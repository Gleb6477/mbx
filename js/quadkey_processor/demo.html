<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Quadkey Processor</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css" type="text/css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 10px 10px 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .left-panel {
                max-width: 100%;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            width: 400px;
            min-width: 400px;
        }

        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-label:hover {
            background-color: #e9ecef;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .results-container {
            margin-top: 20px;
            overflow-x: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-title {
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .results-content {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            max-width: 920px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            overflow: scroll;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .controls button {
            flex: 1;
        }

        .secondary-btn {
            background-color: #6c757d;
        }

        .secondary-btn:hover {
            background-color: #5a6268;
        }

        .success-btn {
            background-color: #28a745;
        }

        .success-btn:hover {
            background-color: #218838;
        }

        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .route-info p {
            margin-bottom: 5px;
        }

        .route-selector {
            margin-bottom: 15px;
        }

        .performance-info {
            background: #e8f4fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .stats-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .route-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-controls button {
            flex: 1;
        }

        /* New styles for country controls */
        .country-controls {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        .country-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .country-control:hover {
            background-color: #e9ecef;
        }

        .country-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .country-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .country-name {
            font-weight: 600;
        }

        .country-count {
            background-color: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .border-control {
            margin-left: 10px;
            font-size: 0.8rem;
            color: #6c757d;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #6c757d;
        }

        .border-control:hover {
            background-color: #6c757d;
            color: white;
        }

        .border-control.excluded {
            background-color: #6c757d;
            color: white;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            margin-top: 30px;
        }

        .select-all-buttons {
            display: flex;
            gap: 5px;
        }

        .select-all-buttons button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .map-controls button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* New styles for CSV upload and processing */
        .csv-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .csv-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a6ee0;
        }

        .csv-processing-btn {
            background: linear-gradient(135deg, #4a6ee0, #764ba2);
        }

        .csv-processing-btn:hover {
            background: linear-gradient(135deg, #3a5ecf, #663aa2);
        }

        .csv-download-btn {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            margin-top: 10px;
        }

        .csv-download-btn:hover {
            background: linear-gradient(135deg, #009985, #85b92d);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .country-selection-item {
            display: flex;
            margin: 10px 0;
            padding: 4px 4px 0px 130px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .country-selection-item input {
            margin-right: 10px;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #confirmSelection {
            background-color: #28a745;
            color: white;
        }

        #cancelSelection {
            background-color: #6c757d;
            color: white;
        }

        .processing-mode-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
        }

        .nested-options {
            margin-top: 10px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .option-description {
            font-size: 0.9rem;
            color: #495057;
        }

        .option-description p {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .option-description p:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #3498db;
        }

        .processing-mode-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        /* Mapbox GL specific styles */
        .mapboxgl-popup {
            max-width: 300px;
        }

        .mapboxgl-popup-content {
            padding: 15px;
            border-radius: 5px;
        }

        .quadkey-highlight {
            fill-opacity: 0.2;
            stroke-width: 2;
        }

        .pulse-marker {
            background: transparent;
            border: none;
        }

        .pulse-dot {
            width: 20px;
            height: 20px;
            background-color: #ff0000;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 0 0 rgba(255, 0, 0, 1);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Route Quadkey Processor</h1>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <h2 class="panel-title">Input & Controls</h2>

                <div class="input-group">
                    <label for="searchQuadkey">Quadkey Search (comma-separated for multiple)</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="searchQuadkey" placeholder="Enter quadkeys">
                        <button id="searchQuadkeyBtn" class="secondary-btn">Search & Zoom</button>
                    </div>
                    <div id="searchResult" style="margin-top: 5px; font-size: 0.9rem; color: #666;"></div>
                    <div id="searchActions" style="margin-top: 10px; display: none;">
                        <button id="addSearchedQuadkeysBtn" class="secondary-btn" style="margin-right: 10px;margin-bottom: 10px">Add All to Results</button>
                        <button id="removeSearchedQuadkeysBtn" class="secondary-btn">Remove All from Results</button>
                    </div>
                </div>

                <div class="input-group">
                    <label for="routeFile">Upload Route JSON File</label>
                    <div class="file-input-container">
                        <input type="file" id="routeFile" class="file-input" accept=".json">
                        <label for="routeFile" class="file-input-label" id="fileInputLabel">Choose a JSON file</label>
                    </div>
                </div>

                <div class="input-group route-selector" id="routeSelectorContainer" style="display: none;">
                    <label for="routeSelect">Select Route</label>
                    <select id="routeSelect"></select>
                </div>

                <div class="route-controls">
                    <button id="downloadRouteBtn" class="secondary-btn" disabled>Download Route GeoJSON</button>
                    <button id="copyWktBtn" class="secondary-btn" disabled>Copy WKT</button>
                </div>

                <div class="input-group">
                    <label for="zoomLevel">Zoom Level (for Quadkey Calculation)</label>
                    <input type="number" id="zoomLevel" min="1" max="18" value="12">
                </div>

                <div class="input-group">
                    <label for="processingMode">Attribute</label>
                    <div id="processingModeContainer">
                        <select id="processingMode" class="processing-mode-select">
                            <option value="speed_limits">Speed Limits</option>
                            <option value="oneways">Oneways</option>
                            <option value="here_oneways">HERE Oneways</option>
                        </select>
                    </div>
                </div>

                <div class="map-controls">
                    <button id="addQuadkeyModeBtn" class="secondary-btn">Add Quadkey Mode</button>
                    <button id="removeQuadkeyModeBtn" class="secondary-btn">Remove Quadkey Mode</button>
                </div>

                <div class="status-message" id="statusMessage"></div>

                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing route data...</p>
                </div>

                <div class="route-info" id="routeInfo" style="display: none;">
                    <p><strong>Route Information</strong></p>
                    <p id="routeDetails"></p>
                </div>

                <div class="controls">
                    <button id="processBtn" disabled>Calculate Quadkeys</button>
                    <button id="downloadGeoJSONBtn" class="secondary-btn" disabled>Download Results GeoJSON</button>
                </div>

                <!-- Country Controls Section -->
                <div id="countryControlsContainer" style="display: none;">
                    <div class="controls-header">
                        <h3 class="panel-title">Country Controls</h3>
                        <div class="select-all-buttons">
                            <button id="selectAllBtn" class="secondary-btn">All</button>
                            <button id="selectNoneBtn" class="secondary-btn">None</button>
                        </div>
                    </div>
                    <div class="country-controls" id="countryControls">
                        <!-- Country controls will be dynamically added here -->
                    </div>
                </div>

                <div class="stats-info" id="statsInfo" style="display: none;">
                    <p><strong>Processing Statistics</strong></p>
                    <p id="statsDetails"></p>
                </div>

                <!-- CSV Upload Section -->
                <div class="csv-section">
                    <h3 class="panel-title">Roads CSV Processing</h3>

                    <div class="input-group">
                        <label for="csvFile">Upload Roads CSV File</label>
                        <div class="file-input-container">
                            <input type="file" id="csvFile" class="file-input" accept=".csv">
                            <label for="csvFile" class="file-input-label" id="csvInputLabel">Choose a Roads CSV file</label>
                        </div>
                    </div>

                    <button id="processCSVBtn" class="csv-processing-btn" disabled>Process Roads CSV</button>
                    <button id="downloadCSVResultsBtn" class="csv-download-btn" disabled>Download Roads GeoJSON</button>
                </div>
                <div class="csv-section" style="margin-top: 20px;">
                    <h3 class="panel-title">Signs CSV Processing</h3>

                    <div class="input-group">
                        <label for="signsCsvFile">Upload Signs CSV File</label>
                        <div class="file-input-container">
                            <input type="file" id="signsCsvFile" class="file-input" accept=".csv">
                            <label for="signsCsvFile" class="file-input-label" id="signsCsvInputLabel">Choose a Signs CSV file</label>
                        </div>
                    </div>

                    <button id="processSignsCSVBtn" class="csv-processing-btn" disabled>Process Signs CSV</button>
                    <button id="downloadCombinedResultsBtn" class="csv-download-btn" disabled>Download Combined GeoJSON</button>
                </div>
            </div>
            <div class="panel">
                <h2 class="panel-title">Map & Results</h2>

                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="results-container">
                    <div class="results-header">
                        <h3 class="results-title">Quadkeys Results</h3>
                        <div style="display: flex">
                            <button id="copyResultsBtn" class="secondary-btn" style="margin-left:20px" disabled>Copy Results</button>
                            <button id="copySqlResultsBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy roads SQL</button>
                            <button id="copySignsSqlBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy signs SQL</button>
                        </div>
                    </div>
                    <div class="results-content" id="resultsOutput">
                        No results yet. Upload a route file and click "Calculate Quadkeys".
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Global variables
        let map;
        let currentRouteData = null;
        let currentRouteIndex = 0;
        let countryCache = {};
        let processingController = null;
        let currentCountryQuadkeys = null;
        let quadkeyCountriesMap = new Map();
        let countryControlsState = {};
        let countryBorderExclusions = new Set();
        let addQuadkeyMode = false;
        let removeQuadkeyMode = false;
        let currentZoomLevel = 12;
        let originalStats = null;
        let csvRoadsData = [];
        let processedRoadsGeoJSON = null;
        let query = '';
        const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2NvdHRzZmFybGV5OTMiLCJhIjoiY2o4ODJxNjh4MWVndjJ3cWI5ODRlZ2hnayJ9.w9-dF3jh-GtQzk9h0wBUbw';
        mapboxgl.accessToken = MAPBOX_TOKEN;

        // Map layers management
        let mapLayers = {
            route: 'route-line',
            quadkeys: new Map(),
            searchHighlights: new Map(),
            searchMarkers: []
        };

        // Initialize map
        function initMap() {
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [0, 20],
                zoom: 2,
                attributionControl: false
            });

            // Add navigation controls
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            // Add geocoder
            const geocoder = new MapboxGeocoder({
                accessToken: mapboxgl.accessToken,
                mapboxgl: mapboxgl,
                marker: false,
                placeholder: 'Search for city, town, or municipality...',
                countries: '',
                types: 'place,locality,neighborhood,address,region',
                bbox: [-180, -90, 180, 90]
            });

            map.addControl(geocoder, 'top-left');

            // Initialize click handler
            map.on('click', handleMapClick);

            // Initialize geocoder result handler
            geocoder.on('result', function(e) {
                const result = e.result;
            });
        }

        // Handle map click
        async function handleMapClick(e) {
            if (!addQuadkeyMode && !removeQuadkeyMode) return;

            const zoom = parseInt(document.getElementById('zoomLevel').value);
            const tile = tileAtZoom(e.lngLat.lat, e.lngLat.lng, zoom);
            const quadkey = toQuadkey(tile.x, tile.y, zoom);

            // Get countries for this quadkey
            const countries = await getQuadkeyCountries(quadkey);

            if (addQuadkeyMode) {
                if (countries.length > 1) {
                    showCountrySelectionModal(quadkey, countries, 'add');
                } else {
                    addQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            } else if (removeQuadkeyMode) {
                if (!quadkeyCountriesMap.has(quadkey) && (!currentCountryQuadkeys ||
                    !Object.values(currentCountryQuadkeys).flat().includes(quadkey))) {
                    showStatus(`Quadkey ${quadkey} not found in current data`, 'error');
                    return;
                }

                if (countries.length > 1 && quadkeyCountriesMap.has(quadkey)) {
                    const currentCountries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    showCountrySelectionModal(quadkey, currentCountries, 'remove');
                } else {
                    removeQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            }
        }

        // Show country selection modal
        function showCountrySelectionModal(quadkey, countries, action) {
            const modalHTML = `
                <div id="countrySelectionModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <h3>Select Countries for Quadkey: ${quadkey}</h3>
                        <p>This quadkey spans multiple countries. Choose which countries to ${action}:</p>
                        <div id="countrySelectionList">
                            ${countries.map(country => `
                                <div class="country-selection-item">
                                    <label for="sel-${country}">${country}</label>
                                    <input type="checkbox" id="sel-${country}" style="width:20px;height:20px;margin-left:30px; margin-top:3px" value="${country}" checked>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-buttons">
                            <button id="confirmSelection">Confirm</button>
                            <button id="cancelSelection">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer);

            document.getElementById('confirmSelection').addEventListener('click', function() {
                const selectedCountries = [];
                countries.forEach(country => {
                    const checkbox = document.getElementById(`sel-${country}`);
                    if (checkbox.checked) {
                        selectedCountries.push(country);
                    }
                });

                if (selectedCountries.length > 0) {
                    if (action === 'add') {
                        addQuadkey(quadkey, selectedCountries);
                    } else {
                        removeQuadkey(quadkey, selectedCountries);
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }

                document.body.removeChild(modalContainer);
            });

            document.getElementById('cancelSelection').addEventListener('click', function() {
                document.body.removeChild(modalContainer);
            });

            document.getElementById('countrySelectionModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    document.body.removeChild(modalContainer);
                }
            });
        }

        // Convert route to WKT format
        function convertRouteToWKT(route) {
            if (!route || !route.legs) {
                throw new Error('Invalid route data');
            }

            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No coordinates found in route');
            }

            const wktCoordinates = allCoords.map(coord => `${coord[0]} ${coord[1]}`).join(', ');
            return `LINESTRING (${wktCoordinates})`;
        }

        // Copy WKT to clipboard
        document.getElementById('copyWktBtn').addEventListener('click', function() {
            if (!currentRouteData) {
                showStatus('No route data available', 'error');
                return;
            }

            try {
                const route = currentRouteData.routes[currentRouteIndex];
                const wkt = convertRouteToWKT(route);

                navigator.clipboard.writeText(wkt).then(() => {
                    showStatus('WKT copied to clipboard!', 'success');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = wkt;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('WKT copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating WKT: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Add a quadkey to results
        function addQuadkey(quadkey, countries) {
            if (!quadkeyCountriesMap) {
                quadkeyCountriesMap = new Map();
            }
            if (!currentCountryQuadkeys) {
                currentCountryQuadkeys = {};
            }
            if (!countryControlsState) {
                countryControlsState = {};
            }

            quadkeyCountriesMap.set(quadkey, new Set(countries));

            countries.forEach(country => {
                if (!currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = [];
                }
                if (!currentCountryQuadkeys[country].includes(quadkey)) {
                    currentCountryQuadkeys[country].push(quadkey);
                    currentCountryQuadkeys[country].sort();
                }

                countryControlsState[country] = true;
            });

            showStatus(`Added quadkey ${quadkey} for countries: ${countries.join(', ')}`, 'success');

            if (Object.keys(currentCountryQuadkeys).length > 0) {
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            }
        }

        // Remove a quadkey
        function removeQuadkey(quadkey, countries) {
            countries.forEach(country => {
                if (currentCountryQuadkeys && currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = currentCountryQuadkeys[country].filter(q => q !== quadkey);
                    if (currentCountryQuadkeys[country].length === 0) {
                        delete currentCountryQuadkeys[country];
                        delete countryControlsState[country];
                    }
                }
            });

            if (quadkeyCountriesMap) {
                const currentCountries = quadkeyCountriesMap.get(quadkey);
                if (currentCountries) {
                    countries.forEach(country => currentCountries.delete(country));
                    if (currentCountries.size === 0) {
                        quadkeyCountriesMap.delete(quadkey);
                    }
                }
            }

            showStatus(`Removed quadkey ${quadkey} from countries: ${countries.join(', ')}`, 'success');

            if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
                document.getElementById('copySqlResultsBtn').disabled = true;
                document.getElementById('copySignsSqlBtn').disabled = true;
                document.getElementById('countryControlsContainer').style.display = 'none';
            }
        }

        // Initialize processing mode
        function initProcessingMode() {
            const processingModeSelect = document.getElementById('processingMode');
            currentProcessingMode = processingModeSelect.value;

            processingModeSelect.addEventListener('change', function() {
                currentProcessingMode = this.value;
                if (currentCountryQuadkeys) {
                    updateDisplayAndVisualization();
                }
            });
        }

        // Recalculate statistics
        function recalculateStatistics() {
            if (!currentCountryQuadkeys) return;

            let totalQuadkeys = 0;
            let borderQuadkeys = 0;
            let totalCountries = new Set();
            const seenQuadkeys = new Set();

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                totalCountries.add(country);
                quadkeys.forEach(quadkey => {
                    if (!seenQuadkeys.has(quadkey)) {
                        seenQuadkeys.add(quadkey);
                        totalQuadkeys++;
                        const countries = quadkeyCountriesMap.get(quadkey);
                        if (countries && countries.size > 1) {
                            borderQuadkeys++;
                        }
                    }
                });
            }

            const statsEl = document.getElementById('statsDetails');
            statsEl.textContent = `Found ${totalQuadkeys} quadkeys, ${borderQuadkeys} border quadkeys across ${totalCountries.size} countries`;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Show/hide loading indicator
        function setLoading(loading) {
            document.getElementById('loadingIndicator').style.display = loading ? 'block' : 'none';
            document.getElementById('processBtn').disabled = loading;

            if (loading && processingController) {
                processingController.abort();
            }
            processingController = new AbortController();
        }

        // Fast country detection using Mapbox Geocoding
        async function reverseGeocodeCountry(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;

            if (countryCache[cacheKey]) {
                return countryCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=country&access_token=${MAPBOX_TOKEN}`,
                    {
                        signal: processingController?.signal
                    }
                );

                if (!response.ok) {
                    throw new Error(`Mapbox API error: ${response.status}`);
                }

                const data = await response.json();
                let countryCode = 'UNKNOWN';
                if (data.features && data.features.length > 0) {
                    const place = data.features[0];
                    countryCode = place.properties?.short_code?.toUpperCase() || 'UNKNOWN';
                }

                countryCache[cacheKey] = countryCode;
                return countryCode;

            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.warn(`Mapbox geocoding failed for (${lat}, ${lng}):`, error);
                return 'UNKNOWN';
            }
        }

        // Get countries for a quadkey
        async function getQuadkeyCountries(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            const countries = new Set();

            const samplePoints = [
                [bounds.north, bounds.west],
                [bounds.north, bounds.east],
                [bounds.south, bounds.west],
                [bounds.south, bounds.east],
                [(bounds.north + bounds.south) / 2, (bounds.west + bounds.east) / 2]
            ];

            const promises = samplePoints.map(([lat, lng]) => reverseGeocodeCountry(lat, lng));
            const results = await Promise.all(promises);

            results.forEach(country => {
                if (country && country !== 'UNKNOWN') {
                    countries.add(country);
                }
            });

            return Array.from(countries);
        }

        // Parse uploaded JSON file
        document.getElementById('routeFile').addEventListener('change', function(e) {
            currentCountryQuadkeys = null;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.routes || !Array.isArray(data.routes)) {
                        throw new Error('Invalid route file format. Expected "routes" array.');
                    }

                    currentRouteData = data;
                    countryCache = {};

                    document.getElementById('fileInputLabel').textContent = file.name;

                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '';

                    data.routes.forEach((route, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Route ${index + 1}`;
                        routeSelect.appendChild(option);
                    });

                    document.getElementById('routeSelectorContainer').style.display = 'block';
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('downloadRouteBtn').disabled = false;
                    document.getElementById('copyWktBtn').disabled = false;

                    loadRoute(0);
                    showStatus('Route file loaded successfully!', 'success');
                } catch (error) {
                    showStatus(`Error parsing JSON: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Handle route selection change
        document.getElementById('routeSelect').addEventListener('change', function(e) {
            const routeIndex = parseInt(e.target.value);
            loadRoute(routeIndex);
        });

        // Load a route onto the map
        function loadRoute(routeIndex) {
            if (!currentRouteData || !currentRouteData.routes[routeIndex]) {
                showStatus('Invalid route selected', 'error');
                return;
            }

            currentRouteIndex = routeIndex;
            const route = currentRouteData.routes[routeIndex];

            // Remove existing route layer
            if (map.getSource('route')) {
                map.removeLayer('route-line');
                map.removeSource('route');
            }

            const allCoords = [];
            let totalDistance = 0;
            let waypointCount = 0;

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    const geom = step.geometry;
                    if (geom.type === 'LineString' && geom.coordinates) {
                        const latLngs = geom.coordinates.map(coord => [coord[0], coord[1]]);
                        allCoords.push(...latLngs);

                        if (latLngs.length > 1) {
                            for (let i = 1; i < latLngs.length; i++) {
                                totalDistance += calculateDistance(latLngs[i-1], latLngs[i]);
                            }
                        }

                        waypointCount += latLngs.length;
                    }
                });
            });

            // Create route GeoJSON
            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`
                }
            };

            // Add route to map
            map.addSource('route', {
                type: 'geojson',
                data: routeFeature
            });

            map.addLayer({
                id: 'route-line',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#3498db',
                    'line-width': 4,
                    'line-opacity': 0.7
                }
            });

            // Fit bounds to route
            const bounds = getBoundingBox(routeFeature);
            map.fitBounds([[bounds.xMin, bounds.yMin], [bounds.xMax, bounds.yMax]], {
                padding: 50
            });

            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('routeDetails').textContent =
                `Distance: ${(totalDistance / 1000).toFixed(2)} km, Waypoints: ${waypointCount}, Legs: ${route.legs.length}`;

            clearQuadkeyLayers();
            document.getElementById('resultsOutput').textContent =
                'No results yet. Click "Calculate Quadkeys" to process this route.';
            document.getElementById('copyResultsBtn').disabled = true;
            document.getElementById('copySqlResultsBtn').disabled = true;
            document.getElementById('copySignsSqlBtn').disabled = true;
            document.getElementById('downloadGeoJSONBtn').disabled = true;
            document.getElementById('statsInfo').style.display = 'none';
            document.getElementById('countryControlsContainer').style.display = 'none';
            document.getElementById('copyWktBtn').style.display = 'block';

            // Reset modes
            addQuadkeyMode = false;
            removeQuadkeyMode = false;
            document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
            document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
        }

        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371e3;
            const φ1 = coord1[0] * Math.PI / 180;
            const φ2 = coord2[0] * Math.PI / 180;
            const Δφ = (coord2[0] - coord1[0]) * Math.PI / 180;
            const Δλ = (coord2[1] - coord1[1]) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                     Math.cos(φ1) * Math.cos(φ2) *
                     Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Get bounding box
        function getBoundingBox(data) {
            var bounds = {}, coords, point, latitude, longitude;
            coords = data.geometry.coordinates;
            for (var j = 0; j < coords.length; j++) {
                longitude = coords[j][0];
                latitude = coords[j][1];
                bounds.xMin = bounds.xMin < longitude ? bounds.xMin : longitude;
                bounds.xMax = bounds.xMax > longitude ? bounds.xMax : longitude;
                bounds.yMin = bounds.yMin < latitude ? bounds.yMin : latitude;
                bounds.yMax = bounds.yMax > latitude ? bounds.yMax : latitude;
            }
            return bounds;
        }

        // Process route to calculate quadkeys
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!currentRouteData) {
                showStatus('Please upload a route file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Calculating quadkeys using bounding box approach...', 'info');

            try {
                const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
                currentZoomLevel = zoomLevel;
                const route = currentRouteData.routes[currentRouteIndex];

                const startTime = Date.now();
                var { countryQuadkeys, stats, quadkeyCountries } = await getRouteQuadkeysWithCountriesBBox(
                    route,
                    zoomLevel
                );
                const processingTime = (Date.now() - startTime) / 1000;

                currentCountryQuadkeys = countryQuadkeys;
                quadkeyCountriesMap = quadkeyCountries;
                originalStats = stats;

                // Initialize all countries as enabled
                countryControlsState = {};
                countryBorderExclusions.clear();
                Object.keys(countryQuadkeys).forEach(country => {
                    countryControlsState[country] = true;
                });

                createCountryControls(countryQuadkeys, false);
                updateDisplayAndVisualization();

                // Show statistics
                document.getElementById('statsInfo').style.display = 'block';
                document.getElementById('statsDetails').textContent =
                    `Found ${stats.totalQuadkeys} quadkeys, ${stats.borderQuadkeys} border quadkeys in ${processingTime.toFixed(1)}s`;

                showStatus(`Found ${stats.totalQuadkeys} quadkeys across ${Object.keys(countryQuadkeys).length} countries`, 'success');

                document.getElementById('downloadGeoJSONBtn').disabled = false;
                document.getElementById('copyResultsBtn').disabled = false;
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`Error calculating quadkeys: ${error.message}`, 'error');
                    console.error(error);
                }
            } finally {
                setLoading(false);
            }
        });

        // Get quadkeys for a route using bounding box approach
        async function getRouteQuadkeysWithCountriesBBox(route, zoom) {
            var stats = {
                totalQuadkeys: 0,
                borderQuadkeys: 0
            };

            // Extract all coordinates
            const allLineStrings = [];
            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allLineStrings.push(step.geometry.coordinates);
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No valid coordinates found in route');
            }

            // Get bounding box
            const lats = allCoords.map(coord => coord[1]);
            const lngs = allCoords.map(coord => coord[0]);

            const minLon = Math.min(...lngs);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lngs);
            const maxLat = Math.max(...lats);

            showStatus(`Route bounds: ${minLon.toFixed(4)}, ${minLat.toFixed(4)} to ${maxLon.toFixed(4)}, ${maxLat.toFixed(4)}`, 'info');

            // Get all tiles in bounding box
            const tiles = getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom);
            showStatus(`Checking ${tiles.length} tiles for intersection...`, 'info');

            const quadkeyCountries = new Map();

            // Check which tiles intersect with route
            for (let i = 0; i < tiles.length; i++) {
                if (processingController?.signal.aborted) {
                    throw new DOMException('Aborted', 'AbortError');
                }

                const tile = tiles[i];
                const quadkey = toQuadkey(tile.x, tile.y, zoom);
                const tileBounds = tileToBounds(tile);

                let intersects = false;
                for (const lineString of allLineStrings) {
                    if (lineStringIntersectsBounds(lineString, tileBounds)) {
                        intersects = true;
                        break;
                    }
                }

                if (intersects) {
                    const countries = await getQuadkeyCountries(quadkey);
                    if (countries.length > 1) {
                        stats.borderQuadkeys++;
                    }
                    quadkeyCountries.set(quadkey, new Set(countries));

                    if (i % 10 === 0) {
                        showStatus(`Processing tiles... ${Math.round((i / tiles.length) * 100)}%`, 'info');
                    }
                }
            }

            stats.totalQuadkeys = quadkeyCountries.size;

            // Convert to country->quadkeys mapping
            const countryQuadkeys = {};
            for (const [quadkey, countries] of quadkeyCountries.entries()) {
                for (const country of countries) {
                    if (!countryQuadkeys[country]) {
                        countryQuadkeys[country] = new Set();
                    }
                    countryQuadkeys[country].add(quadkey);
                }
            }

            // Convert Sets to Arrays and sort
            const result = {};
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                result[country] = Array.from(quadkeys).sort();
            }

            return {
                countryQuadkeys: result,
                stats,
                quadkeyCountries: quadkeyCountries
            };
        }

        // Create country controls UI
        function createCountryControls(countryQuadkeys, qkManipulationEvent) {
            const container = document.getElementById('countryControls');
            container.innerHTML = '';

            const sortedCountries = Object.keys(countryQuadkeys).sort();

            sortedCountries.forEach(country => {
                const quadkeys = countryQuadkeys[country];
                const count = quadkeys.length;

                const controlDiv = document.createElement('div');
                controlDiv.className = 'country-control';
                const check = qkManipulationEvent ? (countryControlsState[country] ? 'checked' : '') : 'checked';

                controlDiv.innerHTML = `
                    <input type="checkbox" class="country-checkbox" id="chk-${country}" ${check}>
                    <div class="country-label">
                        <span class="country-name">${country}</span>
                        <span class="country-count">${count}</span>
                    </div>
                    <button class="border-control" data-country="${country}" title="Exclude border quadkeys for ${country}">No Borders</button>
                `;

                container.appendChild(controlDiv);

                // Add event listener for checkbox
                const checkbox = controlDiv.querySelector('.country-checkbox');
                checkbox.addEventListener('change', function() {
                    countryControlsState[country] = this.checked;
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });

                // Add event listener for border control
                const borderBtn = controlDiv.querySelector('.border-control');
                borderBtn.addEventListener('click', function() {
                    const country = this.getAttribute('data-country');
                    if (countryBorderExclusions.has(country)) {
                        countryBorderExclusions.delete(country);
                        this.classList.remove('excluded');
                        this.textContent = 'No Borders';
                    } else {
                        countryBorderExclusions.add(country);
                        this.classList.add('excluded');
                        this.textContent = 'With Borders';
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });
            });
        }

        // Update display and visualization
        function updateDisplayAndVisualization() {
            if (!currentCountryQuadkeys) {
                document.getElementById('resultsOutput').textContent = 'No quadkeys found.';
                clearQuadkeyLayers();
                return;
            }

            // Filter quadkeys based on country controls and border exclusions
            const filteredCountryQuadkeys = {};

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (countryControlsState[country]) {
                    let filteredQuadkeys = [...quadkeys];

                    if (countryBorderExclusions && countryBorderExclusions.has(country)) {
                        filteredQuadkeys = filteredQuadkeys.filter(quadkey => {
                            const countries = quadkeyCountriesMap.get(quadkey);
                            return countries && countries.size === 1 && countries.has(country);
                        });
                    }

                    if (filteredQuadkeys.length > 0) {
                        filteredCountryQuadkeys[country] = filteredQuadkeys;
                    }
                }
            }

            displayResults(filteredCountryQuadkeys);
            visualizeQuadkeys(filteredCountryQuadkeys, currentZoomLevel);
        }

        // Select all countries
        document.getElementById('selectAllBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = true;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = true;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Select none countries
        document.getElementById('selectNoneBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = false;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = false;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Visualize quadkeys on map
        function visualizeQuadkeys(countryQuadkeys, zoom) {
            clearQuadkeyLayers();

            if (!countryQuadkeys || Object.keys(countryQuadkeys).length === 0) {
                return;
            }

            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
            ];

            let colorIndex = 0;
            const countryColors = {};
            const quadkeyCountries = new Map();

            // First pass: count how many countries each quadkey belongs to
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                for (const quadkey of quadkeys) {
                    if (!quadkeyCountries.has(quadkey)) {
                        quadkeyCountries.set(quadkey, new Set());
                    }
                    quadkeyCountries.get(quadkey).add(country);
                }
            }

            // Second pass: visualize with appropriate colors
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                if (!countryColors[country]) {
                    countryColors[country] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const baseColor = countryColors[country];

                for (const quadkey of quadkeys) {
                    const bounds = quadkeyToBounds(quadkey);
                    const countriesForQuadkey = quadkeyCountries.get(quadkey);

                    let color, fillOpacity;
                    if (countriesForQuadkey.size > 1) {
                        color = '#ffeb3b';
                        fillOpacity = 0.3;
                    } else {
                        color = baseColor;
                        fillOpacity = 0.3;
                    }

                    // Create polygon GeoJSON for quadkey
                    const polygonGeoJSON = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                [bounds.west, bounds.south],
                                [bounds.west, bounds.north],
                                [bounds.east, bounds.north],
                                [bounds.east, bounds.south],
                                [bounds.west, bounds.south]
                            ]]
                        },
                        properties: {
                            quadkey: quadkey,
                            country: country,
                            isBorder: countriesForQuadkey.size > 1
                        }
                    };

                    const sourceId = `quadkey-${quadkey}`;
                    const layerId = `quadkey-layer-${quadkey}`;

                    // Add source
                    map.addSource(sourceId, {
                        type: 'geojson',
                        data: polygonGeoJSON
                    });

                    // Add fill layer
                    map.addLayer({
                        id: layerId + '-fill',
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': color,
                            'fill-opacity': fillOpacity
                        }
                    });

                    // Add outline layer
                    map.addLayer({
                        id: layerId + '-outline',
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': color,
                            'line-width': 2
                        }
                    });

                    // Store layer references
                    if (!mapLayers.quadkeys.has(quadkey)) {
                        mapLayers.quadkeys.set(quadkey, []);
                    }
                    mapLayers.quadkeys.get(quadkey).push(layerId + '-fill', layerId + '-outline');

                    // Add click handler
                    map.on('click', layerId + '-fill', (e) => {
                        if (removeQuadkeyMode) {
                            const clickedQuadkey = quadkey;
                            const countries = Array.from(quadkeyCountriesMap.get(clickedQuadkey) || []);

                            if (countries.length > 1) {
                                showCountrySelectionModal(clickedQuadkey, countries, 'remove');
                            } else {
                                removeQuadkey(clickedQuadkey, countries);
                                updateDisplayAndVisualization();
                                recalculateStatistics();
                                if (currentCountryQuadkeys) {
                                    createCountryControls(currentCountryQuadkeys, true);
                                }
                            }
                        } else {
                            navigator.clipboard.writeText(quadkey).then(() => {
                                showStatus('Quadkey copied to clipboard!', 'success');
                            }).catch(err => {
                                console.error('Copy failed:', err);
                            });
                        }
                    });

                    // Change cursor on hover
                    map.on('mouseenter', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });

                    map.on('mouseleave', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = '';
                    });
                }
            }
        }

        // Clear quadkey layers from map
        function clearQuadkeyLayers() {
            mapLayers.quadkeys.forEach((layers, quadkey) => {
                layers.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });
                const sourceId = `quadkey-${quadkey}`;
                if (map.getSource(sourceId)) {
                    map.removeSource(sourceId);
                }
            });
            mapLayers.quadkeys.clear();
        }

        // Copy results to clipboard
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsText = document.getElementById('resultsOutput').textContent;

            navigator.clipboard.writeText(resultsText).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });

        // Quadkey utility functions
        function tileAtZoom(lat, lng, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);
            return { x, y, z: zoom };
        }

        function toQuadkey(x, y, z) {
            let quadkey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit += 1;
                if ((y & mask) !== 0) digit += 2;
                quadkey += digit.toString();
            }
            return quadkey;
        }

        function quadkeyToBounds(quadkey) {
            let x = 0, y = 0;
            const z = quadkey.length;

            for (let i = z; i > 0; i--) {
                const mask = 1 << (i - 1);
                const q = parseInt(quadkey[z - i]);
                if (q & 1) x |= mask;
                if (q & 2) y |= mask;
            }

            return calculateTileBounds(x, y, z);
        }

        function calculateTileBounds(x, y, z) {
            const n = Math.pow(2, z);
            const west = x / n * 360 - 180;
            const east = (x + 1) / n * 360 - 180;
            const north = (Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI);
            const south = (Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI);
            return { west, south, east, north };
        }

        function tileToBounds(tile) {
            return calculateTileBounds(tile.x, tile.y, tile.z);
        }

        function getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom) {
            const tiles = [];
            const topLeft = [maxLat, minLon];
            const bottomRight = [minLat, maxLon];
            const topLeftTile = tileAtZoom(topLeft[0], topLeft[1], zoom);
            const bottomRightTile = tileAtZoom(bottomRight[0], bottomRight[1], zoom);

            for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {
                for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                    tiles.push({ x, y, z: zoom });
                }
            }
            return tiles;
        }

        // Line intersection functions
        function lineStringIntersectsBounds(lineString, bounds) {
            const lineBounds = getLineStringBounds(lineString);
            if (!boundsIntersect(lineBounds, bounds)) {
                return false;
            }

            for (let i = 1; i < lineString.length; i++) {
                const prevCoord = lineString[i - 1];
                const currCoord = lineString[i];
                if (lineSegmentIntersectsBounds(prevCoord, currCoord, bounds)) {
                    return true;
                }
            }
            return false;
        }

        function getLineStringBounds(lineString) {
            const lats = lineString.map(coord => coord[1]);
            const lngs = lineString.map(coord => coord[0]);
            return {
                west: Math.min(...lngs),
                east: Math.max(...lngs),
                south: Math.min(...lats),
                north: Math.max(...lats)
            };
        }

        function boundsIntersect(bounds1, bounds2) {
            return !(bounds1.east < bounds2.west ||
                     bounds1.west > bounds2.east ||
                     bounds1.south > bounds2.north ||
                     bounds1.north < bounds2.south);
        }

        function lineSegmentIntersectsBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;
                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;
                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    break;
                } else {
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }
            return accept;
        }

        // Display results
        function displayResults(countryQuadkeys) {
            const firstRoutePoint = getFirstRoutePoint();
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            let output = '';
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            let strFormattedDate = `'${formattedDate}'`;

            let countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                // Sort quadkeys by distance from first route point
                const sortedQuadkeys = quadkeys.map(quadkey => {
                    const bounds = quadkeyToBounds(quadkey);
                    const centerLat = (bounds.north + bounds.south) / 2;
                    const centerLng = (bounds.west + bounds.east) / 2;
                    const distance = calculateDistance(
                        [firstRoutePoint.lat, firstRoutePoint.lng],
                        [centerLat, centerLng]
                    );
                    return { quadkey, distance };
                }).sort((a, b) => a.distance - b.distance)
                  .map(item => item.quadkey);

                // Group quadkeys by zoom level
                const quadkeysByZoom = {};
                for (let qk of sortedQuadkeys) {
                    const zoomLevel = qk.length;
                    if (zoomLevel in quadkeysByZoom) {
                        quadkeysByZoom[zoomLevel].push(qk);
                    } else {
                        quadkeysByZoom[zoomLevel] = [qk];
                    }
                }

                // Build cardinality condition
                let cardinalityCondition = '';
                for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
                    let quads = getQkStringifyArray(qks);
                    cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
                }

                if (cardinalityCondition) {
                    cardinalityCondition = cardinalityCondition.slice(0, -4);
                    const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
                    countryConditions.push(countryCondition);
                }

                const count = sortedQuadkeys.length;
                output += `${country}: ${count} quadkeys\n`;
                output += sortedQuadkeys.join(',') + '\n\n';
            }

            // Combine all country conditions
            let finalCountryCondition = '';
            if (countryConditions.length > 0) {
                if (countryConditions.length === 1) {
                    finalCountryCondition = countryConditions[0];
                } else {
                    finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
                }
            }

            // Build the complete query
            query = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country
                from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
                where dt = ${strFormattedDate}
                and ${finalCountryCondition}
                and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;

            document.getElementById('resultsOutput').textContent = output.trim() || 'No quadkeys found for this route.';
        }

        // Get QK stringify array
        function getQkStringifyArray(qk_array){
            let qks = "";
            for (let item of qk_array){
                qks+=`'${item}',`
            }
            return qks.slice(0, -1);
        }

        // Get first point of current route
        function getFirstRoutePoint() {
            if (!currentRouteData || !currentRouteData.routes[currentRouteIndex]) {
                return { lat: 0, lng: 0 };
            }

            const route = currentRouteData.routes[currentRouteIndex];
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates && step.geometry.coordinates.length > 0) {
                        const firstCoord = step.geometry.coordinates[0];
                        return { lat: firstCoord[1], lng: firstCoord[0] };
                    }
                }
            }
            return { lat: 0, lng: 0 };
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initProcessingMode();

            // Add quadkey mode button
            document.getElementById('addQuadkeyModeBtn').addEventListener('click', function() {
                addQuadkeyMode = !addQuadkeyMode;
                removeQuadkeyMode = false;
                if (addQuadkeyMode) {
                    this.style.backgroundColor = '#28a745';
                    document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Add Quadkey Mode: Click on map to add quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Add Quadkey Mode disabled', 'info');
                }
            });

            // Remove quadkey mode button
            document.getElementById('removeQuadkeyModeBtn').addEventListener('click', function() {
                removeQuadkeyMode = !removeQuadkeyMode;
                addQuadkeyMode = false;
                if (removeQuadkeyMode) {
                    this.style.backgroundColor = '#dc3545';
                    document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode: Click on map to remove quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode disabled', 'info');
                }
            });

            showStatus('Ready. Upload a route file to begin.', 'info');
        });
    </script>
</body>
</html>
