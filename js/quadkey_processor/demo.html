<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Quadkey Processor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 10px 10px 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .left-panel {
                max-width: 100%;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            width: 400px;
            min-width: 400px;
        }

        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-label:hover {
            background-color: #e9ecef;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .results-container {
            margin-top: 20px;
            overflow-x: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-title {
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .results-content {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            max-width: 920px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            overflow: scroll;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .controls button {
            flex: 1;
        }

        .secondary-btn {
            background-color: #6c757d;
        }

        .secondary-btn:hover {
            background-color: #5a6268;
        }

        .success-btn {
            background-color: #28a745;
        }

        .success-btn:hover {
            background-color: #218838;
        }

        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .route-info p {
            margin-bottom: 5px;
        }

        .route-selector {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .performance-info {
            background: #e8f4fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .stats-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .route-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-controls button {
            flex: 1;
        }

        /* New styles for country controls */
        .country-controls {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        .country-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .country-control:hover {
            background-color: #e9ecef;
        }

        .country-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .country-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .country-name {
            font-weight: 600;
        }

        .country-count {
            background-color: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .border-control {
            margin-left: 10px;
            font-size: 0.8rem;
            color: #6c757d;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #6c757d;
        }

        .border-control:hover {
            background-color: #6c757d;
            color: white;
        }

        .border-control.excluded {
            background-color: #6c757d;
            color: white;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            margin-top: 30px;
        }

        .select-all-buttons {
            display: flex;
            gap: 5px;
        }

        .select-all-buttons button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .map-controls button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* New styles for CSV upload and processing */
        .csv-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .csv-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a6ee0;
        }

        .csv-processing-btn {
            background: linear-gradient(135deg, #4a6ee0, #764ba2);
        }

        .csv-processing-btn:hover {
            background: linear-gradient(135deg, #3a5ecf, #663aa2);
        }

        .csv-download-btn {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            margin-top: 10px;
        }

        .csv-download-btn:hover {
            background: linear-gradient(135deg, #009985, #85b92d);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .country-selection-item {
            display: flex;
            margin: 10px 0;
            padding: 4px 4px 0px 130px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .country-selection-item input {
            margin-right: 10px;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #confirmSelection {
            background-color: #28a745;
            color: white;
        }

        #cancelSelection {
            background-color: #6c757d;
            color: white;
        }

        .processing-mode-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
        }

        .nested-options {
            margin-top: 10px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .option-description {
            font-size: 0.9rem;
            color: #495057;
        }

        .option-description p {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .option-description p:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #3498db;
        }

        .processing-mode-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        <style>
</style>
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Route Quadkey Processor</h1>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <h2 class="panel-title">Input & Controls</h2>

        <div class="input-group">
            <label for="searchQuadkey">Quadkey Search (comma-separated for multiple)</label>
            <div style="display: flex; gap: 10px;">
                <input type="text" id="searchQuadkey" placeholder="Enter quadkeys">
                <button id="searchQuadkeyBtn" class="secondary-btn">Search & Zoom</button>
            </div>
            <div id="searchResult" style="margin-top: 5px; font-size: 0.9rem; color: #666;"></div>
            <div id="searchActions" style="margin-top: 10px; display: none;">
                <button id="addSearchedQuadkeysBtn" class="secondary-btn" style="margin-right: 10px;margin-bottom: 10px">Add All to Results</button>
                <button id="removeSearchedQuadkeysBtn" class="secondary-btn">Remove All from Results</button>
            </div>
        </div>

                <div class="input-group">
                    <label for="routeFile">Upload Route JSON File</label>
                    <div class="file-input-container">
                        <input type="file" id="routeFile" class="file-input" accept=".json">
                        <label for="routeFile" class="file-input-label" id="fileInputLabel">Choose a JSON file</label>
                    </div>
                </div>

                <div class="input-group route-selector" id="routeSelectorContainer" style="display: none;">
                    <label for="routeSelect">Select Route</label>
                    <select id="routeSelect"></select>
                </div>

                <div class="route-controls">
                    <button id="downloadRouteBtn" class="secondary-btn" disabled>Download Route GeoJSON</button>
                    <button id="copyWktBtn" class="secondary-btn" disabled>Copy WKT</button>
                </div>

                <div class="input-group">
                    <label for="zoomLevel">Zoom Level (for Quadkey Calculation)</label>
                    <input type="number" id="zoomLevel" min="1" max="18" value="12">
                </div>

                <!-- Add this after the zoom level input -->
                <div class="input-group">
                    <label for="processingMode">Attribute</label>
                    <div id="processingModeContainer">
                        <select id="processingMode" class="processing-mode-select">
                            <option value="speed_limits">Speed Limits</option>
                            <option value="oneways">Oneways</option>
                            <option value="here_oneways">HERE Oneways</option>
                        </select>
                    </div>
                </div>

                <div class="map-controls">
                    <button id="addQuadkeyModeBtn" class="secondary-btn">Add Quadkey Mode</button>
                    <button id="removeQuadkeyModeBtn" class="secondary-btn">Remove Quadkey Mode</button>
                </div>

                <div class="status-message" id="statusMessage"></div>

                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing route data...</p>
                </div>

                <div class="route-info" id="routeInfo" style="display: none;">
                    <p><strong>Route Information</strong></p>
                    <p id="routeDetails"></p>
                </div>

                <div class="controls">
                    <button id="processBtn" disabled>Calculate Quadkeys</button>
                    <button id="downloadGeoJSONBtn" class="secondary-btn" disabled>Download Results GeoJSON</button>
                </div>

                <!-- Country Controls Section -->
                <div id="countryControlsContainer" style="display: none;">
                    <div class="controls-header">
                        <h3 class="panel-title">Country Controls</h3>
                        <div class="select-all-buttons">
                            <button id="selectAllBtn" class="secondary-btn">All</button>
                            <button id="selectNoneBtn" class="secondary-btn">None</button>
                        </div>
                    </div>
                    <div class="country-controls" id="countryControls">
                        <!-- Country controls will be dynamically added here -->
                    </div>
                </div>

                <div class="stats-info" id="statsInfo" style="display: none;">
                    <p><strong>Processing Statistics</strong></p>
                    <p id="statsDetails"></p>
                </div>

                <!-- CSV Upload Section -->
                <div class="csv-section">
                    <h3 class="panel-title">Roads CSV Processing</h3>

                    <div class="input-group">
                        <label for="csvFile">Upload Roads CSV File</label>
                        <div class="file-input-container">
                            <input type="file" id="csvFile" class="file-input" accept=".csv">
                            <label for="csvFile" class="file-input-label" id="csvInputLabel">Choose a Roads CSV file</label>
                        </div>
                    </div>

                    <button id="processCSVBtn" class="csv-processing-btn" disabled>Process Roads CSV</button>
                    <button id="downloadCSVResultsBtn" class="csv-download-btn" disabled>Download Roads GeoJSON</button>
                </div>
                <div class="csv-section" style="margin-top: 20px;">
                    <h3 class="panel-title">Signs CSV Processing</h3>

                    <div class="input-group">
                        <label for="signsCsvFile">Upload Signs CSV File</label>
                        <div class="file-input-container">
                            <input type="file" id="signsCsvFile" class="file-input" accept=".csv">
                            <label for="signsCsvFile" class="file-input-label" id="signsCsvInputLabel">Choose a Signs CSV file</label>
                        </div>
                    </div>

                    <button id="processSignsCSVBtn" class="csv-processing-btn" disabled>Process Signs CSV</button>
                    <button id="downloadCombinedResultsBtn" class="csv-download-btn" disabled>Download Combined GeoJSON</button>
                </div>
            </div>
            <div class="panel">
                <h2 class="panel-title">Map & Results</h2>

                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="results-container">
                    <div class="results-header">
                        <h3 class="results-title">Quadkeys Results</h3>
                        <div style="display: flex">
                            <button id="copyResultsBtn" class="secondary-btn" style="margin-left:20px" disabled>Copy Results</button>
                            <button id="copySqlResultsBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy roads SQL</button>
                            <button id="copySignsSqlBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy signs SQL</button>
                        </div>
                    </div>
                    <div class="results-content" id="resultsOutput">
                        No results yet. Upload a route file and click "Calculate Quadkeys".
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let routeLayer;
        let quadkeyLayers = {};
        let currentRouteData = null;
        let currentRouteIndex = 0;
        let countryCache = {};
        let processingController = null;
        let currentCountryQuadkeys = null;
        let quadkeyCountriesMap = new Map(); // Maps quadkey to array of countries
        let countryControlsState = {}; // Tracks which countries are enabled/disabled
        let countryBorderExclusions = new Set(); // Tracks which countries have border quadkeys excluded
        let addQuadkeyMode = false;
        let removeQuadkeyMode = false;
        let currentZoomLevel = 12;
        let originalStats = null;
        let csvRoadsData = []; // Store CSV roads data
        let processedRoadsGeoJSON = null; // Store processed roads GeoJSON
        let query = '';
        const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2NvdHRzZmFybGV5OTMiLCJhIjoiY2o4ODJxNjh4MWVndjJ3cWI5ODRlZ2hnayJ9.w9-dF3jh-GtQzk9h0wBUbw';

        // Initialize the map
        function initMap() {
            map = L.map('map').setView([40.7128, -74.0060], 10);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add click listener for adding/removing quadkeys
            map.on('click', function(e) {
                if (addQuadkeyMode) {
                    handleMapClick(e.latlng);
                }
            });
        }

        // Handle map click for adding/removing quadkeys
        async function handleMapClick(latlng) {
            const zoom = parseInt(document.getElementById('zoomLevel').value);
            const tile = tileAtZoom(latlng.lat, latlng.lng, zoom);
            const quadkey = toQuadkey(tile.x, tile.y, zoom);

            // Get countries for this quadkey
            const countries = await getQuadkeyCountries(quadkey);

            if (addQuadkeyMode) {
                // If it's a border quadkey (multiple countries), show country selection
                if (countries.length > 1) {
                    showCountrySelectionModal(quadkey, countries, 'add');
                } else {
                    addQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    // Create or update country controls if needed
                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            } else if (removeQuadkeyMode) {
                // Check if we have this quadkey in our data
                if (!quadkeyCountriesMap.has(quadkey) && (!currentCountryQuadkeys ||
                    !Object.values(currentCountryQuadkeys).flat().includes(quadkey))) {
                    showStatus(`Quadkey ${quadkey} not found in current data`, 'error');
                    return;
                }

                // If it's a border quadkey (multiple countries), show country selection for removal
                if (countries.length > 1 && quadkeyCountriesMap.has(quadkey)) {
                    const currentCountries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    showCountrySelectionModal(quadkey, currentCountries, 'remove');
                } else {
                    removeQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    // Update country controls if they exist
                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            }
        }

        function showCountrySelectionModal(quadkey, countries, action) {
            // Create modal HTML
            const modalHTML = `
                <div id="countrySelectionModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <h3>Select Countries for Quadkey: ${quadkey}</h3>
                        <p>This quadkey spans multiple countries. Choose which countries to ${action}:</p>
                        <div id="countrySelectionList">
                            ${countries.map(country => `
                                <div class="country-selection-item">
                                    <label for="sel-${country}">${country}</label>
                                    <input type="checkbox" id="sel-${country}" style="width:20px;height:20px;margin-left:30px; margin-top:3px" value="${country}" checked>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-buttons">
                            <button id="confirmSelection">Confirm</button>
                            <button id="cancelSelection">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to page
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer);

            // Add event listeners
            document.getElementById('confirmSelection').addEventListener('click', function() {
                const selectedCountries = [];
                countries.forEach(country => {
                    const checkbox = document.getElementById(`sel-${country}`);
                    if (checkbox.checked) {
                        selectedCountries.push(country);
                    }
                });

                if (selectedCountries.length > 0) {
                    if (action === 'add') {
                        addQuadkey(quadkey, selectedCountries);
                    } else {
                        removeQuadkey(quadkey, selectedCountries);
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }

                // Close modal
                document.body.removeChild(modalContainer);
            });

            document.getElementById('cancelSelection').addEventListener('click', function() {
                document.body.removeChild(modalContainer);
            });

            // Close modal when clicking outside
            document.getElementById('countrySelectionModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    document.body.removeChild(modalContainer);
                }
            });
        }

        // Convert route to WKT format
        function convertRouteToWKT(route) {
            if (!route || !route.legs) {
                throw new Error('Invalid route data');
            }

            const allCoords = [];

            // Extract all coordinates from the route
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No coordinates found in route');
            }

            // Convert coordinates to WKT format
            const wktCoordinates = allCoords.map(coord => `${coord[0]} ${coord[1]}`).join(', ');

            return `LINESTRING (${wktCoordinates})`;
        }

        // Copy WKT to clipboard
        document.getElementById('copyWktBtn').addEventListener('click', function() {
            if (!currentRouteData) {
                showStatus('No route data available', 'error');
                return;
            }

            try {
                const route = currentRouteData.routes[currentRouteIndex];
                const wkt = convertRouteToWKT(route);

                navigator.clipboard.writeText(wkt).then(() => {
                    showStatus('WKT copied to clipboard!', 'success');
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = wkt;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('WKT copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating WKT: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Add a quadkey to the results with specific countries
        function addQuadkey(quadkey, countries) {
            // Initialize data structures if they don't exist
            if (!quadkeyCountriesMap) {
                quadkeyCountriesMap = new Map();
            }
            if (!currentCountryQuadkeys) {
                currentCountryQuadkeys = {};
            }
            if (!countryControlsState) {
                countryControlsState = {};
            }

            // Add to quadkeyCountriesMap
            quadkeyCountriesMap.set(quadkey, new Set(countries));

            // Add to each country's quadkey set
            countries.forEach(country => {
                if (!currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = [];
                }
                if (!currentCountryQuadkeys[country].includes(quadkey)) {
                    currentCountryQuadkeys[country].push(quadkey);
                    currentCountryQuadkeys[country].sort();
                }

                // Enable this country in controls
                countryControlsState[country] = true;
            });

            showStatus(`Added quadkey ${quadkey} for countries: ${countries.join(', ')}`, 'success');

            // Enable SQL buttons if we now have data
            if (Object.keys(currentCountryQuadkeys).length > 0) {
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            }
        }

        // Remove a quadkey from specific countries
        function removeQuadkey(quadkey, countries) {
            // Remove from each specified country's quadkey set
            countries.forEach(country => {
                if (currentCountryQuadkeys && currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = currentCountryQuadkeys[country].filter(q => q !== quadkey);
                    // Remove country entry if no quadkeys left
                    if (currentCountryQuadkeys[country].length === 0) {
                        delete currentCountryQuadkeys[country];
                        delete countryControlsState[country];
                    }
                }
            });

            // Update quadkeyCountriesMap - remove countries or entire quadkey
            if (quadkeyCountriesMap) {
                const currentCountries = quadkeyCountriesMap.get(quadkey);
                if (currentCountries) {
                    countries.forEach(country => currentCountries.delete(country));

                    // If no countries left, remove the quadkey entirely
                    if (currentCountries.size === 0) {
                        quadkeyCountriesMap.delete(quadkey);
                    }
                }
            }

            showStatus(`Removed quadkey ${quadkey} from countries: ${countries.join(', ')}`, 'success');

            // Disable SQL buttons if no data left
            if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
                document.getElementById('copySqlResultsBtn').disabled = true;
                document.getElementById('copySignsSqlBtn').disabled = true;
                document.getElementById('countryControlsContainer').style.display = 'none';
            }
        }

        // Global variable for processing mode
        let currentProcessingMode = 'speed_limits';

        // Initialize processing mode selector
        function initProcessingMode() {
            const processingModeSelect = document.getElementById('processingMode');
            const speedLimitsOptions = document.getElementById('speedLimitsOptions');
            const onewaysOptions = document.getElementById('onewaysOptions');

            // Set initial mode
            currentProcessingMode = processingModeSelect.value;

            // Handle mode change
            processingModeSelect.addEventListener('change', function() {
                currentProcessingMode = this.value;

<!--                // Show/hide nested options-->
<!--                if (currentProcessingMode === 'speed_limits') {-->
<!--                    speedLimitsOptions.style.display = 'block';-->
<!--                    onewaysOptions.style.display = 'none';-->
<!--                    showStatus('Speed Limits mode: Will include all maxspeed tags', 'info');-->
<!--                } else if (currentProcessingMode === 'oneways'){-->
<!--                    speedLimitsOptions.style.display = 'none';-->
<!--                    onewaysOptions.style.display = 'block';-->
<!--                    showStatus('Oneways mode: Simplified output, no maxspeed tags', 'info');-->
<!--                } else if (currentProcessingMode === 'here_oneways'){-->
<!--                    speedLimitsOptions.style.display = 'none';-->
<!--                    onewaysOptions.style.display = 'block';-->
<!--                    showStatus('Oneways mode: Simplified output, no maxspeed tags', 'info');-->
<!--                }-->

                // Update any existing results if we have data
                if (currentCountryQuadkeys) {
                    updateDisplayAndVisualization();
                }
            });
        }

        // Recalculate statistics based on current data
        function recalculateStatistics() {
            if (!currentCountryQuadkeys) return;

            let totalQuadkeys = 0;
            let borderQuadkeys = 0;
            let totalCountries = new Set();

            // Count total quadkeys and border quadkeys
            const seenQuadkeys = new Set();
            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                totalCountries.add(country);
                quadkeys.forEach(quadkey => {
                    if (!seenQuadkeys.has(quadkey)) {
                        seenQuadkeys.add(quadkey);
                        totalQuadkeys++;

                        const countries = quadkeyCountriesMap.get(quadkey);
                        if (countries && countries.size > 1) {
                            borderQuadkeys++;
                        }
                    }
                });
            }

            // Update statistics display
            const statsEl = document.getElementById('statsDetails');
            statsEl.textContent = `Found ${totalQuadkeys} quadkeys, ${borderQuadkeys} border quadkeys across ${totalCountries.size} countries`;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';

            // Auto-hide success messages after 3 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Show/hide loading indicator
        function setLoading(loading) {
            document.getElementById('loadingIndicator').style.display = loading ? 'block' : 'none';
            document.getElementById('processBtn').disabled = loading;

            if (loading && processingController) {
                processingController.abort();
            }
            processingController = new AbortController();
        }

        // Fast country detection using Mapbox Geocoding
        async function reverseGeocodeCountry(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;

            if (countryCache[cacheKey]) {
                return countryCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=country&access_token=${MAPBOX_TOKEN}`,
                    {
                        signal: processingController?.signal
                    }
                );

                if (!response.ok) {
                    throw new Error(`Mapbox API error: ${response.status}`);
                }

                const data = await response.json();

                // Extract country code from Mapbox response
                let countryCode = 'UNKNOWN';
                if (data.features && data.features.length > 0) {
                    const place = data.features[0];
                    countryCode = place.properties?.short_code?.toUpperCase() || 'UNKNOWN';
                }

                // Cache the result
                countryCache[cacheKey] = countryCode;

                return countryCode;

            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.warn(`Mapbox geocoding failed for (${lat}, ${lng}):`, error);
                return 'UNKNOWN';
            }
        }

        // Get countries for a quadkey by sampling multiple points
        async function getQuadkeyCountries(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            const countries = new Set();

            // Sample multiple points for border detection
            const samplePoints = [
                [bounds.north, bounds.west],  // NW corner
                [bounds.north, bounds.east],  // NE corner
                [bounds.south, bounds.west],  // SW corner
                [bounds.south, bounds.east],  // SE corner
                [(bounds.north + bounds.south) / 2, (bounds.west + bounds.east) / 2]  // Center
            ];

            // Process sample points
            const promises = samplePoints.map(([lat, lng]) => reverseGeocodeCountry(lat, lng));
            const results = await Promise.all(promises);

            results.forEach(country => {
                if (country && country !== 'UNKNOWN') {
                    countries.add(country);
                }
            });

            return Array.from(countries);
        }

        // Check if a line string intersects with a bounding box
        function lineStringIntersectsBounds(lineString, bounds) {
            // Simple bounding box intersection check first
            const lineBounds = getLineStringBounds(lineString);
            if (!boundsIntersect(lineBounds, bounds)) {
                return false;
            }

            // More detailed check - see if any segment intersects the bounds
            for (let i = 1; i < lineString.length; i++) {
                const prevCoord = lineString[i - 1];
                const currCoord = lineString[i];

                if (lineSegmentIntersectsBounds(prevCoord, currCoord, bounds)) {
                    return true;
                }
            }

            return false;
        }

        // Get bounding box of a line string
        function getLineStringBounds(lineString) {
            const lats = lineString.map(coord => coord[1]);
            const lngs = lineString.map(coord => coord[0]);

            return {
                west: Math.min(...lngs),
                east: Math.max(...lngs),
                south: Math.min(...lats),
                north: Math.max(...lats)
            };
        }

        // Check if two bounding boxes intersect
        function boundsIntersect(bounds1, bounds2) {
            return !(bounds1.east < bounds2.west ||
                     bounds1.west > bounds2.east ||
                     bounds1.south > bounds2.north ||
                     bounds1.north < bounds2.south);
        }

        // Check if a line segment intersects with a bounding box
        function lineSegmentIntersectsBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            // Cohen-Sutherland line clipping algorithm
            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;

                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;

                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    break;
                } else {
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }

            return accept;
        }

        // Parse CSV file
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    csvRoadsData = parseCSV(csvContent);

                    if (csvRoadsData.length === 0) {
                        showStatus('No valid roads found in CSV file', 'error');
                        return;
                    }

                    document.getElementById('csvInputLabel').textContent = file.name;
                    document.getElementById('processCSVBtn').disabled = false;
                    showStatus(`Loaded ${csvRoadsData.length} roads from CSV`, 'success');

                } catch (error) {
                    showStatus(`Error parsing CSV: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Parse CSV content
        function parseCSV(csvContent) {
            const roads = [];
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                throw new Error('CSV file must have at least a header and one data row');
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = parseCSVLine(line);

                if (values.length < headers.length) {
                    console.warn(`Skipping line ${i}: insufficient columns`);
                    continue;
                }

                const road = {
                    id: values[headers.indexOf('\"id\"')] || '',
                    tags: values[headers.indexOf('\"tags\"')] || '{}',
                    geometry: values[headers.indexOf('\"geometry_wkt\"')] || '',
                    // Try to find country in any column
                    country: ''
                };

                // Look for country in metadata_str['iso:3166_1'] column or similar
                for (let j = 0; j < headers.length; j++) {
                    if (headers[j].includes('iso:3166_1') || headers[j].includes('country')) {
                        road.country = values[j] || '';
                        break;
                    }
                }

                // Parse tags JSON and convert to key-value pairs
                parseTags(road);

                // Parse WKT geometry
                const coords = parseWKTGeometry(road.geometry);
                if (coords && coords.length >= 2) {
                    road.coordinates = coords;
                    roads.push(road);
                } else {
                    console.warn(`Skipping road ${road.id} - invalid geometry`);
                }
            }

            return roads;
        }

        // Parse tags JSON string to key-value object
        function parseTags(road) {
            let tagsString = road.tags;
            if (!tagsString || tagsString.trim() === '') {
                return;
            }

            try {
                // Clean the tags string
                let cleanTags = tagsString.trim();
                if (cleanTags.startsWith('"') && cleanTags.endsWith('"')) {
                    cleanTags = cleanTags.slice(1, -1);
                }
                if (cleanTags.startsWith("'") && cleanTags.endsWith("'")) {
                    cleanTags = cleanTags.slice(1, -1);
                }

                // Replace single quotes with double quotes for JSON parsing
                cleanTags = cleanTags.replace(/'/g, '"');
                cleanTags = cleanTags.replace('{', '');
                cleanTags = cleanTags.replace('}', '');

                // Parse tags
                const tags = cleanTags.split(", ");
                for (let pair of tags) {
                    if (pair.includes('=')) {
                        const p = pair.indexOf('=');
                        let key = pair.substring(0, p)
                        let value = pair.substring(p+1)
                        console.log(key + ' ' + value)
                        if (key === 'geometry' || key === 'id' || key === 'tags') {
                            continue;
                        }
                        road[key] = value;
                    }
                }
            } catch (error) {
                console.warn('Error parsing tags:', error);
            }
        }

        // Extract key-value pairs from a string
        function extractKeyValuePairs(str) {
            const result = {};
            const pairs = str.match(/(\w+)\s*:\s*("[^"]*"|[^,}\s]+)/g);

            if (pairs) {
                pairs.forEach(pair => {
                    const [key, value] = pair.split(':').map(s => s.trim());
                    const cleanValue = value.replace(/^["']|["']$/g, '');
                    result[key] = cleanValue;
                });
            }

            return result;
        }


        // Simple CSV line parser
        function parseCSVLine(line) {
            const values = [];
            let currentValue = '';
            let insideQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"' && !insideQuotes) {
                    insideQuotes = true;
                } else if (char === '"' && insideQuotes) {
                    if (nextChar === '"') {
                        currentValue += '"';
                        i++; // Skip next quote
                    } else {
                        insideQuotes = false;
                    }
                } else if (char === ',' && !insideQuotes) {
                    values.push(currentValue);
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }

            values.push(currentValue);
            return values;
        }

        // Parse WKT geometry string
        function parseWKTGeometry(wkt) {
            if (!wkt) return null;

            // Handle LINESTRING WKT format
            if (wkt.toUpperCase().startsWith('LINESTRING')) {
                // Remove LINESTRING( and )
                const coordsStr = wkt.replace(/LINESTRING\s*\(/i, '').replace(/\)$/, '');
                const coordPairs = coordsStr.split(',');
                return coordPairs.map(pair => {
                    const coords = pair.trim().split(/\s+/);
                    if (coords.length >= 2) {
                        return [parseFloat(coords[0]), parseFloat(coords[1])]; // [lng, lat]
                    }
                    return null;
                }).filter(coord => coord !== null);
            }

            return null;
        }

document.getElementById('processCSVBtn').addEventListener('click', async function() {
    if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
        showStatus('Please calculate quadkeys from a route first', 'error');
        return;
    }

    if (csvRoadsData.length === 0) {
        showStatus('Please upload a CSV file first', 'error');
        return;
    }

    setLoading(true);
    showStatus(`Processing CSV roads in ${currentProcessingMode === 'speed_limits' ? 'Speed Limits' : 'Oneways'} mode...`, 'info');

    try {
        processedRoadsGeoJSON = await processRoadsCSV(csvRoadsData, currentZoomLevel);
        document.getElementById('downloadCSVResultsBtn').disabled = false;

        const modeName = currentProcessingMode === 'speed_limits' ? 'Speed Limits' : 'Oneways';
        showStatus(`Processed ${csvRoadsData.length} roads in ${modeName} mode`, 'success');

    } catch (error) {
        showStatus(`Error processing CSV: ${error.message}`, 'error');
        console.error(error);
    } finally {
        setLoading(false);
    }
});

        // Clip a line segment to bounds (returns the portion of segment inside bounds)
        function clipSegmentToBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            // Cohen-Sutherland line clipping algorithm
            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;

                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;

                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    // Both points inside - accept the whole segment
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    // Both points outside on same side - reject
                    break;
                } else {
                    // Some part is inside - clip
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        // Point is above the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        // Point is below the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        // Point is to the right of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        // Point is to the left of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }

            if (accept) {
                return [[x1, y1], [x2, y2]];
            }
            return null;
        }

        // Calculate intersection length between a complete line and a quadkey bounds
        function calculateIntersectionLength(lineCoordinates, quadkeyBounds) {
            // Check if any part of the line intersects with the bounds
            let totalIntersectionLength = 0;

            for (let i = 1; i < lineCoordinates.length; i++) {
                const segmentStart = lineCoordinates[i - 1];
                const segmentEnd = lineCoordinates[i];

                // Check if this segment intersects with bounds
                if (lineSegmentIntersectsBounds(segmentStart, segmentEnd, quadkeyBounds)) {
                    // Calculate the clipped segment length
                    const clippedSegment = clipSegmentToBounds(segmentStart, segmentEnd, quadkeyBounds);
                    if (clippedSegment) {
                        const [lon1, lat1] = clippedSegment[0];
                        const [lon2, lat2] = clippedSegment[1];

                        // Calculate distance
                        const R = 6371000;
                        const Ï†1 = lat1 * Math.PI / 180;
                        const Ï†2 = lat2 * Math.PI / 180;
                        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
                        const Î”Î» = (lon2 - lon1) * Math.PI / 180;

                        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                                 Math.cos(Ï†1) * Math.cos(Ï†2) *
                                 Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                        totalIntersectionLength += R * c;
                    }
                }
            }

            return totalIntersectionLength;
        }

// Process CSV roads and create GeoJSON organized by country/quadkey (roads NOT shared)
async function processRoadsCSV(roads, zoomLevel) {
    // Create a map of quadkey to countries for faster lookup
    const quadkeyToCountries = new Map();
    for (const [quadkey, countries] of quadkeyCountriesMap.entries()) {
        quadkeyToCountries.set(quadkey, Array.from(countries));
    }

    // Get all quadkey bounds for intersection calculations
    const quadkeyBounds = new Map();
    for (const quadkey of quadkeyToCountries.keys()) {
        quadkeyBounds.set(quadkey, quadkeyToBounds(quadkey));
    }

    // Create GeoJSON structure organized by country and quadkey
    const geoJSONByCountryQuadkey = {};

    let assignedCount = 0;
    let totalRoads = roads.length;
    let processedCount = 0;

    for (let roadIndex = 0; roadIndex < roads.length; roadIndex++) {
        const road = roads[roadIndex];
        if (!road.coordinates || road.coordinates.length < 2) continue;

        // Get the road's country from metadata
        const roadCountry = road.country || 'UNKNOWN';

        // Find all quadkeys this road intersects with
        const intersectingQuadkeys = new Map(); // quadkey -> intersection length

        for (const [quadkey, bounds] of quadkeyBounds.entries()) {
            // Check if road intersects with this quadkey
            if (lineStringIntersectsBounds(road.coordinates, bounds)) {
                // Calculate intersection length
                const intersectionLength = calculateIntersectionLength(road.coordinates, bounds);
                if (intersectionLength > 0) {
                    intersectingQuadkeys.set(quadkey, intersectionLength);
                }
            }
        }

        // If road intersects with any quadkey, assign it to the one with largest intersection
        if (intersectingQuadkeys.size > 0) {
            // Find quadkey with maximum intersection length
            let bestQuadkey = null;
            let maxLength = 0;

            for (const [quadkey, length] of intersectingQuadkeys.entries()) {
                if (length > maxLength) {
                    maxLength = length;
                    bestQuadkey = quadkey;
                }
            }

            if (bestQuadkey) {
                assignedCount++;

                // Filter tags with default maxspeed values
                console.log(road)
                const filteredRoad = filterRoadTags(road);

                // Initialize country structure if not exists
                if (!geoJSONByCountryQuadkey[roadCountry]) {
                    geoJSONByCountryQuadkey[roadCountry] = {};
                }

                // Initialize quadkey structure if not exists
                if (!geoJSONByCountryQuadkey[roadCountry][bestQuadkey]) {
                    geoJSONByCountryQuadkey[roadCountry][bestQuadkey] = {
                        type: 'FeatureCollection',
                        features: []
                    };
                }

                // Create road feature
                const feature = {
                    type: 'Feature',
                    properties: filteredRoad,
                    geometry: {
                        type: 'LineString',
                        coordinates: road.coordinates
                    }
                };

                geoJSONByCountryQuadkey[roadCountry][bestQuadkey].features.push(feature);
            }
        }

        processedCount++;
        // Update progress percentage
        const percentage = Math.round((processedCount / totalRoads) * 100);
        if (roadIndex % 100 === 0) {
            showStatus(`Processing roads: ${percentage}% complete`, 'info');
        }

        // Allow UI to update
        if (roadIndex % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    showStatus(`Processing complete: 100%`, 'success');
    showStatus(`Assigned ${assignedCount} roads to quadkeys (${roads.length - assignedCount} not assigned)`, 'success');

    return geoJSONByCountryQuadkey;
}

// Combine signs with roads, sharing signs across border quadkeys but NOT sharing roads
async function combineSignsWithRoads(signs, roadsGeoJSON) {
    const combinedGeoJSON = {};

    // Group signs by quadkey (signs are shared across countries)
    const signsByQuadkey = new Map();

    // First, assign signs to quadkeys based on coordinates
    for (let signIndex = 0; signIndex < signs.length; signIndex++) {
        const sign = signs[signIndex];
        if (!sign.coordinates) continue;

        const [signLng, signLat] = sign.coordinates;

        // Find which quadkey this sign belongs to
        let foundQuadkey = null;

        // Check all quadkeys by their bounds
        for (const [quadkey, countries] of quadkeyCountriesMap.entries()) {
            const bounds = quadkeyToBounds(quadkey);
            if (isPointInBounds(signLng, signLat, bounds)) {
                foundQuadkey = quadkey;
                break;
            }
        }

        if (foundQuadkey) {
            if (!signsByQuadkey.has(foundQuadkey)) {
                signsByQuadkey.set(foundQuadkey, []);
            }
            signsByQuadkey.get(foundQuadkey).push(sign);
        }

        if (signIndex % 100 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Now combine: each country gets its own roads + shared signs for quadkeys
    for (const [country, quadkeys] of Object.entries(roadsGeoJSON)) {
        if (!combinedGeoJSON[country]) {
            combinedGeoJSON[country] = {};
        }

        for (const [quadkey, roadCollection] of Object.entries(quadkeys)) {
            if (!combinedGeoJSON[country][quadkey]) {
                combinedGeoJSON[country][quadkey] = {
                    type: 'FeatureCollection',
                    features: []
                };
            }

            // Add this country's roads (NOT shared)
            combinedGeoJSON[country][quadkey].features.push(...roadCollection.features);

            // Add shared signs for this quadkey (same signs for all countries)
            const signsInQuadkey = signsByQuadkey.get(quadkey) || [];
            for (const sign of signsInQuadkey) {
                const signFeature = createSignFeature(sign, country, quadkey);
                combinedGeoJSON[country][quadkey].features.push(signFeature);
            }
        }

        // Also add signs for quadkeys that this country has, even if no roads
        const countryQuadkeys = Object.keys(quadkeys);
        for (const [quadkey, signsList] of signsByQuadkey.entries()) {
            // If this country has this quadkey but no roads in it, still add signs
            if (countryQuadkeys.includes(quadkey) ||
                (quadkeyCountriesMap.has(quadkey) &&
                 Array.from(quadkeyCountriesMap.get(quadkey)).includes(country))) {

                if (!combinedGeoJSON[country][quadkey]) {
                    combinedGeoJSON[country][quadkey] = {
                        type: 'FeatureCollection',
                        features: []
                    };
                }

                // Add signs if not already added
                const existingSignIds = new Set(
                    combinedGeoJSON[country][quadkey].features
                        .filter(f => f.properties.id && f.properties.id.startsWith('sign_'))
                        .map(f => f.properties.id)
                );

                for (const sign of signsList) {
                    if (!existingSignIds.has(sign.id)) {
                        const signFeature = createSignFeature(sign, country, quadkey);
                        combinedGeoJSON[country][quadkey].features.push(signFeature);
                    }
                }
            }
        }
    }

    const totalSigns = Array.from(signsByQuadkey.values()).reduce((sum, arr) => sum + arr.length, 0);
    showStatus(`Shared ${totalSigns} signs across ${signsByQuadkey.size} quadkeys`, 'success');

    return combinedGeoJSON;
}

// Get the first point of the current route
function getFirstRoutePoint() {
    if (!currentRouteData || !currentRouteData.routes[currentRouteIndex]) {
        return { lat: 0, lng: 0 };
    }

    const route = currentRouteData.routes[currentRouteIndex];

    // Find the first coordinate in the route
    for (const leg of route.legs) {
        for (const step of leg.steps) {
            if (step.geometry.type === 'LineString' && step.geometry.coordinates && step.geometry.coordinates.length > 0) {
                const firstCoord = step.geometry.coordinates[0];
                return { lat: firstCoord[1], lng: firstCoord[0] };
            }
        }
    }

    return { lat: 0, lng: 0 };
}

function isPointInBounds(lng, lat, bounds) {
    return lng >= bounds.west && lng <= bounds.east &&
           lat >= bounds.south && lat <= bounds.north;
}

function filterRoadTags(road) {
    // Check if oneway
    const isOneway = road.oneway === 'yes' || road.oneway === '1' || road.oneway === '-1' || road.oneway === 'true';

    let filteredRoad = {
        id: road.id || ''
    };

    if (currentProcessingMode === 'speed_limits') {
        // Speed Limits mode - current functionality
        filteredRoad = filterRoadTagsSpeedLimits(road, isOneway);
    } else if (currentProcessingMode === 'oneways' || currentProcessingMode === 'here_oneways'){
        // Oneways mode - simplified output
        filteredRoad = filterRoadTagsOneways(road, isOneway);
    }
    return filteredRoad;
}

function filterRoadTagsSpeedLimits(road, isOneway) {
    const filteredRoad = {
        id: road.id || ''
    };

    // Keep only specified keys and remove any with "type" substring
    const keysToCheck = Object.keys(road);

    for (const key of keysToCheck) {
        const lowerKey = key.toLowerCase();

        // Skip if key contains "type" substring or other excluded patterns
        if (lowerKey.includes('type') || lowerKey.includes('zone') || lowerKey.includes('correction') ||
            lowerKey.includes('dt') || lowerKey.includes('advisory') || lowerKey.includes('source') ||
            lowerKey.includes('country')) {
            continue;
        }

        // Get the value and check if it's [DELETED]
        let value = road[key];
        if (value === '[DELETED]') {
            value = '0';
        }

        // Always include these specific tags if they exist
        if (lowerKey === 'oneway') {
            filteredRoad.oneway = value;
        }
        else if (lowerKey === 'junction') {
            filteredRoad.junction = value;
        }
        else if (lowerKey === 'highway') {
            // Rename highway to FRC
            filteredRoad.FRC = value;
        }
        // Include any tag with "maxspeed" substring
        else if (lowerKey.startsWith('maxspeed')) {
            filteredRoad[key] = value;
        }
    }

    // Add oneway=no if oneway key doesn't exist
    if (!filteredRoad.oneway) {
        filteredRoad.oneway = isOneway ? isOneway : 'no';
    }

    // Add default maxspeed tags based on oneway status
    if (!filteredRoad['maxspeed:conditional']) {
        filteredRoad['maxspeed_conditional'] = '0';
    }
    if (!filteredRoad['maxspeed:variable']) {
        filteredRoad['maxspeed:variable'] = '0';
    }
    if (!filteredRoad['maxspeed:hgv']) {
        filteredRoad['maxspeed_hgv'] = '0';
    }
    if (!filteredRoad['maxspeed:hgv:conditional']) {
        filteredRoad['maxspeed_hgv_conditional'] = '0';
    }
    if (!filteredRoad['maxspeed:trailer']) {
        filteredRoad['maxspeed_trailer'] = '0';
    }
    if (isOneway) {
        if (!filteredRoad.maxspeed) {
            filteredRoad.maxspeed = '0';
        }
    } else {
        // For bidirectional roads, add forward/backward tags if not present
        if (!filteredRoad['maxspeed:forward']) {
            filteredRoad['maxspeed:forward'] = '0';
        }
        if (!filteredRoad['maxspeed:backward']) {
            filteredRoad['maxspeed:backward'] = '0';
        }
        if (!filteredRoad['maxspeed:forward:conditional']) {
            filteredRoad['maxspeed_forward_conditional'] = '0';
        }
        if (!filteredRoad['maxspeed:backward:conditional']) {
            filteredRoad['maxspeed_backward_conditional'] = '0';
        }
    }

    return filteredRoad;
}

function filterRoadTagsOneways(road, isOneway) {
    const filteredRoad = {
        id: road.id || ''
    };

    // Only include these specific tags
    if (road.oneway !== undefined) {
        filteredRoad.oneway = road.oneway === '[DELETED]' ? '0' : road.oneway;
    } else {
        filteredRoad.oneway = isOneway ? isOneway : 'no';
    }

    if (road.junction !== undefined) {
        filteredRoad.junction = road.junction === '[DELETED]' ? '0' : road.junction;
    }

    if (road.highway !== undefined) {
        filteredRoad.highway = road.highway;
    }
    return filteredRoad;
}

let currentFilteredCountryQuadkeys = null;

function displayResults(countryQuadkeys) {
    currentFilteredCountryQuadkeys = countryQuadkeys;
    const firstRoutePoint = getFirstRoutePoint();

    const sortedCountries = Object.keys(countryQuadkeys).sort();
    let output = '';
    const currentDate = new Date();
    currentDate.setDate(currentDate.getDate() - 2);
    const formattedDate = currentDate.toLocaleDateString('en-CA');
    let strFormattedDate = `'${formattedDate}'`;

    // Build country-specific conditions (now simpler since we only need country-specific quadkeys)
    let countryConditions = [];

    for (const country of sortedCountries) {
        const quadkeys = countryQuadkeys[country];

        // Sort quadkeys by distance from first route point
        const sortedQuadkeys = quadkeys.map(quadkey => {
            const bounds = quadkeyToBounds(quadkey);
            const centerLat = (bounds.north + bounds.south) / 2;
            const centerLng = (bounds.west + bounds.east) / 2;
            const distance = calculateDistance(
                [firstRoutePoint.lat, firstRoutePoint.lng],
                [centerLat, centerLng]
            );
            return { quadkey, distance };
        }).sort((a, b) => a.distance - b.distance)
          .map(item => item.quadkey);

        // Group quadkeys by zoom level for this country
        const quadkeysByZoom = {};
        for (let qk of sortedQuadkeys) {
            const zoomLevel = qk.length;
            if (zoomLevel in quadkeysByZoom) {
                quadkeysByZoom[zoomLevel].push(qk);
            } else {
                quadkeysByZoom[zoomLevel] = [qk];
            }
        }

        // Build cardinality condition for this country
        let cardinalityCondition = '';
        for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
            let quads = getQkStringifyArray(qks);
            cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
        }

        if (cardinalityCondition) {
            cardinalityCondition = cardinalityCondition.slice(0, -4);
            // Create country-specific condition (now using IN clause for multiple countries)
            const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
            countryConditions.push(countryCondition);
        }

        const count = sortedQuadkeys.length;
        output += `${country}: ${count} quadkeys\n`;
        output += sortedQuadkeys.join(',') + '\n\n';
    }

    // Combine all country conditions with OR
    let finalCountryCondition = '';
    if (countryConditions.length > 0) {
        if (countryConditions.length === 1) {
            finalCountryCondition = countryConditions[0];
        } else {
            finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
        }
    }

    // Build the complete query with country field
    query = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country
        from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
        where dt = ${strFormattedDate}
        and ${finalCountryCondition}
        and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;

    document.getElementById('resultsOutput').textContent = output.trim() || 'No quadkeys found for this route.';
}

        // Download processed roads GeoJSON
        document.getElementById('downloadCSVResultsBtn').addEventListener('click', function() {
            if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
                showStatus('No processed roads data available', 'error');
                return;
            }

            // Create a zip file with organized GeoJSON files
            const zip = new JSZip();

            for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
                const countryFolder = zip.folder(country);

                for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                    if (geojson.features.length > 0) {
                        const fileName = `${quadkey}.geojson`;
                        countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                    }
                }
            }

            // Generate and download zip file
            zip.generateAsync({ type: 'blob' }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                let currentDate = new Date();
                let iso = currentDate.toISOString()
                a.download = `roads_${currentProcessingMode}_${iso}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('Downloaded roads organized by country/quadkey');
                showStatus(`Downloaded roads organized by country/quadkey`, 'success');
            });
        });

        // Load JSZip library dynamically
        function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (typeof JSZip !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

<!--        // Initialize JSZip when needed-->
<!--        document.getElementById('downloadCSVResultsBtn').addEventListener('click', async function(e) {-->
<!--            e.preventDefault();-->

<!--            try {-->
<!--                await loadJSZip();-->
<!--                // Now call the actual download function-->
<!--                downloadCSVResults();-->
<!--            } catch (error) {-->
<!--                showStatus('Error loading JSZip library: ' + error.message, 'error');-->
<!--            }-->
<!--        });-->

        // Updated download function that uses JSZip
async function downloadCSVResults() {
    if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
        showStatus('No processed roads data available', 'error');
        return;
    }

    try {
        await loadJSZip();
        const zip = new JSZip();
        let fileCount = 0;

        // Process each country
        for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
            // Only process if we have features for this country
            let hasFeatures = false;
            for (const quadkey in quadkeys) {
                if (quadkeys[quadkey].features.length > 0) {
                    hasFeatures = true;
                    break;
                }
            }

            if (!hasFeatures) continue;

            // Create folder for this country
            const countryFolder = zip.folder(country);

            // Add each quadkey's features for this country
            for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                if (geojson.features.length > 0) {
                    // Create file name with country code to make it clear
                    const fileName = `${quadkey}_${country}.geojson`;
                    countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                    fileCount++;
                }
            }
        }

        // Generate and download zip file
        zip.generateAsync({ type: 'blob' }).then(function(content) {
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = `roads_by_country_strict.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`Downloaded ${fileCount} GeoJSON files organized by country`, 'success');
        });

    } catch (error) {
        showStatus('Error creating zip file: ' + error.message, 'error');
        console.error(error);
    }
}

        // Parse uploaded JSON file
        document.getElementById('routeFile').addEventListener('change', function(e) {
            currentCountryQuadkeys = null;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.routes || !Array.isArray(data.routes)) {
                        throw new Error('Invalid route file format. Expected "routes" array.');
                    }

                    currentRouteData = data;
                    countryCache = {}; // Clear cache for new file

                    document.getElementById('fileInputLabel').textContent = file.name;

                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '';

                    data.routes.forEach((route, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Route ${index + 1}`;
                        routeSelect.appendChild(option);
                    });

                    document.getElementById('routeSelectorContainer').style.display = 'block';
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('downloadRouteBtn').disabled = false;
                    document.getElementById('copyWktBtn').disabled = false;

                    loadRoute(0);

                    showStatus('Route file loaded successfully!', 'success');
                } catch (error) {
                    showStatus(`Error parsing JSON: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        document.getElementById('processBtn').disabled = false;

        // Handle route selection change
        document.getElementById('routeSelect').addEventListener('change', function(e) {
            const routeIndex = parseInt(e.target.value);
            loadRoute(routeIndex);
        });

        // Download route as GeoJSON before processing
        document.getElementById('downloadRouteBtn').addEventListener('click', function() {
            if (!currentRouteData) return;

            const route = currentRouteData.routes[currentRouteIndex];
            const features = [];

            // Create route feature from all coordinates
            const allCoords = [];
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`,
                    distance: document.getElementById('routeDetails').textContent.split(',')[0].replace('Distance: ', ''),
                    waypoints: document.getElementById('routeDetails').textContent.split(',')[1].replace(' Waypoints: ', ''),
                    legs: route.legs.length
                }
            };

            features.push(routeFeature);

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${currentRouteIndex}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('Route GeoJSON downloaded!', 'success');
        });

        // Add Quadkey Mode
        document.getElementById('addQuadkeyModeBtn').addEventListener('click', function() {
            addQuadkeyMode = !addQuadkeyMode;
            removeQuadkeyMode = false;

            if (addQuadkeyMode) {
                this.style.backgroundColor = '#28a745';
                document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
                showStatus('Add Quadkey Mode: Click on map to add quadkeys', 'info');
            } else {
                this.style.backgroundColor = '';
                showStatus('Add Quadkey Mode disabled', 'info');
            }
        });

        // Remove Quadkey Mode
        document.getElementById('removeQuadkeyModeBtn').addEventListener('click', function() {
            removeQuadkeyMode = !removeQuadkeyMode;
            addQuadkeyMode = false;

            if (removeQuadkeyMode) {
                this.style.backgroundColor = '#dc3545';
                document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
                showStatus('Remove Quadkey Mode: Click on map to remove quadkeys', 'info');
            } else {
                this.style.backgroundColor = '';
                showStatus('Remove Quadkey Mode disabled', 'info');
            }
        });

        // Load a specific route onto the map
        function loadRoute(routeIndex) {
            if (!currentRouteData || !currentRouteData.routes[routeIndex]) {
                showStatus('Invalid route selected', 'error');
                return;
            }

            currentRouteIndex = routeIndex;
            const route = currentRouteData.routes[routeIndex];

            if (routeLayer) {
                map.removeLayer(routeLayer);
            }

            const allCoords = [];
            let totalDistance = 0;
            let waypointCount = 0;

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    const geom = step.geometry;
                    if (geom.type === 'LineString' && geom.coordinates) {
                        const latLngs = geom.coordinates.map(coord => [coord[1], coord[0]]);
                        allCoords.push(...latLngs);

                        if (latLngs.length > 1) {
                            for (let i = 1; i < latLngs.length; i++) {
                                totalDistance += calculateDistance(latLngs[i-1], latLngs[i]);
                            }
                        }

                        waypointCount += latLngs.length;
                    }
                });
            });

            routeLayer = L.polyline(allCoords, {
                color: '#3498db',
                weight: 4,
                opacity: 0.7,
                smoothFactor: 1
            }).addTo(map);

            map.fitBounds(routeLayer.getBounds());

            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('routeDetails').textContent =
                `Distance: ${(totalDistance / 1000).toFixed(2)} km, Waypoints: ${waypointCount}, Legs: ${route.legs.length}`;

            clearQuadkeyLayers();
            document.getElementById('resultsOutput').textContent =
                'No results yet. Click "Calculate Quadkeys" to process this route.';
            document.getElementById('copyResultsBtn').disabled = true;
            document.getElementById('copySqlResultsBtn').disabled = true;
            document.getElementById('copySignsSqlBtn').disabled = true;
            document.getElementById('downloadGeoJSONBtn').disabled = true;
            document.getElementById('statsInfo').style.display = 'none';
            document.getElementById('countryControlsContainer').style.display = 'none';
            document.getElementById('copyWktBtn').style.display = 'block';
            // Reset modes
            addQuadkeyMode = false;
            removeQuadkeyMode = false;
            document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
            document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
        }

        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371e3;
            const Ï†1 = coord1[0] * Math.PI / 180;
            const Ï†2 = coord2[0] * Math.PI / 180;
            const Î”Ï† = (coord2[0] - coord1[0]) * Math.PI / 180;
            const Î”Î» = (coord2[1] - coord1[1]) * Math.PI / 180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                      Math.cos(Ï†1) * Math.cos(Ï†2) *
                      Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Process route to calculate quadkeys - USING BOUNDING BOX APPROACH
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!currentRouteData) {
                showStatus('Please upload a route file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Calculating quadkeys using bounding box approach...', 'info');

            try {
                const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
                currentZoomLevel = zoomLevel;
                const route = currentRouteData.routes[currentRouteIndex];

                const startTime = Date.now();
                var { countryQuadkeys, stats, quadkeyCountries } = await getRouteQuadkeysWithCountriesBBox(
                    route,
                    zoomLevel
                );
                const processingTime = (Date.now() - startTime) / 1000;

                currentCountryQuadkeys = countryQuadkeys;
                quadkeyCountriesMap = quadkeyCountries;
                originalStats = stats;

                // Initialize all countries as enabled
                countryControlsState = {};
                countryBorderExclusions.clear();
                Object.keys(countryQuadkeys).forEach(country => {
                    countryControlsState[country] = true;
                });

                createCountryControls(countryQuadkeys, false);
                updateDisplayAndVisualization();

                // Show statistics
                document.getElementById('statsInfo').style.display = 'block';
                document.getElementById('statsDetails').textContent =
                    `Found ${stats.totalQuadkeys} quadkeys, ${stats.borderQuadkeys} border quadkeys in ${processingTime.toFixed(1)}s`;

                showStatus(`Found ${stats.totalQuadkeys} quadkeys across ${Object.keys(countryQuadkeys).length} countries`, 'success');

                document.getElementById('downloadGeoJSONBtn').disabled = false;
                document.getElementById('copyResultsBtn').disabled = false;
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`Error calculating quadkeys: ${error.message}`, 'error');
                    console.error(error);
                }
            } finally {
                setLoading(false);
            }
        });

        // Get quadkeys for a route using bounding box approach
        async function getRouteQuadkeysWithCountriesBBox(route, zoom) {
            var stats = {
                totalQuadkeys: 0,
                borderQuadkeys: 0
            };

            // Extract all coordinates and create line strings
            const allLineStrings = [];
            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allLineStrings.push(step.geometry.coordinates);
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No valid coordinates found in route');
            }

            // Get the bounding box of the entire route
            const lats = allCoords.map(coord => coord[1]);
            const lngs = allCoords.map(coord => coord[0]);

            const minLon = Math.min(...lngs);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lngs);
            const maxLat = Math.max(...lats);

            showStatus(`Route bounds: ${minLon.toFixed(4)}, ${minLat.toFixed(4)} to ${maxLon.toFixed(4)}, ${maxLat.toFixed(4)}`, 'info');

            // Get all tiles in the bounding box
            const tiles = getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom);
            showStatus(`Checking ${tiles.length} tiles for intersection...`, 'info');

            const quadkeyCountries = new Map();

            // Check which tiles intersect with the route
            for (let i = 0; i < tiles.length; i++) {
                if (processingController?.signal.aborted) {
                    throw new DOMException('Aborted', 'AbortError');
                }

                const tile = tiles[i];
                const quadkey = toQuadkey(tile.x, tile.y, zoom);
                const tileBounds = tileToBounds(tile);

                // Check if any line string intersects with this tile
                let intersects = false;
                for (const lineString of allLineStrings) {
                    if (lineStringIntersectsBounds(lineString, tileBounds)) {
                        intersects = true;
                        break;
                    }
                }

                if (intersects) {
                    // Get countries for this quadkey
                    const countries = await getQuadkeyCountries(quadkey);

                    if (countries.length > 1) {
                        stats.borderQuadkeys++;
                    }

                    quadkeyCountries.set(quadkey, new Set(countries));

                    if (i % 10 === 0) {
                        showStatus(`Processing tiles... ${Math.round((i / tiles.length) * 100)}%`, 'info');
                    }
                }
            }

            stats.totalQuadkeys = quadkeyCountries.size;

            // Convert to country->quadkeys mapping
            const countryQuadkeys = {};
            for (const [quadkey, countries] of quadkeyCountries.entries()) {
                for (const country of countries) {
                    if (!countryQuadkeys[country]) {
                        countryQuadkeys[country] = new Set();
                    }
                    countryQuadkeys[country].add(quadkey);
                }
            }

            // Convert Sets to Arrays and sort
            const result = {};
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                result[country] = Array.from(quadkeys).sort();
            }

            return {
                countryQuadkeys: result,
                stats,
                quadkeyCountries: quadkeyCountries
            };
        }

        // Create country controls UI
        function createCountryControls(countryQuadkeys, qkManipulationEvent) {
            const container = document.getElementById('countryControls');
            container.innerHTML = '';

            const sortedCountries = Object.keys(countryQuadkeys).sort();

            sortedCountries.forEach(country => {
                const quadkeys = countryQuadkeys[country];
                const count = quadkeys.length;

                const controlDiv = document.createElement('div');
                controlDiv.className = 'country-control';
                check = 'checked'
                if (qkManipulationEvent){
                    check = countryControlsState[country] ? 'checked' : 'unchecked';
                }
                check =
                controlDiv.innerHTML = `
                    <input type="checkbox" class="country-checkbox" id="chk-${country}" ${check}>
                    <div class="country-label">
                        <span class="country-name">${country}</span>
                        <span class="country-count">${count}</span>
                    </div>
                    <button class="border-control" data-country="${country}" title="Exclude border quadkeys for ${country}">No Borders</button>
                `;

                container.appendChild(controlDiv);

                // Add event listener for checkbox
                const checkbox = controlDiv.querySelector('.country-checkbox');
                checkbox.addEventListener('change', function() {
                    countryControlsState[country] = this.checked;
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });

                // Add event listener for border control
                const borderBtn = controlDiv.querySelector('.border-control');
                borderBtn.addEventListener('click', function() {
                    const country = this.getAttribute('data-country');
                    if (countryBorderExclusions.has(country)) {
                        countryBorderExclusions.delete(country);
                        this.classList.remove('excluded');
                        this.textContent = 'No Borders';
                    } else {
                        countryBorderExclusions.add(country);
                        this.classList.add('excluded');
                        this.textContent = 'With Borders';
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });
            });
        }

        if (!countryBorderExclusions) {
            countryBorderExclusions = new Set();
        }

        // Update display and visualization based on current filters
        function updateDisplayAndVisualization() {
            if (!currentCountryQuadkeys) {
                // Clear results if no data
                document.getElementById('resultsOutput').textContent = 'No quadkeys found.';
                clearQuadkeyLayers();
                return;
            }

            // Filter quadkeys based on country controls and border exclusions
            const filteredCountryQuadkeys = {};

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (countryControlsState[country]) {
                    let filteredQuadkeys = [...quadkeys];

                    // Apply border exclusion if enabled for this country
                    if (countryBorderExclusions && countryBorderExclusions.has(country)) {
                        filteredQuadkeys = filteredQuadkeys.filter(quadkey => {
                            const countries = quadkeyCountriesMap.get(quadkey);
                            return countries && countries.size === 1 && countries.has(country);
                        });
                    }

                    if (filteredQuadkeys.length > 0) {
                        filteredCountryQuadkeys[country] = filteredQuadkeys;
                    }
                }
            }

            displayResults(filteredCountryQuadkeys);
            visualizeQuadkeys(filteredCountryQuadkeys, currentZoomLevel);
        }

        // Select all countries
        document.getElementById('selectAllBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = true;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = true;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Select none countries
        document.getElementById('selectNoneBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = false;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = false;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Get all tiles in a bounding box
        function getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom) {
            const tiles = [];

            const topLeft = [maxLat, minLon];
            const bottomRight = [minLat, maxLon];

            const topLeftTile = tileAtZoom(topLeft[0], topLeft[1], zoom);
            const bottomRightTile = tileAtZoom(bottomRight[0], bottomRight[1], zoom);

            for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {
                for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                    tiles.push({ x, y, z: zoom });
                }
            }

            return tiles;
        }

        // Convert tile to bounds
        function tileToBounds(tile) {
            return calculateTileBounds(tile.x, tile.y, tile.z);
        }

        // Calculate tile bounds (renamed from tileBounds)
        function calculateTileBounds(x, y, z) {
            const n = Math.pow(2, z);
            const west = x / n * 360 - 180;
            const east = (x + 1) / n * 360 - 180;
            const north = (Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI);
            const south = (Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI);

            return { west, south, east, north };
        }

        // Calculate tile coordinates for given lat/lng and zoom
        function tileAtZoom(lat, lng, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);

            return { x, y, z: zoom };
        }

        // Convert tile coordinates to quadkey
        function toQuadkey(x, y, z) {
            let quadkey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);

                if ((x & mask) !== 0) {
                    digit += 1;
                }

                if ((y & mask) !== 0) {
                    digit += 2;
                }

                quadkey += digit.toString();
            }
            return quadkey;
        }

        // Convert quadkey to bounding box
        function quadkeyToBounds(quadkey) {
            let x = 0, y = 0;
            const z = quadkey.length;

            for (let i = z; i > 0; i--) {
                const mask = 1 << (i - 1);
                const q = parseInt(quadkey[z - i]);

                if (q & 1) x |= mask;
                if (q & 2) y |= mask;
            }

            return calculateTileBounds(x, y, z);
        }

        function getQkStringifyArray(qk_array){
            qks = "";
            for (let item of qk_array){
                qks+=`'${item}',`
            }
            return qks.slice(0, -1);
        }

        function visualizeQuadkeys(countryQuadkeys, zoom) {
            clearQuadkeyLayers();

            // If no quadkeys, clear the map and return
            if (!countryQuadkeys || Object.keys(countryQuadkeys).length === 0) {
                return;
            }

            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
            ];

            let colorIndex = 0;
            const countryColors = {};
            const quadkeyCountries = new Map();

            // First pass: count how many countries each quadkey belongs to
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                for (const quadkey of quadkeys) {
                    if (!quadkeyCountries.has(quadkey)) {
                        quadkeyCountries.set(quadkey, new Set());
                    }
                    quadkeyCountries.get(quadkey).add(country);
                }
            }

            // Second pass: visualize with appropriate colors
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                if (!countryColors[country]) {
                    countryColors[country] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const baseColor = countryColors[country];

                for (const quadkey of quadkeys) {
                    const bounds = quadkeyToBounds(quadkey);
                    const countriesForQuadkey = quadkeyCountries.get(quadkey);

                    // Determine color: border quadkeys get special treatment
                    let color, fillOpacity;
                    if (countriesForQuadkey.size > 1) {
                        // Border quadkey - use yellow for visibility
                        color = '#ffeb3b';
                        fillOpacity = 0.3;
                    } else {
                        // Single country quadkey
                        color = baseColor;
                        fillOpacity = 0.3;
                    }

                    const polygon = L.rectangle(
                        [[bounds.south, bounds.west], [bounds.north, bounds.east]],
                        {
                            color: color,
                            weight: 2,
                            fillColor: color,
                            fillOpacity: fillOpacity
                        }
                    ).addTo(map);

                    // Add click event to toggle quadkey visibility
                    polygon.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);

                        if (removeQuadkeyMode) {
                            const clickedQuadkey = quadkey;
                            const countries = Array.from(quadkeyCountriesMap.get(clickedQuadkey) || []);

                            if (countries.length > 1) {
                                showCountrySelectionModal(clickedQuadkey, countries, 'remove');
                            } else {
                                removeQuadkey(clickedQuadkey, countries);
                                updateDisplayAndVisualization();
                                recalculateStatistics();
                                if (currentCountryQuadkeys) {
                                    createCountryControls(currentCountryQuadkeys, true);
                                }
                            }
                        } else {
                            navigator.clipboard.writeText(quadkey).then(() => {
                                showStatus('Quadkey copied to clipboard!', 'success');
                            }).catch(err => {
                                console.error('Copy failed:', err);
                            });
                        }
                    });

                    const countryList = Array.from(countriesForQuadkey).join(', ');
                    polygon.bindTooltip(
                        `Countries: ${countryList}<br>Quadkey: ${quadkey}`,
                        { permanent: false, direction: 'center' }
                    );

                    if (!quadkeyLayers[country]) {
                        quadkeyLayers[country] = [];
                    }
                    quadkeyLayers[country].push(polygon);
                }
            }
        }

        // Clear quadkey layers from the map
        function clearQuadkeyLayers() {
            for (const country in quadkeyLayers) {
                quadkeyLayers[country].forEach(layer => {
                    map.removeLayer(layer);
                });
            }
            quadkeyLayers = {};
        }

        // Copy results to clipboard
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsText = document.getElementById('resultsOutput').textContent;

            navigator.clipboard.writeText(resultsText).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });


        // Extract the SQL generation logic into a separate function
function generateRoadsSQL(countryQuadkeys) {
    const firstRoutePoint = getFirstRoutePoint();
    const sortedCountries = Object.keys(countryQuadkeys).sort();
    const currentDate = new Date();
    currentDate.setDate(currentDate.getDate() - 2);
    const formattedDate = currentDate.toLocaleDateString('en-CA');
    let strFormattedDate = `'${formattedDate}'`;

    // Build country-specific conditions
    let countryConditions = [];

    for (const country of sortedCountries) {
        const quadkeys = countryQuadkeys[country];

        // Sort quadkeys by distance from first route point
        const sortedQuadkeys = quadkeys.map(quadkey => {
            const bounds = quadkeyToBounds(quadkey);
            const centerLat = (bounds.north + bounds.south) / 2;
            const centerLng = (bounds.west + bounds.east) / 2;
            const distance = calculateDistance(
                [firstRoutePoint.lat, firstRoutePoint.lng],
                [centerLat, centerLng]
            );
            return { quadkey, distance };
        }).sort((a, b) => a.distance - b.distance)
          .map(item => item.quadkey);

        // Group quadkeys by zoom level for this country
        const quadkeysByZoom = {};
        for (let qk of sortedQuadkeys) {
            const zoomLevel = qk.length;
            if (zoomLevel in quadkeysByZoom) {
                quadkeysByZoom[zoomLevel].push(qk);
            } else {
                quadkeysByZoom[zoomLevel] = [qk];
            }
        }

        // Build cardinality condition for this country
        let cardinalityCondition = '';
        for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
            let quads = getQkStringifyArray(qks);
            cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
        }

        if (cardinalityCondition) {
            cardinalityCondition = cardinalityCondition.slice(0, -4);
            // Create country-specific condition
            const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
            countryConditions.push(countryCondition);
        }
    }

    // Combine all country conditions with OR
    let finalCountryCondition = '';
    if (countryConditions.length > 0) {
        if (countryConditions.length === 1) {
            finalCountryCondition = countryConditions[0];
        } else {
            finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
        }
    }

    // Build the complete query with appropriate fields based on mode
    let selectFields = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country`;
    let endFields = '';
    if (currentProcessingMode === 'speed_limits' || currentProcessingMode === 'here_oneways') {
        endFields = `tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;
    } else if (currentProcessingMode === 'oneways'){
        endFields = `tags['highway'] in ('unclassified', 'residential', 'living_street')`;
    }

    return `${selectFields}
        from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
        where dt = ${strFormattedDate}
        and ${finalCountryCondition}
        and ${endFields}`;
}

        // Copy SQL results to clipboard
        document.getElementById('copySqlResultsBtn').addEventListener('click', function() {
            if (!currentFilteredCountryQuadkeys && (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0)) {
                showStatus('No quadkey data available. Please add quadkeys first.', 'error');
                return;
            }

            try {
                let roadsSQL;
                   if (currentProcessingMode === 'here_oneways'){
                       roadsSQL = generateHereRoadsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});
                   } else{
                       roadsSQL = generateRoadsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});
                   }
                navigator.clipboard.writeText(roadsSQL).then(() => {
                    showStatus('Roads SQL copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = roadsSQL;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('Roads SQL copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating roads SQL: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Download GeoJSON with quadkeys
        document.getElementById('downloadGeoJSONBtn').addEventListener('click', function() {
            if (!currentRouteData) return;

            const route = currentRouteData.routes[currentRouteIndex];
            const features = [];

            // Create route feature
            const allCoords = [];
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`,
                    type: 'route'
                }
            };

            features.push(routeFeature);

            // Create quadkey features
            const resultsText = document.getElementById('resultsOutput').textContent;
            const lines = resultsText.split('\n');
            let currentCountry = null;

            for (const line of lines) {
                if (line.includes(':')) {
                    const parts = line.split(':');
                    if (parts.length === 2 && parts[1].includes('quadkeys')) {
                        currentCountry = parts[0].trim();
                    }
                } else if (line.trim() && currentCountry && line.includes(',')) {
                    const quadkeys = line.split(',').map(q => q.trim()).filter(q => q);
                    for (const quadkey of quadkeys) {
                        const bounds = quadkeyToBounds(quadkey);

                        const polygonCoords = [
                            [bounds.west, bounds.north],
                            [bounds.east, bounds.north],
                            [bounds.east, bounds.south],
                            [bounds.west, bounds.south],
                            [bounds.west, bounds.north]
                        ];

                        const quadkeyFeature = {
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: [polygonCoords]
                            },
                            properties: {
                                quadkey: quadkey,
                                country: currentCountry
                            }
                        };

                        features.push(quadkeyFeature);
                    }
                }
            }

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_quadkeys_${currentRouteIndex}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('Results GeoJSON downloaded!', 'success');
        });

        function generateMultipolygonWKT(countryQuadkeys) {
            const polygons = [];

            for (const quadkey of countryQuadkeys) {
                const bounds = quadkeyToBounds(quadkey);

                // Create polygon for this quadkey (rectangle)
                // WKT polygon format: ((west south, west north, east north, east south, west south))
                const polygon = `((${bounds.west} ${bounds.south}, ${bounds.west} ${bounds.north}, ${bounds.east} ${bounds.north}, ${bounds.east} ${bounds.south}, ${bounds.west} ${bounds.south}))`;
                polygons.push(polygon);
            }

            if (polygons.length === 0) {
                return '';
            }

            // MULTIPOLYGON format: MULTIPOLYGON(((polygon1)), ((polygon2)), ...)
            return `MULTIPOLYGON(${polygons.join(', ')})`;
        }

        function generateHereRoadsSQL(countryQuadkeys) {
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            const countryConditions = [];
            let escapedWKT;
            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];
                if (quadkeys.length === 0) continue;
                const wktMultipolygon = generateMultipolygonWKT(quadkeys);
                escapedWKT = wktMultipolygon.replace(/'/g, "''");
            }

            const query = `WITH ways AS (
          SELECT
            id,
            osmium_id,
            mapbox_id,
            type,
            tags,
            nds,
            dt
          FROM
            roads_hereproduction.road_pipeline_v3_0_0_road_here
          WHERE
            dt = '2025-11-20'
            AND region = 'Europe_West'
            AND type = 'way'
            and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')
        ),
        nodes AS (
          SELECT
            id,
            lat,
            lon
          FROM
            roads_hereproduction.road_pipeline_v3_0_0_road_here
          WHERE
            dt = '2025-11-20'
            AND region = 'Europe_West'
            AND type = 'node'
            AND lat IS NOT NULL
            AND lon IS NOT NULL
        ),
        unique_way_points AS (
          SELECT
            *
          FROM (
            SELECT
              w.id,
              w.osmium_id,
              w.mapbox_id,
              w.type,
              w.tags,
              w.dt,
              t.node_index,
              ST_Point(n.lon, n.lat) AS point_geom,
              LAG(ST_Point(n.lon, n.lat), 1) OVER (PARTITION BY w.id ORDER BY t.node_index) AS prev_point_geom
            FROM
              ways AS w
            CROSS JOIN
              UNNEST(w.nds) WITH ORDINALITY AS t(node_id, node_index)
            JOIN
              nodes AS n ON t.node_id = n.id
          )
          WHERE
            prev_point_geom IS NULL OR NOT ST_Equals(point_geom, prev_point_geom)
        ),
        geom AS (
            SELECT
              uwp.id,
              uwp.osmium_id,
              uwp.mapbox_id,
              uwp.type,
              uwp.tags,
              uwp.dt,
              array_agg(uwp.point_geom ORDER BY uwp.node_index) as geometry_arr,
              ST_LineString(array_agg(uwp.point_geom ORDER BY uwp.node_index)) AS geometry
            FROM
              unique_way_points AS uwp
            GROUP BY
              uwp.id,
              uwp.osmium_id,
              uwp.mapbox_id,
              uwp.type,
              uwp.tags,
              uwp.dt
            HAVING
              count(uwp.point_geom) >= 2
        )
        SELECT
              id,
              tags,
              ST_AsText(geometry) as geometry_wkt
        FROM geom
        WHERE
            ST_Intersects(
                geometry,
                st_geometryfromtext('${escapedWKT}')
            )`;
            return query;
        }

        // Generate signs SQL with WKT multipolygons for each country
        function generateSignsSQL(countryQuadkeys) {
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            const strFormattedDate = `'${formattedDate}'`;

            // Get sorted countries
            const sortedCountries = Object.keys(countryQuadkeys).sort();

            // Build country-specific conditions with WKT multipolygons
            const countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                if (quadkeys.length === 0) continue;

                // Generate WKT multipolygon for this country's quadkeys
                const wktMultipolygon = generateMultipolygonWKT(quadkeys);

                if (wktMultipolygon) {
                    // Escape single quotes in WKT by doubling them
                    const escapedWKT = wktMultipolygon.replace(/'/g, "''");

                    const countryCondition = `(country in ('${country}')
                    and st_intersects(
                          st_point(lon, lat),
                          st_geometryfromtext('${escapedWKT}')
                       )
                    )`;
                    countryConditions.push(countryCondition);
                }
            }

            if (countryConditions.length === 0) {
                return '-- No quadkeys found for any country';
            }

            // Combine all country conditions with OR
            let finalCondition = '';
            if (countryConditions.length === 1) {
                finalCondition = countryConditions[0];
            } else {
                finalCondition = '(' + countryConditions.join('\nor ') + '\n)';
            }

            if (currentProcessingMode === 'speed_limits') {
                endFields = `((detection_type like ('%speed_limit%') and detection_type not like ('%road_marking%'))
                    or detection_type like ('%city%')
                    or detection_type like ('%end_of_speedlimit%')
                    or detection_type like ('%end_general%')
                    or detection_type like ('%motorway%')
                    or detection_type like ('%residential_area%'))`;
            } else if (currentProcessingMode === 'oneways'){
                endFields = `detection_type in ('oneway','no_entrance','arrow_no_left','arrow_left','arrow_right','arrow_straight','arrow_left_ahead','arrow_right_ahead','arrow_no_right')`;
            }

            // Build complete signs query
            const query = `select id, lon, lat, detection_type, angle, cluster_size, confidence, dt, supplementary_type, sub_type, is_electronic, from_tunnel, country from roads_rsd_production.source_v3_0_0_deduplicated_points
                where dt = ${strFormattedDate}
                and ${finalCondition}
                and cluster_size > 10 and confidence > 0.1 and status <> 'Deleted'
                and ${endFields}`;
            return query;
        }

        document.getElementById('copySignsSqlBtn').addEventListener('click', function() {
            if (!currentFilteredCountryQuadkeys && (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0)) {
                showStatus('No quadkey data available. Please add quadkeys first.', 'error');
                return;
            }

            try {
                const signsSQL = generateSignsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});

                navigator.clipboard.writeText(signsSQL).then(() => {
                    showStatus('Signs SQL copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = signsSQL;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('Signs SQL copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating signs SQL: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Global variables for signs data
        let signsCsvData = [];
        let combinedGeoJSON = null;

        // Parse Signs CSV
        document.getElementById('signsCsvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    signsCsvData = parseSignsCSV(csvContent);

                    if (signsCsvData.length === 0) {
                        showStatus('No valid signs found in CSV file', 'error');
                        return;
                    }

                    document.getElementById('signsCsvInputLabel').textContent = file.name;
                    document.getElementById('processSignsCSVBtn').disabled = false;
                    showStatus(`Loaded ${signsCsvData.length} signs from CSV`, 'success');

                } catch (error) {
                    showStatus(`Error parsing Signs CSV: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Parse Signs CSV content
        function parseSignsCSV(csvContent) {
            const signs = [];
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                throw new Error('Signs CSV file must have at least a header and one data row');
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = parseCSVLine(line);

                if (values.length < headers.length) {
                    console.warn(`Skipping line ${i}: insufficient columns`);
                    continue;
                }

                const sign = {};

                // Map values to headers
                headers.forEach((header, index) => {
                    let value = values[index] || '';
                    // Remove surrounding quotes
                    if (typeof value === 'string') {
                        value = value.replace(/^["']|["']$/g, '').trim();
                    }
                    sign[header] = value;
                });

                // Try to get coordinates from different sources
                let lat = null, lon = null;

                // 1. Try from explicit lat/lon columns
                if (sign.lat && sign.lon) {
                    lat = parseFloat(sign.lat);
                    lon = parseFloat(sign.lon);
                }

                // 2. Try from geometry_wkt
                if ((!lat || !lon) && sign.geometry_wkt) {
                    const coords = parseWKTGeometry(sign.geometry_wkt);
                    if (coords && coords.length > 0) {
                        if (sign.geometry_wkt.toUpperCase().includes('POINT')) {
                            lon = coords[0][0];
                            lat = coords[0][1];
                        }
                    }
                }

                // 3. Try from coordinates column (if exists)
                if ((!lat || !lon) && sign.coordinates) {
                    try {
                        const coords = JSON.parse(sign.coordinates);
                        if (Array.isArray(coords) && coords.length >= 2) {
                            lon = coords[0];
                            lat = coords[1];
                        }
                    } catch (e) {
                        // Not JSON, try to parse as string
                        const match = sign.coordinates.match(/[-+]?\d*\.\d+|\d+/g);
                        if (match && match.length >= 2) {
                            lon = parseFloat(match[0]);
                            lat = parseFloat(match[1]);
                        }
                    }
                }

                if (lat !== null && lon !== null) {
                    sign.coordinates = [lon, lat];
                    sign.lat = lat.toString();
                    sign.lon = lon.toString();

                    // Process maxspeed
                    if (sign.detection_type) {
                        if (!sign.detection_type.toLowerCase().startsWith("speed_limit")) {
                            sign.maxspeed = sign.detection_type;
                        } else {
                            const parts = sign.detection_type.toLowerCase().split("speed_limit_");
                            sign.maxspeed = parts.length > 1 ? parts[1] : sign.detection_type;
                        }
                    }

                    // Ensure angle is a number
                    if (sign.angle) {
                        sign.angle = parseFloat(sign.angle) || 0;
                    } else {
                        sign.angle = 0;
                    }

                    signs.push(sign);
                } else {
                    console.warn(`Skipping sign ${sign.id || 'unknown'} - no valid coordinates found`);
                }
            }

            return signs;
        }

        // Process detection_type field
        function processDetectionType(detectionType) {
            if (!detectionType) return '';

            if (!detectionType.toLowerCase().startsWith("speed_limit")) {
                return detectionType;
            }

            // Extract speed limit value
            const parts = detectionType.toLowerCase().split("speed_limit_");
            if (parts.length > 1) {
                return parts[1];
            }
            return detectionType;
        }

        // Process Signs CSV and combine with roads
        document.getElementById('processSignsCSVBtn').addEventListener('click', async function() {
<!--            if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {-->
<!--                showStatus('Please process roads CSV first', 'error');-->
<!--                return;-->
<!--            }-->

            if (!processedRoadsGeoJSON && signsCsvData.length === 0) {
                showStatus('Please upload CSV files first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Processing signs and combining with roads...', 'info');

            try {
                combinedGeoJSON = await combineSignsWithRoads(signsCsvData, processedRoadsGeoJSON);
                document.getElementById('downloadCombinedResultsBtn').disabled = false;
                showStatus(`Combined ${signsCsvData.length} signs with roads data`, 'success');

            } catch (error) {
                showStatus(`Error processing signs: ${error.message}`, 'error');
                console.error(error);
            } finally {
                setLoading(false);
            }
        });

async function combineSignsWithRoads(signs, roadsGeoJSON) {
    const combinedGeoJSON = {};

    // Group signs by quadkey
    const signsByQuadkey = new Map();

    // First, assign signs to quadkeys based on coordinates
    for (let signIndex = 0; signIndex < signs.length; signIndex++) {
        const sign = signs[signIndex];
        if (!sign.coordinates) continue;

        const [signLng, signLat] = sign.coordinates;

        // Find which quadkey this sign belongs to
        let foundQuadkey = null;

        // Check all quadkeys in roadsGeoJSON
        for (const [country, quadkeys] of Object.entries(roadsGeoJSON)) {
            for (const [quadkey, roadFeatures] of Object.entries(quadkeys)) {
                if (roadFeatures.features.length === 0) continue;

                // Check if sign is within this quadkey
                const bounds = quadkeyToBounds(quadkey);
                if (isPointInBounds(signLng, signLat, bounds)) {
                    foundQuadkey = quadkey;
                    break;
                }
            }
            if (foundQuadkey) break;
        }

        if (foundQuadkey) {
            if (!signsByQuadkey.has(foundQuadkey)) {
                signsByQuadkey.set(foundQuadkey, []);
            }
            signsByQuadkey.get(foundQuadkey).push(sign);
        }

        if (signIndex % 100 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Now distribute signs to all countries in each quadkey
    for (const [country, quadkeys] of Object.entries(roadsGeoJSON)) {
        if (!combinedGeoJSON[country]) {
            combinedGeoJSON[country] = {};
        }

        for (const [quadkey, roadCollection] of Object.entries(quadkeys)) {
            if (!combinedGeoJSON[country][quadkey]) {
                combinedGeoJSON[country][quadkey] = {
                    type: 'FeatureCollection',
                    features: []
                };
            }

            // Add roads
            combinedGeoJSON[country][quadkey].features.push(...roadCollection.features);

            // Add signs for this quadkey (shared across all countries)
            const signsInQuadkey = signsByQuadkey.get(quadkey) || [];
            for (const sign of signsInQuadkey) {
                const signFeature = createSignFeature(sign, country, quadkey);
                combinedGeoJSON[country][quadkey].features.push(signFeature);
            }
        }
    }

    const totalSigns = Array.from(signsByQuadkey.values()).reduce((sum, arr) => sum + arr.length, 0);
    showStatus(`Shared ${totalSigns} signs across border quadkeys`, 'success');

    return combinedGeoJSON;
}

function createSignFeature(sign, country, quadkey) {
    let maxspeedValue = '';

    if (currentProcessingMode === 'speed_limits') {
        // Speed Limits mode: rename detection_type to maxspeed
        if (sign.detection_type) {
            if (!sign.detection_type.toLowerCase().startsWith("speed_limit")) {
                maxspeedValue = sign.detection_type;
            } else {
                // Extract speed limit value
                const parts = sign.detection_type.toLowerCase().split("speed_limit_");
                maxspeedValue = parts.length > 1 ? parts[1] : sign.detection_type;
            }
        }
    } else {
        // Oneways mode: keep original detection_type
        maxspeedValue = sign.detection_type || '';
    }

    // Parse coordinates
    let lat = 0, lon = 0;
    if (sign.coordinates && Array.isArray(sign.coordinates) && sign.coordinates.length >= 2) {
        lon = sign.coordinates[0];
        lat = sign.coordinates[1];
    } else if (sign.lat && sign.lon) {
        lat = parseFloat(sign.lat);
        lon = parseFloat(sign.lon);
    }

    // Parse angle for URLs
    const angle = parseFloat(sign.angle) || 0;

    // Generate all URLs
    const properties = {
        id: sign.id || '',
        supplementary_type: sign.supplementary_type || '',
        angle: angle.toString(),
        confidence: sign.confidence || '',
        cluster_size: sign.cluster_size || '',
        url_rsd_link: getLvdExplorerLink(lon, lat, 18),
        url_google: withGoogleLink(lon, lat, angle),
        url_bing: getBingLink(lon, lat, angle),
        url_mapillary: getMapillaryLink(lon, lat, angle),
        url_tabula_rasa_link: getTabulaLink(lat, lon)
    };

    // Add maxspeed or detection_type based on mode
    if (currentProcessingMode === 'speed_limits') {
        properties.maxspeed = maxspeedValue;
    } else {
        properties.detection_type = sign.detection_type || '';
        // Also include maxspeed if it exists in original data
        if (sign.maxspeed) {
            properties.maxspeed = sign.maxspeed;
        }
    }

    // Add optional timestamp fields if they exist
    if (sign.creation_timestamp) properties.creation_timestamp = sign.creation_timestamp;
    if (sign.last_modified_timestamp) properties.last_modified_timestamp = sign.last_modified_timestamp;

    return {
        type: 'Feature',
        properties: properties,
        geometry: {
            type: 'Point',
            coordinates: [lon, lat]
        }
    };
}

        function processMaxspeed(detectionType) {
            if (!detectionType) return '';

            if (!detectionType.toLowerCase().startsWith("speed_limit")) {
                return detectionType;
            }

            // Extract speed limit value
            const parts = detectionType.toLowerCase().split("speed_limit_");
            if (parts.length > 1) {
                return parts[1]; // Returns just the speed value, e.g., "50"
            }
            return detectionType;
        }

        // Download combined GeoJSON
        document.getElementById('downloadCombinedResultsBtn').addEventListener('click', async function() {
            if (!combinedGeoJSON || Object.keys(combinedGeoJSON).length === 0) {
                showStatus('No combined data available', 'error');
                return;
            }

            try {
                await loadJSZip();
                const zip = new JSZip();
                let fileCount = 0;

                for (const [country, quadkeys] of Object.entries(combinedGeoJSON)) {
                    const countryFolder = zip.folder(country);

                    for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                        if (geojson.features.length > 0) {
                            // Separate roads and signs
                            const roadsFeatures = geojson.features.filter(f => f.properties.type !== 'sign');
                            const signsFeatures = geojson.features.filter(f => f.properties.type === 'sign');

                            // Create combined file
                            const fileName = `${quadkey}.geojson`;
                            countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                            fileCount++;

<!--                            // Also create separate files for roads and signs-->
<!--                            if (roadsFeatures.length > 0) {-->
<!--                                const roadsGeoJSON = {-->
<!--                                    type: 'FeatureCollection',-->
<!--                                    features: roadsFeatures-->
<!--                                };-->
<!--                                const roadsFileName = `${quadkey}_roads.geojson`;-->
<!--                                countryFolder.file(roadsFileName, JSON.stringify(roadsGeoJSON, null, 2));-->
<!--                                fileCount++;-->
<!--                            }-->

<!--                            if (signsFeatures.length > 0) {-->
<!--                                const signsGeoJSON = {-->
<!--                                    type: 'FeatureCollection',-->
<!--                                    features: signsFeatures-->
<!--                                };-->
<!--                                const signsFileName = `${quadkey}_signs.geojson`;-->
<!--                                countryFolder.file(signsFileName, JSON.stringify(signsGeoJSON, null, 2));-->
<!--                                fileCount++;-->
<!--                            }-->
                        }
                    }
                }

                // Generate and download zip file
                zip.generateAsync({ type: 'blob' }).then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    let currentDate = new Date();
                    let iso = currentDate.toISOString()
                    a.download = `roads_signs_${currentProcessingMode}_${iso}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Count totals
                    let totalFeatures = 0;
                    let totalRoads = 0;
                    let totalSigns = 0;

                    for (const [country, quadkeys] of Object.entries(combinedGeoJSON)) {
                        for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                            totalFeatures += geojson.features.length;
                            totalRoads += geojson.features.filter(f => f.properties.type !== 'sign').length;
                            totalSigns += geojson.features.filter(f => f.properties.type === 'sign').length;
                        }
                    }

                    showStatus(`Downloaded ${fileCount} GeoJSON files with ${totalRoads} roads and ${totalSigns} signs`, 'success');
                });

            } catch (error) {
                showStatus('Error creating zip file: ' + error.message, 'error');
                console.error(error);
            }
        });

        // Geographic utility functions for URL generation
        function normalizeDeg360(deg) {
            let normalized = deg;
            while (normalized >= 360) {
                normalized -= 360;
            }
            while (normalized < 0) {
                normalized += 360;
            }
            return normalized;
        }

        function getOppositeAngle(deg) {
            return normalizeDeg360(deg + 180.0);
        }

        // Calculate destination point given start point, bearing, and distance
        function calculateDestination(lat, lon, bearing, distanceMeters) {
            // Simple spherical Earth calculation (good enough for short distances)
            const R = 6371000; // Earth's radius in meters
            const bearingRad = bearing * Math.PI / 180;
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;

            const angularDistance = distanceMeters / R;

            const lat2Rad = Math.asin(
                Math.sin(latRad) * Math.cos(angularDistance) +
                Math.cos(latRad) * Math.sin(angularDistance) * Math.cos(bearingRad)
            );

            const lon2Rad = lonRad + Math.atan2(
                Math.sin(bearingRad) * Math.sin(angularDistance) * Math.cos(latRad),
                Math.cos(angularDistance) - Math.sin(latRad) * Math.sin(lat2Rad)
            );

            return {
                lat: lat2Rad * 180 / Math.PI,
                lon: lon2Rad * 180 / Math.PI
            };
        }

        // URL generation functions
        function withGoogleLink(lon, lat, hdg, distance = 10) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, distance);
            return `https://maps.google.com/maps?q=&layer=c&cbll=${dest.lat},${dest.lon}&cbp=11,${hdgNum},0,0,0`;
        }

        function getTabulaLink(lat, lon) {
            const disable_features = "points,service_roads,paths,buildings,building_parts,indoor,landuse,boundaries,water,rail,pistes,aerialways,power,past_future,others";
            return `https://tabula-rasa-roads-production.tilestream.net/id-internal/index.html#disable_features=${disable_features}&map=20.90/${lat}/${lon}`;
        }

        function getMapillaryLink(lon, lat, hdg, zoom = 17) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, 10);
            return `https://www.mapillary.com/app/?lat=${dest.lat}&lng=${dest.lon}&z=${zoom}`;
        }

        function getBingLink(lon, lat, hdg) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, 10);
            return `https://www.bing.com/maps?cp=${dest.lat}~${dest.lon}&lvl=15&dir=${hdgNum}&style=x&v=2&sV=1`;
        }

        function getLvdExplorerLink(lon, lat, zoom = 18) {
            return `https://sites.mapbox.com/lvd-explorer/#${zoom}/${lat}/${lon}`;
        }

        function isQuadkeyInResults(quadkey) {
            if (!currentCountryQuadkeys) return false;

            for (const quadkeys of Object.values(currentCountryQuadkeys)) {
                if (quadkeys.includes(quadkey)) {
                    return true;
                }
            }
            return false;
        }

        function updateSearchActionButtons() {
    const addBtn = document.getElementById('addSearchedQuadkeysBtn');
    const removeBtn = document.getElementById('removeSearchedQuadkeysBtn');

    if (searchedQuadkeys.length === 0) {
        addBtn.disabled = true;
        removeBtn.disabled = true;
        return;
    }

    // Check how many quadkeys are already in results
    let inResultsCount = 0;
    let notInResultsCount = 0;

    for (const quadkey of searchedQuadkeys) {
        if (isQuadkeyInResults(quadkey)) {
            inResultsCount++;
        } else {
            notInResultsCount++;
        }
    }

    addBtn.disabled = notInResultsCount === 0;
    removeBtn.disabled = inResultsCount === 0;

    // Update button text
    addBtn.textContent = notInResultsCount > 0 ? `Add ${notInResultsCount} to Results` : 'All Already Added';
    removeBtn.textContent = inResultsCount > 0 ? `Remove ${inResultsCount} from Results` : 'None in Results';
}

function initQuadkeySearch() {
    const searchInput = document.getElementById('searchQuadkey');
    const searchBtn = document.getElementById('searchQuadkeyBtn');
    const searchResult = document.getElementById('searchResult');
    const searchActions = document.getElementById('searchActions');
    const addSearchedBtn = document.getElementById('addSearchedQuadkeysBtn');
    const removeSearchedBtn = document.getElementById('removeSearchedQuadkeysBtn');

    let searchedQuadkeys = []; // Store searched quadkeys
    let searchedQuadkeysData = new Map(); // Store quadkey -> data mapping

    // Search and zoom to quadkeys
    searchBtn.addEventListener('click', async function() {
        const input = searchInput.value.trim();
        if (!input) {
            searchResult.textContent = 'Please enter quadkeys';
            searchResult.style.color = '#e74c3c';
            searchActions.style.display = 'none';
            return;
        }

        // Parse comma-separated quadkeys
        const quadkeyStrings = input.split(',').map(q => q.trim()).filter(q => q.length > 0);

        // Validate quadkey formats
        const invalidQuadkeys = quadkeyStrings.filter(q => !/^\d+$/.test(q));
        if (invalidQuadkeys.length > 0) {
            searchResult.textContent = `Invalid quadkey format: ${invalidQuadkeys.join(', ')}. Quadkeys should contain only digits.`;
            searchResult.style.color = '#e74c3c';
            searchActions.style.display = 'none';
            return;
        }

        try {
            // Clear previous highlights
            clearSearchHighlight();
            searchedQuadkeys = [];
            searchedQuadkeysData.clear();

            let combinedBounds = null;
            const results = [];

            // Process each quadkey
            for (let i = 0; i < quadkeyStrings.length; i++) {
                const quadkey = quadkeyStrings[i];

                // Get bounds for the quadkey
                const bounds = quadkeyToBounds(quadkey);

                // Store quadkey data
                searchedQuadkeys.push(quadkey);
                searchedQuadkeysData.set(quadkey, { bounds, index: i });

                // Highlight this quadkey on the map
                highlightQuadkeyOnMap(quadkey, bounds, i);

                // Get countries for this quadkey
                const countries = await getQuadkeyCountries(quadkey);

                // Update combined bounds for zooming
                const quadkeyBounds = L.latLngBounds(
                    [bounds.south, bounds.west],
                    [bounds.north, bounds.east]
                );

                if (combinedBounds) {
                    combinedBounds.extend(quadkeyBounds);
                } else {
                    combinedBounds = quadkeyBounds;
                }

                // Add to results display
<!--                results.push(`-->
<!--                    <div class="quadkey-result" style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 4px;">-->
<!--                        <strong>#${i + 1}: ${quadkey}</strong><br>-->
<!--                        Zoom level: ${quadkey.length}<br>-->
<!--                        Countries: ${countries.length > 0 ? countries.join(', ') : 'Unknown'}<br>-->
<!--                        Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}-->
<!--                        ${isQuadkeyInResults(quadkey) ? '<br><span style="color: #27ae60;">âœ“ Already in results</span>' : ''}-->
<!--                    </div>-->
<!--                `);-->
            }

            // Zoom to show all quadkeys
            if (combinedBounds) {
                map.fitBounds(combinedBounds, {
                    padding: [50, 50],
                    maxZoom: 18
                });
            }

            // Show search results
            searchResult.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>Found ${quadkeyStrings.length} quadkey(s):</strong>
                </div>
                ${results.join('')}
            `;
            searchResult.style.color = '#333';

            // Show action buttons
            searchActions.style.display = 'block';

            // Update button states
            updateSearchActionButtons();

        } catch (error) {
<!--            searchResult.textContent = `Error: ${error.message}`;-->
<!--            searchResult.style.color = '#e74c3c';-->
<!--            searchActions.style.display = 'none';-->
            console.error('Quadkey search error:', error);
        }
    });

    // Add all searched quadkeys to results
    addSearchedBtn.addEventListener('click', async function() {
        if (searchedQuadkeys.length === 0) {
            showStatus('No quadkeys to add', 'error');
            return;
        }

        try {
            setLoading(true);
            let addedCount = 0;

            for (const quadkey of searchedQuadkeys) {
                if (!isQuadkeyInResults(quadkey)) {
                    const data = searchedQuadkeysData.get(quadkey);
                    if (data) {
                        const countries = await getQuadkeyCountries(quadkey);
                        if (countries.length > 0) {
                            addQuadkey(quadkey, countries);
                            addedCount++;
                        }
                    }
                }
            }

            if (addedCount > 0) {
                updateDisplayAndVisualization();
                recalculateStatistics();
                if (currentCountryQuadkeys) {
                    createCountryControls(currentCountryQuadkeys, true);
                }
                showStatus(`Added ${addedCount} quadkey(s) to results`, 'success');
                updateSearchResultStatus();
            } else {
                showStatus('All quadkeys are already in results', 'info');
            }

        } catch (error) {
            showStatus(`Error adding quadkeys: ${error.message}`, 'error');
        } finally {
            setLoading(false);
        }
    });

    // Remove all searched quadkeys from results
    removeSearchedBtn.addEventListener('click', function() {
        if (searchedQuadkeys.length === 0) {
            showStatus('No quadkeys to remove', 'error');
            return;
        }

        let removedCount = 0;

        for (const quadkey of searchedQuadkeys) {
            if (isQuadkeyInResults(quadkey)) {
                const data = searchedQuadkeysData.get(quadkey);
                if (data) {
                    // Get countries for this quadkey
                    const countries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    if (countries.length > 0) {
                        removeQuadkey(quadkey, countries);
                        removedCount++;
                    }
                }
            }
        }

        if (removedCount > 0) {
            updateDisplayAndVisualization();
            recalculateStatistics();
            if (currentCountryQuadkeys) {
                createCountryControls(currentCountryQuadkeys, true);
            }
            showStatus(`Removed ${removedCount} quadkey(s) from results`, 'success');
            updateSearchResultStatus();
        } else {
            showStatus('None of the searched quadkeys are in results', 'info');
        }
    });

    // Allow Enter key to search
    searchInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            searchBtn.click();
        }
    });

    // Clear search result when input changes
    searchInput.addEventListener('input', function() {
        searchResult.textContent = '';
        searchActions.style.display = 'none';
        clearSearchHighlight();
        searchedQuadkeys = [];
        searchedQuadkeysData.clear();
    });
}

function clearSearchHighlight() {
    if (window.currentHighlights) {
        window.currentHighlights.forEach(highlight => {
            map.removeLayer(highlight);
        });
        window.currentHighlights = [];
    }

    if (window.currentSearchMarker) {
        map.removeLayer(window.currentSearchMarker);
        window.currentSearchMarker = null;
    }
}

        // Highlight a quadkey on the map
function highlightQuadkeyOnMap(quadkey, bounds, index) {
    // Create a unique color for each quadkey
    const colors = [
        '#ff0000', '#ff8000', '#ffff00', '#80ff00', '#00ff00',
        '#00ff80', '#00ffff', '#0080ff', '#0000ff', '#8000ff'
    ];
    const colorIndex = index % colors.length;

    // Create a highlighted rectangle for the quadkey
    const highlight = L.rectangle(
        [[bounds.south, bounds.west], [bounds.north, bounds.east]],
        {
            color: colors[colorIndex],
            weight: 3,
            fillColor: colors[colorIndex],
            fillOpacity: 0.2,
            dashArray: '10, 10'
        }
    ).addTo(map);
}

        // Focus on the quadkey with animation
        function focusQuadkey(quadkey, bounds) {
            // Create bounds for the quadkey
            const quadkeyBounds = L.latLngBounds(
                [bounds.south, bounds.west],
                [bounds.north, bounds.east]
            );

            // Fit bounds with padding
            map.fitBounds(quadkeyBounds, {
                padding: [50, 50],
                maxZoom: Math.min(quadkey.length + 4, 18)
            });

            // Add a pulsing marker at the center
            const centerLat = (bounds.north + bounds.south) / 2;
            const centerLng = (bounds.west + bounds.east) / 2;

            // Remove any existing marker
            if (window.currentSearchMarker) {
                map.removeLayer(window.currentSearchMarker);
            }

            // Create pulsing marker
            const marker = L.marker([centerLat, centerLng], {
                icon: L.divIcon({
                    className: 'pulse-marker',
                    html: '<div class="pulse-dot"></div>',
                    iconSize: [20, 20]
                })
            }).addTo(map);

            window.currentSearchMarker = marker;

            // Auto-remove marker after 10 seconds
            setTimeout(() => {
                if (window.currentSearchMarker === marker) {
                    map.removeLayer(marker);
                    window.currentSearchMarker = null;
                }
            }, 1000);
        }

        // Add CSS for the pulsing marker and highlight
        const style = document.createElement('style');
        style.textContent = `
            .pulse-marker {
                background: transparent;
                border: none;
            }

            .pulse-dot {
                width: 20px;
                height: 20px;
                background-color: #ff0000;
                border-radius: 50%;
                position: relative;
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 1);
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0% {
                    transform: scale(0.95);
                    box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
                }
                70% {
                    transform: scale(1);
                    box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
                }
                100% {
                    transform: scale(0.95);
                    box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
                }
            }

            .quadkey-highlight-tooltip {
                color: black;
                font-weight: bold;
                padding: 5px 10px;
            }
        `;
        document.head.appendChild(style);

        // Update the display to show when a quadkey is already in the results
        function updateQuadkeyInResultsStatus(quadkey) {
            const searchResult = document.getElementById('searchResult');

            if (!currentCountryQuadkeys) {
                return;
            }

            // Check if quadkey is already in results
            let isInResults = false;
            let countriesIn = [];

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (quadkeys.includes(quadkey)) {
                    isInResults = true;
                    countriesIn.push(country);
                }
            }

            if (isInResults) {
                const existingInfo = document.createElement('div');
                existingInfo.style.marginTop = '10px';
                existingInfo.style.padding = '8px';
                existingInfo.style.backgroundColor = '#d4edda';
                existingInfo.style.border = '1px solid #c3e6cb';
                existingInfo.style.borderRadius = '4px';
                existingInfo.style.color = '#155724';
                existingInfo.innerHTML = `
                    <strong>âœ“ This quadkey is already in your results</strong><br>
                    Countries: ${countriesIn.join(', ')}<br>
                    <button onclick="focusOnExistingQuadkey('${quadkey}')"
                            style="margin-top: 5px; padding: 3px 8px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Show in results
                    </button>
                `;

                // Add or update the existing info
                const existingDiv = document.getElementById('quadkey-in-results-info');
                if (existingDiv) {
                    existingDiv.replaceWith(existingInfo);
                } else {
                    existingInfo.id = 'quadkey-in-results-info';
                    searchResult.appendChild(existingInfo);
                }
            } else {
                // Remove existing info if present
                const existingDiv = document.getElementById('quadkey-in-results-info');
                if (existingDiv) {
                    existingDiv.remove();
                }
            }
        }

        // Focus on an existing quadkey in the results
        function focusOnExistingQuadkey(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            focusQuadkey(quadkey, bounds);

            // Also highlight the existing polygon if it's visible
            for (const country in quadkeyLayers) {
                const layers = quadkeyLayers[country];
                for (const layer of layers) {
                    // Check if this layer represents our quadkey
                    // We can check by comparing bounds or storing quadkey in layer data
                    const layerBounds = layer.getBounds();
                    if (Math.abs(layerBounds.getSouth() - bounds.south) < 0.0001 &&
                        Math.abs(layerBounds.getNorth() - bounds.north) < 0.0001 &&
                        Math.abs(layerBounds.getWest() - bounds.west) < 0.0001 &&
                        Math.abs(layerBounds.getEast() - bounds.east) < 0.0001) {

                        // Flash the polygon
                        const originalStyle = {
                            color: layer.options.color,
                            weight: layer.options.weight,
                            fillOpacity: layer.options.fillOpacity
                        };

                        // Flash effect
                        layer.setStyle({
                            color: '#ff0000',
                            weight: 4,
                            fillOpacity: 0.5
                        });

                        // Revert after 3 seconds
                        setTimeout(() => {
                            layer.setStyle(originalStyle);
                        }, 3000);

                        break;
                    }
                }
            }
        }

        function isQuadkeyInResults(quadkey) {
            if (!currentCountryQuadkeys) return false;

            for (const quadkeys of Object.values(currentCountryQuadkeys)) {
                if (quadkeys.includes(quadkey)) {
                    return true;
                }
            }
            return false;
        }

        // Update search result status display
        function updateSearchResultStatus() {
            const searchResult = document.getElementById('searchResult');
            const quadkeyElements = searchResult.querySelectorAll('.quadkey-result');

            quadkeyElements.forEach(element => {
                const match = element.textContent.match(/#\d+: (\d+)/);
                if (match) {
                    const quadkey = match[1];
                    const statusSpan = element.querySelector('span');
                    if (isQuadkeyInResults(quadkey)) {
                        if (statusSpan) {
                            statusSpan.textContent = 'âœ“ Already in results';
                            statusSpan.style.color = '#27ae60';
                        } else {
                            element.innerHTML += '<br><span style="color: #27ae60;">âœ“ Already in results</span>';
                        }
                    } else {
                        if (statusSpan) {
                            statusSpan.textContent = '';
                        }
                    }
                }
            });
        }

        // Update the search function to check if quadkey is already in results
        document.getElementById('searchQuadkeyBtn').addEventListener('click', async function() {
            const quadkey = document.getElementById('searchQuadkey').value.trim();
            if (!quadkey) {
                searchResult.textContent = 'Please enter a quadkey';
                searchResult.style.color = '#e74c3c';
                return;
            }

            // Validate quadkey format (digits only)
            if (!/^\d+$/.test(quadkey)) {
                searchResult.textContent = 'Invalid quadkey format. Quadkeys should contain only digits.';
                searchResult.style.color = '#e74c3c';
                return;
            }

            try {
                // Get bounds for the quadkey
                const bounds = quadkeyToBounds(quadkey);

                // Calculate center of the quadkey
                const centerLat = (bounds.north + bounds.south) / 2;
                const centerLng = (bounds.west + bounds.east) / 2;

                // Zoom to the quadkey
                const zoomLevel = Math.max(quadkey.length + 2, 10);
                map.setView([centerLat, centerLng], zoomLevel);

                // Highlight the quadkey on the map
                highlightQuadkeyOnMap(quadkey, bounds);

                // Get countries for this quadkey
                const countries = await getQuadkeyCountries(quadkey);

                // Show search result
                searchResult.innerHTML = `
                    Zoom level: ${quadkey.length}<br>
                    Countries: ${countries.length > 0 ? countries.join(', ') : 'Unknown'}<br>
                    Bounds: ${bounds.south.toFixed(4)}, ${bounds.west.toFixed(4)} to ${bounds.north.toFixed(4)}, ${bounds.east.toFixed(4)}
                `;
                searchResult.style.color = '#27ae60';

                // Focus the quadkey on the map
                focusQuadkey(quadkey, bounds);

                // Check and show if quadkey is already in results
                updateQuadkeyInResultsStatus(quadkey);

            } catch (error) {
                searchResult.textContent = `Error: ${error.message}`;
                searchResult.style.color = '#e74c3c';
                console.error('Quadkey search error:', error);
            }
        });

const multiQuadkeyStyle = document.createElement('style');
multiQuadkeyStyle.textContent = `
    .quadkey-highlight-tooltip {
                color: black;
                padding: 5px 10px;
                background-color: rgba(255,0,0,0);
    }

    .quadkey-result {
        border-left: 4px solid #3498db;
    }

    #searchActions button {
        padding: 8px 15px;
        font-size: 0.9rem;
    }

    #searchActions button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
`;
document.head.appendChild(multiQuadkeyStyle);

// Update the focusOnExistingQuadkey to handle multiple quadkeys
function focusOnExistingQuadkeys(quadkeys) {
    if (!quadkeys || quadkeys.length === 0) return;

    let combinedBounds = null;

    // Create bounds for all quadkeys
    quadkeys.forEach(quadkey => {
        const bounds = quadkeyToBounds(quadkey);
        const quadkeyBounds = L.latLngBounds(
            [bounds.south, bounds.west],
            [bounds.north, bounds.east]
        );

        if (combinedBounds) {
            combinedBounds.extend(quadkeyBounds);
        } else {
            combinedBounds = quadkeyBounds;
        }
    });

    // Fit bounds with padding
    if (combinedBounds) {
        map.fitBounds(combinedBounds, {
            padding: [50, 50],
            maxZoom: 18
        });
    }
}

// Add select/deselect all functionality
function addSelectAllButtons() {
    const searchResult = document.getElementById('searchResult');

    // Check if select buttons already exist
    if (document.getElementById('selectAllQuadkeys') || document.getElementById('deselectAllQuadkeys')) {
        return;
    }

    const selectButtons = document.createElement('div');
    selectButtons.style.marginBottom = '10px';
    selectButtons.style.display = 'flex';
    selectButtons.style.gap = '10px';
    selectButtons.innerHTML = `
        <button id="selectAllQuadkeys" class="secondary-btn" style="padding: 5px 10px; font-size: 0.8rem;">Select All</button>
        <button id="deselectAllQuadkeys" class="secondary-btn" style="padding: 5px 10px; font-size: 0.8rem;">Deselect All</button>
    `;

    searchResult.insertBefore(selectButtons, searchResult.firstChild);

    // Add event listeners
    document.getElementById('selectAllQuadkeys').addEventListener('click', function() {
        // Implementation would depend on how you want to handle selection
        // Could add checkboxes to each quadkey result
    });

    document.getElementById('deselectAllQuadkeys').addEventListener('click', function() {
        // Implementation for deselection
    });
}

// Initialize the application with multiple quadkey search
document.addEventListener('DOMContentLoaded', function() {
    initMap();
    initQuadkeySearch();
    initProcessingMode();
    showStatus('Ready. Enter multiple quadkeys separated by commas in search.', 'info');
});
    </script>
    <!-- Load JSZip library for zip file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>
