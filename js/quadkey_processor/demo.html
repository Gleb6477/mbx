<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Quadkey Processor</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 10px 10px 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .left-panel {
                max-width: 100%;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            width: 400px;
            min-width: 400px;
        }

        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-label:hover {
            background-color: #e9ecef;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .results-container {
            margin-top: 20px;
            overflow-x: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-title {
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .results-content {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            max-width: 920px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            overflow: scroll;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .controls button {
            flex: 1;
        }

        .secondary-btn {
            background-color: #6c757d;
        }

        .secondary-btn:hover {
            background-color: #5a6268;
        }

        .success-btn {
            background-color: #28a745;
        }

        .success-btn:hover {
            background-color: #218838;
        }

        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .route-info p {
            margin-bottom: 5px;
        }

        .route-selector {
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            color: #6c757d;
            font-size: 0.9rem;
        }

        .performance-info {
            background: #e8f4fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .stats-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .route-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-controls button {
            flex: 1;
        }

        /* New styles for country controls */
        .country-controls {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        .country-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .country-control:hover {
            background-color: #e9ecef;
        }

        .country-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .country-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .country-name {
            font-weight: 600;
        }

        .country-count {
            background-color: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .border-control {
            margin-left: 10px;
            font-size: 0.8rem;
            color: #6c757d;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #6c757d;
        }

        .border-control:hover {
            background-color: #6c757d;
            color: white;
        }

        .border-control.excluded {
            background-color: #6c757d;
            color: white;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            margin-top: 30px;
        }

        .select-all-buttons {
            display: flex;
            gap: 5px;
        }

        .select-all-buttons button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .map-controls button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* New styles for CSV upload and processing */
        .csv-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .csv-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a6ee0;
        }

        .csv-processing-btn {
            background: linear-gradient(135deg, #4a6ee0, #764ba2);
            margin-top: 10px;
        }

        .csv-processing-btn:hover {
            background: linear-gradient(135deg, #3a5ecf, #663aa2);
        }

        .csv-download-btn {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            margin-top: 10px;
        }

        .csv-download-btn:hover {
            background: linear-gradient(135deg, #009985, #85b92d);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .country-selection-item {
            display: flex;
            margin: 10px 0;
            padding: 4px 4px 0px 130px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .country-selection-item input {
            margin-right: 10px;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #confirmSelection {
            background-color: #28a745;
            color: white;
        }

        #cancelSelection {
            background-color: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Route Quadkey Processor</h1>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <h2 class="panel-title">Input & Controls</h2>

                <div class="input-group">
                    <label for="routeFile">Upload Route JSON File</label>
                    <div class="file-input-container">
                        <input type="file" id="routeFile" class="file-input" accept=".json">
                        <label for="routeFile" class="file-input-label" id="fileInputLabel">Choose a JSON file</label>
                    </div>
                </div>

                <div class="input-group route-selector" id="routeSelectorContainer" style="display: none;">
                    <label for="routeSelect">Select Route</label>
                    <select id="routeSelect"></select>
                </div>

                <div class="route-controls">
                    <button id="downloadRouteBtn" class="secondary-btn" disabled>Download Route GeoJSON</button>
                    <button id="copyWktBtn" class="secondary-btn" disabled>Copy WKT</button>
                </div>

                <div class="input-group">
                    <label for="zoomLevel">Zoom Level (for Quadkey Calculation)</label>
                    <input type="number" id="zoomLevel" min="1" max="18" value="12">
                </div>

                <div class="map-controls">
                    <button id="addQuadkeyModeBtn" class="secondary-btn" disabled>Add Quadkey Mode</button>
                    <button id="removeQuadkeyModeBtn" class="secondary-btn" disabled>Remove Quadkey Mode</button>
                </div>

                <div class="status-message" id="statusMessage"></div>

                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing route data...</p>
                </div>

                <div class="route-info" id="routeInfo" style="display: none;">
                    <p><strong>Route Information</strong></p>
                    <p id="routeDetails"></p>
                </div>

                <div class="controls">
                    <button id="processBtn" disabled>Calculate Quadkeys</button>
                    <button id="downloadGeoJSONBtn" class="secondary-btn" disabled>Download Results GeoJSON</button>
                </div>

                <!-- Country Controls Section -->
                <div id="countryControlsContainer" style="display: none;">
                    <div class="controls-header">
                        <h3 class="panel-title">Country Controls</h3>
                        <div class="select-all-buttons">
                            <button id="selectAllBtn" class="secondary-btn">All</button>
                            <button id="selectNoneBtn" class="secondary-btn">None</button>
                        </div>
                    </div>
                    <div class="country-controls" id="countryControls">
                        <!-- Country controls will be dynamically added here -->
                    </div>
                </div>

                <div class="stats-info" id="statsInfo" style="display: none;">
                    <p><strong>Processing Statistics</strong></p>
                    <p id="statsDetails"></p>
                </div>

                <!-- CSV Upload Section -->
                <div class="csv-section">
                    <h3 class="panel-title">Roads CSV Processing</h3>

                    <div class="input-group">
                        <label for="csvFile">Upload Roads CSV File</label>
                        <div class="file-input-container">
                            <input type="file" id="csvFile" class="file-input" accept=".csv">
                            <label for="csvFile" class="file-input-label" id="csvInputLabel">Choose a CSV file</label>
                        </div>
                    </div>

                    <button id="processCSVBtn" class="csv-processing-btn" disabled>Process Roads CSV</button>
                    <button id="downloadCSVResultsBtn" class="csv-download-btn" disabled>Download Roads GeoJSON</button>
                </div>
            </div>
            <div class="panel">
                <h2 class="panel-title">Map & Results</h2>

                <div class="map-container">
                    <div id="map"></div>
                </div>

                <div class="results-container">
                    <div class="results-header">
                        <h3 class="results-title">Quadkeys Results</h3>
                        <div style="display: flex">
                            <button id="copyResultsBtn" class="secondary-btn" style="margin-left:20px" disabled>Copy Results</button>
                            <button id="copySqlResultsBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy SQL</button>
                        </div>
                    </div>
                    <div class="results-content" id="resultsOutput">
                        No results yet. Upload a route file and click "Calculate Quadkeys".
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Global variables
        let map;
        let routeLayer;
        let quadkeyLayers = {};
        let currentRouteData = null;
        let currentRouteIndex = 0;
        let countryCache = {};
        let processingController = null;
        let currentCountryQuadkeys = null;
        let quadkeyCountriesMap = new Map(); // Maps quadkey to array of countries
        let countryControlsState = {}; // Tracks which countries are enabled/disabled
        let countryBorderExclusions = new Set(); // Tracks which countries have border quadkeys excluded
        let addQuadkeyMode = false;
        let removeQuadkeyMode = false;
        let currentZoomLevel = 12;
        let originalStats = null;
        let csvRoadsData = []; // Store CSV roads data
        let processedRoadsGeoJSON = null; // Store processed roads GeoJSON
        let query = '';
        const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2NvdHRzZmFybGV5OTMiLCJhIjoiY2o4ODJxNjh4MWVndjJ3cWI5ODRlZ2hnayJ9.w9-dF3jh-GtQzk9h0wBUbw';

        // Initialize the map
        function initMap() {
            map = L.map('map').setView([40.7128, -74.0060], 10);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // Add click listener for adding/removing quadkeys
            map.on('click', function(e) {
                if (addQuadkeyMode) {
                    handleMapClick(e.latlng);
                }
            });
        }

        // Handle map click for adding/removing quadkeys
        async function handleMapClick(latlng) {
            const zoom = parseInt(document.getElementById('zoomLevel').value);
            const tile = tileAtZoom(latlng.lat, latlng.lng, zoom);
            const quadkey = toQuadkey(tile.x, tile.y, zoom);

            // Get countries for this quadkey
            const countries = await getQuadkeyCountries(quadkey);

            if (addQuadkeyMode) {
                // If it's a border quadkey (multiple countries), show country selection
                if (countries.length > 1) {
                    showCountrySelectionModal(quadkey, countries, 'add');
                } else {
                    addQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }
            } else if (removeQuadkeyMode) {
                // If it's a border quadkey (multiple countries), show country selection for removal
                if (countries.length > 1 && quadkeyCountriesMap.has(quadkey)) {
                    const currentCountries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    showCountrySelectionModal(quadkey, currentCountries, 'remove');
                } else {
                    removeQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }
            }
        }

        function showCountrySelectionModal(quadkey, countries, action) {
            // Create modal HTML
            const modalHTML = `
                <div id="countrySelectionModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <h3>Select Countries for Quadkey: ${quadkey}</h3>
                        <p>This quadkey spans multiple countries. Choose which countries to ${action}:</p>
                        <div id="countrySelectionList">
                            ${countries.map(country => `
                                <div class="country-selection-item">
                                    <label for="sel-${country}">${country}</label>
                                    <input type="checkbox" id="sel-${country}" style="width:20px;height:20px;margin-left:30px; margin-top:3px" value="${country}" checked>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-buttons">
                            <button id="confirmSelection">Confirm</button>
                            <button id="cancelSelection">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to page
            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer);

            // Add event listeners
            document.getElementById('confirmSelection').addEventListener('click', function() {
                const selectedCountries = [];
                countries.forEach(country => {
                    const checkbox = document.getElementById(`sel-${country}`);
                    if (checkbox.checked) {
                        selectedCountries.push(country);
                    }
                });

                if (selectedCountries.length > 0) {
                    if (action === 'add') {
                        addQuadkey(quadkey, selectedCountries);
                    } else {
                        removeQuadkey(quadkey, selectedCountries);
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }

                // Close modal
                document.body.removeChild(modalContainer);
            });

            document.getElementById('cancelSelection').addEventListener('click', function() {
                document.body.removeChild(modalContainer);
            });

            // Close modal when clicking outside
            document.getElementById('countrySelectionModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    document.body.removeChild(modalContainer);
                }
            });
        }

        // Convert route to WKT format
        function convertRouteToWKT(route) {
            if (!route || !route.legs) {
                throw new Error('Invalid route data');
            }

            const allCoords = [];

            // Extract all coordinates from the route
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No coordinates found in route');
            }

            // Convert coordinates to WKT format
            const wktCoordinates = allCoords.map(coord => `${coord[0]} ${coord[1]}`).join(', ');

            return `LINESTRING (${wktCoordinates})`;
        }

        // Copy WKT to clipboard
        document.getElementById('copyWktBtn').addEventListener('click', function() {
            if (!currentRouteData) {
                showStatus('No route data available', 'error');
                return;
            }

            try {
                const route = currentRouteData.routes[currentRouteIndex];
                const wkt = convertRouteToWKT(route);

                navigator.clipboard.writeText(wkt).then(() => {
                    showStatus('WKT copied to clipboard!', 'success');
                }).catch(() => {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = wkt;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('WKT copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating WKT: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Add a quadkey to the results with specific countries
        function addQuadkey(quadkey, countries) {
            // Add to quadkeyCountriesMap
            quadkeyCountriesMap.set(quadkey, new Set(countries));

            // Add to each country's quadkey set
            countries.forEach(country => {
                if (!currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = [];
                }
                if (!currentCountryQuadkeys[country].includes(quadkey)) {
                    currentCountryQuadkeys[country].push(quadkey);
                    currentCountryQuadkeys[country].sort();
                }
            });

            showStatus(`Added quadkey ${quadkey} for countries: ${countries.join(', ')}`, 'success');
        }

        // Remove a quadkey from specific countries
        function removeQuadkey(quadkey, countries) {
            // Remove from each specified country's quadkey set
            countries.forEach(country => {
                if (currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = currentCountryQuadkeys[country].filter(q => q !== quadkey);
                    // Remove country entry if no quadkeys left
                    if (currentCountryQuadkeys[country].length === 0) {
                        delete currentCountryQuadkeys[country];
                    }
                }
            });

            // Update quadkeyCountriesMap - remove countries or entire quadkey
            const currentCountries = quadkeyCountriesMap.get(quadkey);
            if (currentCountries) {
                countries.forEach(country => currentCountries.delete(country));

                // If no countries left, remove the quadkey entirely
                if (currentCountries.size === 0) {
                    quadkeyCountriesMap.delete(quadkey);
                }
            }

            showStatus(`Removed quadkey ${quadkey} from countries: ${countries.join(', ')}`, 'success');
        }

        // Recalculate statistics based on current data
        function recalculateStatistics() {
            if (!currentCountryQuadkeys) return;

            let totalQuadkeys = 0;
            let borderQuadkeys = 0;
            let totalCountries = new Set();

            // Count total quadkeys and border quadkeys
            const seenQuadkeys = new Set();
            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                totalCountries.add(country);
                quadkeys.forEach(quadkey => {
                    if (!seenQuadkeys.has(quadkey)) {
                        seenQuadkeys.add(quadkey);
                        totalQuadkeys++;

                        const countries = quadkeyCountriesMap.get(quadkey);
                        if (countries && countries.size > 1) {
                            borderQuadkeys++;
                        }
                    }
                });
            }

            // Update statistics display
            const statsEl = document.getElementById('statsDetails');
            statsEl.textContent = `Found ${totalQuadkeys} quadkeys, ${borderQuadkeys} border quadkeys across ${totalCountries.size} countries`;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';

            // Auto-hide success messages after 3 seconds
            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Show/hide loading indicator
        function setLoading(loading) {
            document.getElementById('loadingIndicator').style.display = loading ? 'block' : 'none';
            document.getElementById('processBtn').disabled = loading;

            if (loading && processingController) {
                processingController.abort();
            }
            processingController = new AbortController();
        }

        // Fast country detection using Mapbox Geocoding
        async function reverseGeocodeCountry(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;

            if (countryCache[cacheKey]) {
                return countryCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=country&access_token=${MAPBOX_TOKEN}`,
                    {
                        signal: processingController?.signal
                    }
                );

                if (!response.ok) {
                    throw new Error(`Mapbox API error: ${response.status}`);
                }

                const data = await response.json();

                // Extract country code from Mapbox response
                let countryCode = 'UNKNOWN';
                if (data.features && data.features.length > 0) {
                    const place = data.features[0];
                    countryCode = place.properties?.short_code?.toUpperCase() || 'UNKNOWN';
                }

                // Cache the result
                countryCache[cacheKey] = countryCode;

                return countryCode;

            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.warn(`Mapbox geocoding failed for (${lat}, ${lng}):`, error);
                return 'UNKNOWN';
            }
        }

        // Get countries for a quadkey by sampling multiple points
        async function getQuadkeyCountries(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            const countries = new Set();

            // Sample multiple points for border detection
            const samplePoints = [
                [bounds.north, bounds.west],  // NW corner
                [bounds.north, bounds.east],  // NE corner
                [bounds.south, bounds.west],  // SW corner
                [bounds.south, bounds.east],  // SE corner
                [(bounds.north + bounds.south) / 2, (bounds.west + bounds.east) / 2]  // Center
            ];

            // Process sample points
            const promises = samplePoints.map(([lat, lng]) => reverseGeocodeCountry(lat, lng));
            const results = await Promise.all(promises);

            results.forEach(country => {
                if (country && country !== 'UNKNOWN') {
                    countries.add(country);
                }
            });

            return Array.from(countries);
        }

        // Check if a line string intersects with a bounding box
        function lineStringIntersectsBounds(lineString, bounds) {
            // Simple bounding box intersection check first
            const lineBounds = getLineStringBounds(lineString);
            if (!boundsIntersect(lineBounds, bounds)) {
                return false;
            }

            // More detailed check - see if any segment intersects the bounds
            for (let i = 1; i < lineString.length; i++) {
                const prevCoord = lineString[i - 1];
                const currCoord = lineString[i];

                if (lineSegmentIntersectsBounds(prevCoord, currCoord, bounds)) {
                    return true;
                }
            }

            return false;
        }

        // Get bounding box of a line string
        function getLineStringBounds(lineString) {
            const lats = lineString.map(coord => coord[1]);
            const lngs = lineString.map(coord => coord[0]);

            return {
                west: Math.min(...lngs),
                east: Math.max(...lngs),
                south: Math.min(...lats),
                north: Math.max(...lats)
            };
        }

        // Check if two bounding boxes intersect
        function boundsIntersect(bounds1, bounds2) {
            return !(bounds1.east < bounds2.west ||
                     bounds1.west > bounds2.east ||
                     bounds1.south > bounds2.north ||
                     bounds1.north < bounds2.south);
        }

        // Check if a line segment intersects with a bounding box
        function lineSegmentIntersectsBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            // Cohen-Sutherland line clipping algorithm
            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;

                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;

                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    break;
                } else {
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }

            return accept;
        }

        // Parse CSV file
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    csvRoadsData = parseCSV(csvContent);

                    if (csvRoadsData.length === 0) {
                        showStatus('No valid roads found in CSV file', 'error');
                        return;
                    }

                    document.getElementById('csvInputLabel').textContent = file.name;
                    document.getElementById('processCSVBtn').disabled = false;
                    showStatus(`Loaded ${csvRoadsData.length} roads from CSV`, 'success');

                } catch (error) {
                    showStatus(`Error parsing CSV: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Parse CSV content
        function parseCSV(csvContent) {
            const roads = [];
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                throw new Error('CSV file must have at least a header and one data row');
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

            // Validate required columns
            const requiredColumns = ['\"id\"', '\"tags\"', '\"geometry_wkt\"'];
            for (const col of requiredColumns) {
                if (!headers.includes(col)) {
                    throw new Error(`Missing required column: ${col}`);
                }
            }

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = parseCSVLine(line);

                if (values.length < headers.length) {
                    console.warn(`Skipping line ${i}: insufficient columns`);
                    continue;
                }

                const road = {
                    id: values[headers.indexOf('\"id\"')],
                    tags: values[headers.indexOf('\"tags\"')] || '{}',
                    geometry: values[headers.indexOf('\"geometry_wkt\"')] || ''
                };
                let tmp = {...road};
                // Parse tags JSON and convert to key-value pairs
                try {
                    parseTags(road);
                } catch (error) {
                    console.warn(`Error parsing tags for road ${road.id}:`, error);
                    road.tagsParsed = {};
                }

                // Parse WKT geometry
                const coords = parseWKTGeometry(road.geometry);
                if (coords && coords.length >= 2) {
                    road.coordinates = coords;
                    roads.push(road);
                } else {
                    //console.log(JSON.stringify(road));
                    console.warn(`Skipping road ${road.id} - invalid geometry (${JSON.stringify(tmp)})`);
                }
            }

            return roads;
        }

        // Parse tags JSON string to key-value object
        function parseTags(road) {
            tagsString = road.tags;
            if (!tagsString || tagsString.trim() === '') {
                return {};
            }

            try {
                // Remove any surrounding quotes and parse JSON
                let cleanTags = tagsString.trim();
                if (cleanTags.startsWith('"') && cleanTags.endsWith('"')) {
                    cleanTags = cleanTags.slice(1, -1);
                }
                if (cleanTags.startsWith("'") && cleanTags.endsWith("'")) {
                    cleanTags = cleanTags.slice(1, -1);
                }

                // Replace single quotes with double quotes for JSON parsing
                cleanTags = cleanTags.replace(/'/g, '"');
                cleanTags = cleanTags.replace('{', '')
                cleanTags = cleanTags.replace('}', '')
                // Parse the JSON

                tags = cleanTags.split(", ");
                for (let pair of tags){
                    if (pair.includes('=')){
                        p = pair.split("=");
                        if (p[0] == 'geometry' || p[0] == 'id' || p[0] == 'tags'){
                            continue;
                        }
                        road[p[0]] = p[1];
                    }
                }
            } catch (error) {
                // If JSON parsing fails, try to extract key-value pairs manually
                console.warn('JSON parsing failed, trying manual extraction:', error);
            }
        }

        // Extract key-value pairs from a string
        function extractKeyValuePairs(str) {
            const result = {};
            const pairs = str.match(/(\w+)\s*:\s*("[^"]*"|[^,}\s]+)/g);

            if (pairs) {
                pairs.forEach(pair => {
                    const [key, value] = pair.split(':').map(s => s.trim());
                    const cleanValue = value.replace(/^["']|["']$/g, '');
                    result[key] = cleanValue;
                });
            }

            return result;
        }


        // Simple CSV line parser
        function parseCSVLine(line) {
            const values = [];
            let currentValue = '';
            let insideQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"' && !insideQuotes) {
                    insideQuotes = true;
                } else if (char === '"' && insideQuotes) {
                    if (nextChar === '"') {
                        currentValue += '"';
                        i++; // Skip next quote
                    } else {
                        insideQuotes = false;
                    }
                } else if (char === ',' && !insideQuotes) {
                    values.push(currentValue);
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }

            values.push(currentValue);
            return values;
        }

        // Parse WKT geometry string
        function parseWKTGeometry(wkt) {
            if (!wkt) return null;

            // Handle LINESTRING WKT format
            if (wkt.toUpperCase().startsWith('LINESTRING')) {
                // Remove LINESTRING( and )
                const coordsStr = wkt.replace(/LINESTRING\s*\(/i, '').replace(/\)$/, '');
                const coordPairs = coordsStr.split(',');
                return coordPairs.map(pair => {
                    const coords = pair.trim().split(/\s+/);
                    if (coords.length >= 2) {
                        return [parseFloat(coords[0]), parseFloat(coords[1])]; // [lng, lat]
                    }
                    return null;
                }).filter(coord => coord !== null);
            }

            return null;
        }

        // Process CSV roads and assign to quadkeys/countries
        document.getElementById('processCSVBtn').addEventListener('click', async function() {
            if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
                showStatus('Please calculate quadkeys from a route first', 'error');
                return;
            }

            if (csvRoadsData.length === 0) {
                showStatus('Please upload a CSV file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Processing CSV roads and assigning to quadkeys...', 'info');

            try {
                processedRoadsGeoJSON = await processRoadsCSV(csvRoadsData, currentZoomLevel);
                document.getElementById('downloadCSVResultsBtn').disabled = false;
                showStatus(`Processed ${csvRoadsData.length} roads and assigned them to quadkeys`, 'success');

            } catch (error) {
                showStatus(`Error processing CSV: ${error.message}`, 'error');
                console.error(error);
            } finally {
                setLoading(false);
            }
        });

        // Clip a line segment to bounds (returns the portion of segment inside bounds)
        function clipSegmentToBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            // Cohen-Sutherland line clipping algorithm
            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;

                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;

                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    // Both points inside - accept the whole segment
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    // Both points outside on same side - reject
                    break;
                } else {
                    // Some part is inside - clip
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        // Point is above the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        // Point is below the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        // Point is to the right of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        // Point is to the left of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }

            if (accept) {
                return [[x1, y1], [x2, y2]];
            }
            return null;
        }

        // Calculate intersection length between a complete line and a quadkey bounds
        function calculateIntersectionLength(lineCoordinates, quadkeyBounds) {
            // Check if any part of the line intersects with the bounds
            let totalIntersectionLength = 0;

            for (let i = 1; i < lineCoordinates.length; i++) {
                const segmentStart = lineCoordinates[i - 1];
                const segmentEnd = lineCoordinates[i];

                // Check if this segment intersects with bounds
                if (lineSegmentIntersectsBounds(segmentStart, segmentEnd, quadkeyBounds)) {
                    // Calculate the clipped segment length
                    const clippedSegment = clipSegmentToBounds(segmentStart, segmentEnd, quadkeyBounds);
                    if (clippedSegment) {
                        const [lon1, lat1] = clippedSegment[0];
                        const [lon2, lat2] = clippedSegment[1];

                        // Calculate distance
                        const R = 6371000;
                        const φ1 = lat1 * Math.PI / 180;
                        const φ2 = lat2 * Math.PI / 180;
                        const Δφ = (lat2 - lat1) * Math.PI / 180;
                        const Δλ = (lon2 - lon1) * Math.PI / 180;

                        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                                 Math.cos(φ1) * Math.cos(φ2) *
                                 Math.sin(Δλ/2) * Math.sin(Δλ/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                        totalIntersectionLength += R * c;
                    }
                }
            }

            return totalIntersectionLength;
        }

        // Process CSV roads and create GeoJSON organized by country/quadkey - KEEP ROADS INTACT
        async function processRoadsCSV(roads, zoomLevel) {
            // Create a map of quadkey to countries for faster lookup
            const quadkeyToCountries = new Map();
            for (const [quadkey, countries] of quadkeyCountriesMap.entries()) {
                quadkeyToCountries.set(quadkey, Array.from(countries));
            }

            // Get all quadkey bounds for intersection calculations
            const quadkeyBounds = new Map();
            for (const quadkey of quadkeyToCountries.keys()) {
                quadkeyBounds.set(quadkey, quadkeyToBounds(quadkey));
            }

            // Create GeoJSON structure organized by country and quadkey
            const geoJSONByCountryQuadkey = {};

            let assignedCount = 0;
            let totalRoads = roads.length;

            for (let roadIndex = 0; roadIndex < roads.length; roadIndex++) {
                const road = roads[roadIndex];
                if (!road.coordinates || road.coordinates.length < 2) continue;

                // Find all quadkeys this road intersects with
                const intersectingQuadkeys = new Map(); // quadkey -> intersection length

                for (const [quadkey, bounds] of quadkeyBounds.entries()) {
                    // Check if road intersects with this quadkey
                    if (lineStringIntersectsBounds(road.coordinates, bounds)) {
                        // Calculate intersection length
                        const intersectionLength = calculateIntersectionLength(road.coordinates, bounds);
                        if (intersectionLength > 0) {
                            intersectingQuadkeys.set(quadkey, intersectionLength);
                        }
                    }
                }

                // If road intersects with any quadkey, assign it to the one with largest intersection
                if (intersectingQuadkeys.size > 0) {
                    // Find quadkey with maximum intersection length
                    let bestQuadkey = null;
                    let maxLength = 0;

                    for (const [quadkey, length] of intersectingQuadkeys.entries()) {
                        if (length > maxLength) {
                            maxLength = length;
                            bestQuadkey = quadkey;
                        }
                    }

                    if (bestQuadkey) {
                        const countries = quadkeyToCountries.get(bestQuadkey);
                        if (countries && countries.length > 0) {
                            assignedCount++;

                            // Add to each country's GeoJSON (for border quadkeys, road goes to all countries)
                            for (const country of countries) {
                                if (!geoJSONByCountryQuadkey[country]) {
                                    geoJSONByCountryQuadkey[country] = {};
                                }

                                if (!geoJSONByCountryQuadkey[country][bestQuadkey]) {
                                    geoJSONByCountryQuadkey[country][bestQuadkey] = {
                                        type: 'FeatureCollection',
                                        features: []
                                    };
                                }

                                // Create road feature with COMPLETE ORIGINAL GEOMETRY - NO SPLITTING
                                const feature = {
                                    type: 'Feature',
                                    properties: road,
                                    geometry: {
                                        type: 'LineString',
                                        coordinates: road.coordinates // Keep the original complete geometry
                                    }
                                };

                                geoJSONByCountryQuadkey[country][bestQuadkey].features.push(feature);
                            }
                        }
                    }
                }
                // Allow UI to update
                if (roadIndex % 10 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            console.log(geoJSONByCountryQuadkey);
            showStatus(`Assigned ${assignedCount} roads to quadkeys (${roads.length - assignedCount} not assigned)`, 'success');

            return geoJSONByCountryQuadkey;
        }

        // Download processed roads GeoJSON
        document.getElementById('downloadCSVResultsBtn').addEventListener('click', function() {
            if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
                showStatus('No processed roads data available', 'error');
                return;
            }

            // Create a zip file with organized GeoJSON files
            const zip = new JSZip();

            for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
                const countryFolder = zip.folder(country);

                for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                    if (geojson.features.length > 0) {
                        const fileName = `${quadkey}.geojson`;
                        countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                    }
                }
            }

            // Generate and download zip file
            zip.generateAsync({ type: 'blob' }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roads_by_country_quadkey.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('Downloaded roads organized by country/quadkey');
                showStatus(`Downloaded roads organized by country/quadkey`, 'success');
            });
        });

        // Load JSZip library dynamically
        function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (typeof JSZip !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // Initialize JSZip when needed
        document.getElementById('downloadCSVResultsBtn').addEventListener('click', async function(e) {
            e.preventDefault();

            try {
                await loadJSZip();
                // Now call the actual download function
                downloadCSVResults();
            } catch (error) {
                showStatus('Error loading JSZip library: ' + error.message, 'error');
            }
        });

        // Updated download function that uses JSZip
        async function downloadCSVResults() {
            if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
                showStatus('No processed roads data available', 'error');
                return;
            }

            const zip = new JSZip();
            let fileCount = 0;

            for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
                const countryFolder = zip.folder(country);

                for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                    if (geojson.features.length > 0) {
                        const fileName = `${quadkey}.geojson`;
                        countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                        fileCount++;
                    }
                }
            }

            // Generate and download zip file
            zip.generateAsync({ type: 'blob' }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = `roads_by_country_quadkey.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showStatus(`Downloaded ${fileCount} GeoJSON files organized by country/quadkey`, 'success');
            });
        }

        // Parse uploaded JSON file
        document.getElementById('routeFile').addEventListener('change', function(e) {
            currentCountryQuadkeys = null;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.routes || !Array.isArray(data.routes)) {
                        throw new Error('Invalid route file format. Expected "routes" array.');
                    }

                    currentRouteData = data;
                    countryCache = {}; // Clear cache for new file

                    document.getElementById('fileInputLabel').textContent = file.name;

                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '';

                    data.routes.forEach((route, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Route ${index + 1}`;
                        routeSelect.appendChild(option);
                    });

                    document.getElementById('routeSelectorContainer').style.display = 'block';
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('downloadRouteBtn').disabled = false;
                    document.getElementById('copyWktBtn').disabled = false;
                    document.getElementById('addQuadkeyModeBtn').disabled = false;
                    document.getElementById('removeQuadkeyModeBtn').disabled = false;

                    loadRoute(0);

                    showStatus('Route file loaded successfully!', 'success');
                } catch (error) {
                    showStatus(`Error parsing JSON: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Handle route selection change
        document.getElementById('routeSelect').addEventListener('change', function(e) {
            const routeIndex = parseInt(e.target.value);
            loadRoute(routeIndex);
        });

        // Download route as GeoJSON before processing
        document.getElementById('downloadRouteBtn').addEventListener('click', function() {
            if (!currentRouteData) return;

            const route = currentRouteData.routes[currentRouteIndex];
            const features = [];

            // Create route feature from all coordinates
            const allCoords = [];
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`,
                    distance: document.getElementById('routeDetails').textContent.split(',')[0].replace('Distance: ', ''),
                    waypoints: document.getElementById('routeDetails').textContent.split(',')[1].replace(' Waypoints: ', ''),
                    legs: route.legs.length
                }
            };

            features.push(routeFeature);

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_${currentRouteIndex}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('Route GeoJSON downloaded!', 'success');
        });

        // Add Quadkey Mode
        document.getElementById('addQuadkeyModeBtn').addEventListener('click', function() {
            addQuadkeyMode = !addQuadkeyMode;
            removeQuadkeyMode = false;

            if (addQuadkeyMode) {
                this.style.backgroundColor = '#28a745';
                document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
                showStatus('Add Quadkey Mode: Click on map to add quadkeys', 'info');
            } else {
                this.style.backgroundColor = '';
                showStatus('Add Quadkey Mode disabled', 'info');
            }
        });

        // Remove Quadkey Mode
        document.getElementById('removeQuadkeyModeBtn').addEventListener('click', function(e) {
            removeQuadkeyMode = !removeQuadkeyMode;
            addQuadkeyMode = false;
            console.log("Remove qk button clicked")
            if (removeQuadkeyMode) {
                this.style.backgroundColor = '#dc3545';
                document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
                showStatus('Remove Quadkey Mode: Click on map to remove quadkeys', 'info');
            } else {
                this.style.backgroundColor = '';
                showStatus('Remove Quadkey Mode disabled', 'info');
            }
        });

        // Load a specific route onto the map
        function loadRoute(routeIndex) {
            if (!currentRouteData || !currentRouteData.routes[routeIndex]) {
                showStatus('Invalid route selected', 'error');
                return;
            }

            currentRouteIndex = routeIndex;
            const route = currentRouteData.routes[routeIndex];

            if (routeLayer) {
                map.removeLayer(routeLayer);
            }

            const allCoords = [];
            let totalDistance = 0;
            let waypointCount = 0;

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    const geom = step.geometry;
                    if (geom.type === 'LineString' && geom.coordinates) {
                        const latLngs = geom.coordinates.map(coord => [coord[1], coord[0]]);
                        allCoords.push(...latLngs);

                        if (latLngs.length > 1) {
                            for (let i = 1; i < latLngs.length; i++) {
                                totalDistance += calculateDistance(latLngs[i-1], latLngs[i]);
                            }
                        }

                        waypointCount += latLngs.length;
                    }
                });
            });

            routeLayer = L.polyline(allCoords, {
                color: '#3498db',
                weight: 4,
                opacity: 0.7,
                smoothFactor: 1
            }).addTo(map);

            map.fitBounds(routeLayer.getBounds());

            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('routeDetails').textContent =
                `Distance: ${(totalDistance / 1000).toFixed(2)} km, Waypoints: ${waypointCount}, Legs: ${route.legs.length}`;

            clearQuadkeyLayers();
            document.getElementById('resultsOutput').textContent =
                'No results yet. Click "Calculate Quadkeys" to process this route.';
            document.getElementById('copyResultsBtn').disabled = true;
            document.getElementById('copySqlResultsBtn').disabled = true;
            document.getElementById('downloadGeoJSONBtn').disabled = true;
            document.getElementById('statsInfo').style.display = 'none';
            document.getElementById('countryControlsContainer').style.display = 'none';
            document.getElementById('copyWktBtn').style.display = 'block';
            // Reset modes
            addQuadkeyMode = false;
            removeQuadkeyMode = false;
            document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
            document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
        }

        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371e3;
            const φ1 = coord1[0] * Math.PI / 180;
            const φ2 = coord2[0] * Math.PI / 180;
            const Δφ = (coord2[0] - coord1[0]) * Math.PI / 180;
            const Δλ = (coord2[1] - coord1[1]) * Math.PI / 180;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Process route to calculate quadkeys - USING BOUNDING BOX APPROACH
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!currentRouteData) {
                showStatus('Please upload a route file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Calculating quadkeys using bounding box approach...', 'info');

            try {
                const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
                currentZoomLevel = zoomLevel;
                const route = currentRouteData.routes[currentRouteIndex];

                const startTime = Date.now();
                var { countryQuadkeys, stats, quadkeyCountries } = await getRouteQuadkeysWithCountriesBBox(
                    route,
                    zoomLevel
                );
                const processingTime = (Date.now() - startTime) / 1000;

                currentCountryQuadkeys = countryQuadkeys;
                quadkeyCountriesMap = quadkeyCountries;
                originalStats = stats;

                // Initialize all countries as enabled
                countryControlsState = {};
                countryBorderExclusions.clear();
                Object.keys(countryQuadkeys).forEach(country => {
                    countryControlsState[country] = true;
                });

                createCountryControls(countryQuadkeys, false);
                updateDisplayAndVisualization();

                // Show statistics
                document.getElementById('statsInfo').style.display = 'block';
                document.getElementById('statsDetails').textContent =
                    `Found ${stats.totalQuadkeys} quadkeys, ${stats.borderQuadkeys} border quadkeys in ${processingTime.toFixed(1)}s`;

                showStatus(`Found ${stats.totalQuadkeys} quadkeys across ${Object.keys(countryQuadkeys).length} countries`, 'success');

                document.getElementById('downloadGeoJSONBtn').disabled = false;
                document.getElementById('copyResultsBtn').disabled = false;
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`Error calculating quadkeys: ${error.message}`, 'error');
                    console.error(error);
                }
            } finally {
                setLoading(false);
            }
        });

        // Get quadkeys for a route using bounding box approach
        async function getRouteQuadkeysWithCountriesBBox(route, zoom) {
            var stats = {
                totalQuadkeys: 0,
                borderQuadkeys: 0
            };

            // Extract all coordinates and create line strings
            const allLineStrings = [];
            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allLineStrings.push(step.geometry.coordinates);
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No valid coordinates found in route');
            }

            // Get the bounding box of the entire route
            const lats = allCoords.map(coord => coord[1]);
            const lngs = allCoords.map(coord => coord[0]);

            const minLon = Math.min(...lngs);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lngs);
            const maxLat = Math.max(...lats);

            showStatus(`Route bounds: ${minLon.toFixed(4)}, ${minLat.toFixed(4)} to ${maxLon.toFixed(4)}, ${maxLat.toFixed(4)}`, 'info');

            // Get all tiles in the bounding box
            const tiles = getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom);
            showStatus(`Checking ${tiles.length} tiles for intersection...`, 'info');

            const quadkeyCountries = new Map();

            // Check which tiles intersect with the route
            for (let i = 0; i < tiles.length; i++) {
                if (processingController?.signal.aborted) {
                    throw new DOMException('Aborted', 'AbortError');
                }

                const tile = tiles[i];
                const quadkey = toQuadkey(tile.x, tile.y, zoom);
                const tileBounds = tileToBounds(tile);

                // Check if any line string intersects with this tile
                let intersects = false;
                for (const lineString of allLineStrings) {
                    if (lineStringIntersectsBounds(lineString, tileBounds)) {
                        intersects = true;
                        break;
                    }
                }

                if (intersects) {
                    // Get countries for this quadkey
                    const countries = await getQuadkeyCountries(quadkey);

                    if (countries.length > 1) {
                        stats.borderQuadkeys++;
                    }

                    quadkeyCountries.set(quadkey, new Set(countries));

                    if (i % 10 === 0) {
                        showStatus(`Processing tiles... ${Math.round((i / tiles.length) * 100)}%`, 'info');
                    }
                }
            }

            stats.totalQuadkeys = quadkeyCountries.size;

            // Convert to country->quadkeys mapping
            const countryQuadkeys = {};
            for (const [quadkey, countries] of quadkeyCountries.entries()) {
                for (const country of countries) {
                    if (!countryQuadkeys[country]) {
                        countryQuadkeys[country] = new Set();
                    }
                    countryQuadkeys[country].add(quadkey);
                }
            }

            // Convert Sets to Arrays and sort
            const result = {};
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                result[country] = Array.from(quadkeys).sort();
            }

            return {
                countryQuadkeys: result,
                stats,
                quadkeyCountries: quadkeyCountries
            };
        }

        // Create country controls UI
        function createCountryControls(countryQuadkeys, qkManipulationEvent) {
            const container = document.getElementById('countryControls');
            container.innerHTML = '';

            const sortedCountries = Object.keys(countryQuadkeys).sort();

            sortedCountries.forEach(country => {
                const quadkeys = countryQuadkeys[country];
                const count = quadkeys.length;

                const controlDiv = document.createElement('div');
                controlDiv.className = 'country-control';
                check = 'checked'
                if (qkManipulationEvent){
                    check = countryControlsState[country] ? 'checked' : 'unchecked';
                }
                check =
                controlDiv.innerHTML = `
                    <input type="checkbox" class="country-checkbox" id="chk-${country}" ${check}>
                    <div class="country-label">
                        <span class="country-name">${country}</span>
                        <span class="country-count">${count}</span>
                    </div>
                    <button class="border-control" data-country="${country}" title="Exclude border quadkeys for ${country}">No Borders</button>
                `;

                container.appendChild(controlDiv);

                // Add event listener for checkbox
                const checkbox = controlDiv.querySelector('.country-checkbox');
                checkbox.addEventListener('change', function() {
                    countryControlsState[country] = this.checked;
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });

                // Add event listener for border control
                const borderBtn = controlDiv.querySelector('.border-control');
                borderBtn.addEventListener('click', function() {
                    const country = this.getAttribute('data-country');
                    if (countryBorderExclusions.has(country)) {
                        countryBorderExclusions.delete(country);
                        this.classList.remove('excluded');
                        this.textContent = 'No Borders';
                    } else {
                        countryBorderExclusions.add(country);
                        this.classList.add('excluded');
                        this.textContent = 'With Borders';
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });
            });
        }

        // Update display and visualization based on current filters
        function updateDisplayAndVisualization() {
            if (!currentCountryQuadkeys) return;

            // Filter quadkeys based on country controls and border exclusions
            const filteredCountryQuadkeys = {};

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (countryControlsState[country]) {
                    let filteredQuadkeys = [...quadkeys];

                    // Apply border exclusion if enabled for this country
                    if (countryBorderExclusions.has(country)) {
                        filteredQuadkeys = filteredQuadkeys.filter(quadkey => {
                            const countries = quadkeyCountriesMap.get(quadkey);
                            return countries && countries.size === 1 && countries.has(country);
                        });
                    }

                    if (filteredQuadkeys.length > 0) {
                        filteredCountryQuadkeys[country] = filteredQuadkeys;
                    }
                }
            }

            displayResults(filteredCountryQuadkeys);
            visualizeQuadkeys(filteredCountryQuadkeys, currentZoomLevel);
        }

        // Select all countries
        document.getElementById('selectAllBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = true;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = true;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Select none countries
        document.getElementById('selectNoneBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = false;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = false;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Get all tiles in a bounding box
        function getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom) {
            const tiles = [];

            const topLeft = [maxLat, minLon];
            const bottomRight = [minLat, maxLon];

            const topLeftTile = tileAtZoom(topLeft[0], topLeft[1], zoom);
            const bottomRightTile = tileAtZoom(bottomRight[0], bottomRight[1], zoom);

            for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {
                for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                    tiles.push({ x, y, z: zoom });
                }
            }

            return tiles;
        }

        // Convert tile to bounds
        function tileToBounds(tile) {
            return calculateTileBounds(tile.x, tile.y, tile.z);
        }

        // Calculate tile bounds (renamed from tileBounds)
        function calculateTileBounds(x, y, z) {
            const n = Math.pow(2, z);
            const west = x / n * 360 - 180;
            const east = (x + 1) / n * 360 - 180;
            const north = (Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI);
            const south = (Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI);

            return { west, south, east, north };
        }

        // Calculate tile coordinates for given lat/lng and zoom
        function tileAtZoom(lat, lng, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);

            return { x, y, z: zoom };
        }

        // Convert tile coordinates to quadkey
        function toQuadkey(x, y, z) {
            let quadkey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);

                if ((x & mask) !== 0) {
                    digit += 1;
                }

                if ((y & mask) !== 0) {
                    digit += 2;
                }

                quadkey += digit.toString();
            }
            return quadkey;
        }

        // Convert quadkey to bounding box
        function quadkeyToBounds(quadkey) {
            let x = 0, y = 0;
            const z = quadkey.length;

            for (let i = z; i > 0; i--) {
                const mask = 1 << (i - 1);
                const q = parseInt(quadkey[z - i]);

                if (q & 1) x |= mask;
                if (q & 2) y |= mask;
            }

            return calculateTileBounds(x, y, z);
        }

        function getQkStringifyArray(qk_array){
            qks = "";
            for (let item of qk_array){
                qks+=`'${item}',`
            }
            return qks.slice(0, -1);
        }

        // Display results with proper line breaks between countries
        function displayResults(countryQuadkeys) {
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            let output = '';
            let countries_str = '';
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            let strFormattedDate = `'${formattedDate}'`
            quadkeysByZoom = {};
            cardinalityCondition = '(';
            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];
                for (let qk of quadkeys){
                    zoomLevel = qk.length;
                    if (zoomLevel in quadkeysByZoom){
                        quadkeysByZoom[zoomLevel].push(qk);
                    }
                    else{
                        quadkeysByZoom[zoomLevel] = [qk]
                    }
                }
                const count = quadkeys.length;
                countries_str+=`'${country}',`
                output += `${country}: ${count} quadkeys\n`;
                output += quadkeys.join(',') + '\n\n';
            }
            countries_str = countries_str.slice(0, -1);
            for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
                let quads = getQkStringifyArray(qks);
                cardinalityCondition+=`cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
            }
            cardinalityCondition = cardinalityCondition.slice(0, -4);
            cardinalityCondition+=')';
            query = `select id, tags, geometry_wkt
                from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
                where dt = ${strFormattedDate}
                and metadata_str['iso:3166_1'] in (${countries_str})
                and ${cardinalityCondition}
                and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`
            document.getElementById('resultsOutput').textContent = output.trim() || 'No quadkeys found for this route.';
        }

        // Visualize quadkeys on the map with special coloring for border quadkeys
        function visualizeQuadkeys(countryQuadkeys, zoom) {
            clearQuadkeyLayers();

            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
            ];

            let colorIndex = 0;
            const countryColors = {};
            const quadkeyCountries = new Map();

            // First pass: count how many countries each quadkey belongs to
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                for (const quadkey of quadkeys) {
                    if (!quadkeyCountries.has(quadkey)) {
                        quadkeyCountries.set(quadkey, new Set());
                    }
                    quadkeyCountries.get(quadkey).add(country);
                }
            }

            // Second pass: visualize with appropriate colors
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                if (!countryColors[country]) {
                    countryColors[country] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const baseColor = countryColors[country];

                for (const quadkey of quadkeys) {
                    const bounds = quadkeyToBounds(quadkey);
                    const countriesForQuadkey = quadkeyCountries.get(quadkey);

                    // Determine color: border quadkeys get special treatment
                    let color, fillOpacity;
                    if (countriesForQuadkey.size > 1) {
                        // Border quadkey - use yellow for visibility
                        color = '#ffeb3b';
                        fillOpacity = 0.3;
                    } else {
                        // Single country quadkey
                        color = baseColor;
                        fillOpacity = 0.3;
                    }

                    const polygon = L.rectangle(
                        [[bounds.south, bounds.west], [bounds.north, bounds.east]],
                        {
                            color: color,
                            weight: 2,
                            fillColor: color,
                            fillOpacity: fillOpacity
                        }
                    ).addTo(map);

                    // Add click event to toggle quadkey visibility
                    polygon.on('click', function(e) {
                        L.DomEvent.stopPropagation(e);

                        if (removeQuadkeyMode) {
                            const clickedQuadkey = quadkey; // You'll need to capture this in closure
                            const countries = Array.from(quadkeyCountriesMap.get(clickedQuadkey) || []);

                            if (countries.length > 1) {
                                showCountrySelectionModal(clickedQuadkey, countries, 'remove');
                            } else {
                                removeQuadkey(clickedQuadkey, countries);
                                updateDisplayAndVisualization();
                                recalculateStatistics();
                                createCountryControls(currentCountryQuadkeys, true);
                            }
                        }
                        else{
                            navigator.clipboard.writeText(quadkey).then(() => {
                                showStatus('Quadkey copied to clipboard!', 'success');
                            }).catch(err => {
                                console.error('Copy failed:', err);
                            });
                        }
                    });

                    const countryList = Array.from(countriesForQuadkey).join(', ');
                    polygon.bindTooltip(
                        `Countries: ${countryList}<br>Quadkey: ${quadkey}`,
                        { permanent: false, direction: 'center' }
                    );

                    if (!quadkeyLayers[country]) {
                        quadkeyLayers[country] = [];
                    }
                    quadkeyLayers[country].push(polygon);
                }
            }
        }

        // Clear quadkey layers from the map
        function clearQuadkeyLayers() {
            for (const country in quadkeyLayers) {
                quadkeyLayers[country].forEach(layer => {
                    map.removeLayer(layer);
                });
            }
            quadkeyLayers = {};
        }

        // Copy results to clipboard
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsText = document.getElementById('resultsOutput').textContent;

            navigator.clipboard.writeText(resultsText).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });

        // Copy SQL results to clipboard
        document.getElementById('copySqlResultsBtn').addEventListener('click', function() {
            navigator.clipboard.writeText(query).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });

        // Download GeoJSON with quadkeys
        document.getElementById('downloadGeoJSONBtn').addEventListener('click', function() {
            if (!currentRouteData) return;

            const route = currentRouteData.routes[currentRouteIndex];
            const features = [];

            // Create route feature
            const allCoords = [];
            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`,
                    type: 'route'
                }
            };

            features.push(routeFeature);

            // Create quadkey features
            const resultsText = document.getElementById('resultsOutput').textContent;
            const lines = resultsText.split('\n');
            let currentCountry = null;

            for (const line of lines) {
                if (line.includes(':')) {
                    const parts = line.split(':');
                    if (parts.length === 2 && parts[1].includes('quadkeys')) {
                        currentCountry = parts[0].trim();
                    }
                } else if (line.trim() && currentCountry && line.includes(',')) {
                    const quadkeys = line.split(',').map(q => q.trim()).filter(q => q);
                    for (const quadkey of quadkeys) {
                        const bounds = quadkeyToBounds(quadkey);

                        const polygonCoords = [
                            [bounds.west, bounds.north],
                            [bounds.east, bounds.north],
                            [bounds.east, bounds.south],
                            [bounds.west, bounds.south],
                            [bounds.west, bounds.north]
                        ];

                        const quadkeyFeature = {
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: [polygonCoords]
                            },
                            properties: {
                                quadkey: quadkey,
                                country: currentCountry
                            }
                        };

                        features.push(quadkeyFeature);
                    }
                }
            }

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `route_quadkeys_${currentRouteIndex}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus('Results GeoJSON downloaded!', 'success');
        });

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            showStatus('Ready to process routes. Upload a JSON file to get started.', 'info');
        });
    </script>
    <!-- Load JSZip library for zip file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</body>
</html>