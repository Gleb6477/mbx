<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadkey Processor</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css" type="text/css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 10px 10px 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .left-panel {
                max-width: 100%;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            width: 400px;
            min-width: 400px;
        }

        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-label:hover {
            background-color: #e9ecef;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .results-container {
            margin-top: 20px;
            overflow-x: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-title {
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .results-content {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            max-width: 920px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            overflow: scroll;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .controls button {
            flex: 1;
        }

        .secondary-btn {
            background-color: #6c757d;
        }

        .secondary-btn:hover {
            background-color: #5a6268;
        }

        .success-btn {
            background-color: #28a745;
        }

        .success-btn:hover {
            background-color: #218838;
        }

        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .route-info p {
            margin-bottom: 5px;
        }

        .route-selector {
            margin-bottom: 15px;
        }

        .performance-info {
            background: #e8f4fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .stats-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .route-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-controls button {
            flex: 1;
        }

        /* New styles for country controls */
        .country-controls {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        .country-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .country-control:hover {
            background-color: #e9ecef;
        }

        .country-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .country-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .country-name {
            font-weight: 600;
        }

        .country-count {
            background-color: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .border-control {
            margin-left: 10px;
            font-size: 0.8rem;
            color: #6c757d;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #6c757d;
        }

        .border-control:hover {
            background-color: #6c757d;
            color: white;
        }

        .border-control.excluded {
            background-color: #6c757d;
            color: white;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            margin-top: 30px;
        }

        .select-all-buttons {
            display: flex;
            gap: 5px;
        }

        .select-all-buttons button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .map-controls button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* New styles for CSV upload and processing */
        .csv-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .tab-container {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #eaeaea;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            color: #666;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .csv-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a6ee0;
        }

        .csv-processing-btn {
            background: linear-gradient(135deg, #4a6ee0, #764ba2);
        }

        .csv-processing-btn:hover {
            background: linear-gradient(135deg, #3a5ecf, #663aa2);
        }

        .csv-download-btn {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            margin-top: 10px;
        }

        .csv-download-btn:hover {
            background: linear-gradient(135deg, #009985, #85b92d);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .country-selection-item {
            display: flex;
            margin: 10px 0;
            padding: 4px 4px 0px 130px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .country-selection-item input {
            margin-right: 10px;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #confirmSelection {
            background-color: #28a745;
            color: white;
        }

        #cancelSelection {
            background-color: #6c757d;
            color: white;
        }

        .processing-mode-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
        }

        .nested-options {
            margin-top: 10px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .option-description {
            font-size: 0.9rem;
            color: #495057;
        }

        .option-description p {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .option-description p:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #3498db;
        }

        .processing-mode-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        /* Mapbox GL specific styles */
        .mapboxgl-popup {
            max-width: 300px;
        }

        .mapboxgl-popup-content {
            padding: 15px;
            border-radius: 5px;
        }

        .quadkey-highlight {
            fill-opacity: 0.2;
            stroke-width: 2;
        }

        .pulse-marker {
            background: transparent;
            border: none;
        }

        .pulse-dot {
            width: 20px;
            height: 20px;
            background-color: #ff0000;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 0 0 rgba(255, 0, 0, 1);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        #statsResults {
            max-height: 500px;
            overflow-y: auto;
        }

        #statsResults pre {
            font-size: 12px;
            max-height: 300px;
        }

        .btn {
            margin-right: 5px;
            margin-bottom: 5px;
        }

        .card {
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Quadkey Processor</h1>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <div class="tab-container">
                    <button class="tab active" data-tab="preferences">Settings</button>
                    <button class="tab" data-tab="route">Route</button>
                    <button class="tab" data-tab="admin">Admin</button>
                    <button class="tab" data-tab="csv">CSV</button>
                </div>

                <div id="preferences-tab" class="tab-content active">
                    <div class="input-group">
                        <label for="searchQuadkey">Quadkey Search (comma-separated for multiple)</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="searchQuadkey" placeholder="Enter quadkeys">
                            <button id="searchQuadkeyBtn" class="secondary-btn">Search & Zoom</button>
                        </div>
                        <div id="searchResult" style="margin-top: 5px; font-size: 0.9rem; color: #666;"></div>
                        <div id="searchActions" style="margin-top: 10px; display: none;">
                            <button id="addSearchedQuadkeysBtn" class="secondary-btn" style="margin-right: 10px;margin-bottom: 10px">Add All to Results</button>
                            <button id="removeSearchedQuadkeysBtn" class="secondary-btn">Remove All from Results</button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="zoomLevel">Zoom Level (for Quadkey Calculation)</label>
                        <input type="number" id="zoomLevel" min="1" max="18" value="12">
                    </div>

                    <div class="input-group">
                        <label for="processingMode">Attribute</label>
                        <div id="processingModeContainer">
                            <select id="processingMode" class="processing-mode-select">
                                <option value="speed_limits">Speed Limits</option>
                                <option value="oneways">Oneways</option>
                                <option value="here_oneways">HERE Oneways</option>
                            </select>
                        </div>
                    </div>

                    <div class="map-controls">
                        <button id="addQuadkeyModeBtn" class="secondary-btn">Add Quadkey Mode</button>
                        <button id="removeQuadkeyModeBtn" class="secondary-btn">Remove Quadkey Mode</button>
                    </div>
                </div>

                <!-- Route Processor Tab -->
                <div id="route-tab" class="tab-content">

                    <div class="input-group">
                        <label for="routeFile">Upload Route JSON File</label>
                        <div class="file-input-container">
                            <input type="file" id="routeFile" class="file-input" accept=".json">
                            <label for="routeFile" class="file-input-label" id="fileInputLabel">Choose a JSON file</label>
                        </div>
                    </div>

                    <div class="input-group route-selector" id="routeSelectorContainer" style="display: none;">
                        <label for="routeSelect">Select Route</label>
                        <select id="routeSelect"></select>
                    </div>

                    <div class="route-controls">
                        <button id="downloadRouteBtn" class="secondary-btn" disabled>Download Route GeoJSON</button>
                        <button id="copyWktBtn" class="secondary-btn" disabled>Copy WKT</button>
                    </div>

                    <div class="controls">
                        <button id="processBtn" disabled>Calculate Quadkeys</button>
                        <button id="downloadGeoJSONBtn" class="secondary-btn" disabled>Download Results GeoJSON</button>
                    </div>

                    <!-- Country Controls Section -->
                    <div id="countryControlsContainer" style="display: none;">
                        <div class="controls-header">
                            <h3 class="panel-title">Country Controls</h3>
                            <div class="select-all-buttons">
                                <button id="selectAllBtn" class="secondary-btn">All</button>
                                <button id="selectNoneBtn" class="secondary-btn">None</button>
                            </div>
                        </div>
                        <div class="country-controls" id="countryControls">
                            <!-- Country controls will be dynamically added here -->
                        </div>
                    </div>
                </div>

<!--                <div class="route-info" id="routeInfo" style="display: none;">-->
<!--                    <p><strong>Route Information</strong></p>-->
<!--                    <p id="routeDetails"></p>-->
<!--                </div>-->
                <div id="admin-tab" class="tab-content">
                    <div class="csv-section">
                        <div class="input-group">
                            <label for="adminLevel">Admin Level</label>
                            <select id="adminLevel">
                                <option value="2">Country (level 2)</option>
                                <option value="4">Region/State (level 4)</option>
                                <option value="6">County (level 6)</option>
                                <option value="8" selected>Municipality (level 8)</option>
                                <option value="9">Local (level 9)</option>
                                <option value="10">Neighborhood (level 10)</option>
                            </select>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="countryFilter">Country Filter (optional)</label>
                        <input type="text" id="countryFilter" placeholder="e.g., Spain, France">
                    </div>

                    <div class="controls">
                        <button id="queryAdminBtn" class="admin-btn">Query Admin Boundaries</button>
                        <button id="clearAdminBtn" class="secondary-btn">Clear Admin</button>
                    </div>

                    <div class="controls">
                        <button id="splitQuadkeysBtn" class="quadkey-btn">Generate Quadkeys from Selected</button>
                    </div>
                </div>
<!--                <div id="adminInfo" class="info-box admin-info" style="display: none;">-->
<!--                    <p><strong>Selected Polygon:</strong> <span id="selectedPolygonName">None</span></p>-->
<!--                    <p><strong>OSM ID:</strong> <span id="selectedPolygonId">-</span></p>-->
<!--                    <p><strong>Admin Level:</strong> <span id="selectedAdminLevel">-</span></p>-->
<!--                    <p><strong>Area Quadkeys:</strong> <span id="quadkeyCount">0</span></p>-->
<!--                </div>-->

                <!-- CSV Upload Section -->
                <div id="csv-tab" class="tab-content">
                    <div class="csv-section">
                        <div class="input-group">
                            <label for="csvFile">Upload Roads CSV File</label>
                            <div class="file-input-container">
                                <input type="file" id="csvFile" class="file-input" accept=".csv">
                                <label for="csvFile" class="file-input-label" id="csvInputLabel">Choose a Roads CSV file</label>
                            </div>
                        </div>

                        <button id="processCSVBtn" class="csv-processing-btn" disabled>Process Roads CSV</button>
                        <button id="downloadCSVResultsBtn" class="csv-download-btn" disabled>Download Roads GeoJSON</button>
                    </div>


                    <div class="csv-section" style="margin-top: 20px;">
                        <h3 class="panel-title">Signs CSV Processing</h3>

                        <div class="input-group">
                            <label for="signsCsvFile">Upload Signs CSV File</label>
                            <div class="file-input-container">
                                <input type="file" id="signsCsvFile" class="file-input" accept=".csv">
                                <label for="signsCsvFile" class="file-input-label" id="signsCsvInputLabel">Choose a Signs CSV file</label>
                            </div>
                        </div>

                        <button id="processSignsCSVBtn" class="csv-processing-btn" disabled>Process Signs CSV</button>
                        <button id="downloadCombinedResultsBtn" class="csv-download-btn" disabled>Download Combined GeoJSON</button>
                    </div>
                </div>
                <div class="status-message" id="statusMessage"></div>

                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing route data...</p>
                </div>
            </div>
            <div class="panel">
                <h2 class="panel-title">Map & Results</h2>

                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="results-container">
                    <div class="results-header">
                        <h3 class="results-title">Quadkeys Results</h3>
                        <div style="display: flex">
                            <button id="copyResultsBtn" class="secondary-btn" style="margin-left:20px" disabled>Copy Results</button>
                            <button id="copySqlResultsBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy roads SQL</button>
                            <button id="copySignsSqlBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy signs SQL</button>
                            <button id="copyStats" class="secondary-btn" style="margin-left:10px">
                                <i class="fas fa-chart-bar"></i> Calculate Statistics
                            </button>
<!--                            <div id="statsResults" class="mt-3"></div>-->
                        </div>
                    </div>
                    <div class="results-content" id="resultsOutput">
                        No results yet. Upload a route file and click "Calculate Quadkeys".
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src='https://unpkg.com'></script>
    <script>
        // Global variables
        let map;
        let currentRouteData = null;
        let currentRouteIndex = 0;
        let countryCache = {};
        let processingController = null;
        let currentCountryQuadkeys = null;
        let quadkeyCountriesMap = new Map();
        let countryControlsState = {};
        let countryBorderExclusions = new Set();
        let addQuadkeyMode = false;
        let removeQuadkeyMode = false;
        let currentZoomLevel = 12;
        let originalStats = null;
        let csvRoadsData = [];
        let processedRoadsGeoJSON = null;
        let query = '';
        let selectedAdminPolygon = []
        const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2NvdHRzZmFybGV5OTMiLCJhIjoiY2o4ODJxNjh4MWVndjJ3cWI5ODRlZ2hnayJ9.w9-dF3jh-GtQzk9h0wBUbw';
        mapboxgl.accessToken = MAPBOX_TOKEN;

        // Admin elements
        const queryAdminBtn = document.getElementById('queryAdminBtn');
        const clearAdminBtn = document.getElementById('clearAdminBtn');
        const splitQuadkeysBtn = document.getElementById('splitQuadkeysBtn');
        const adminInfo = document.getElementById('adminInfo');
        const selectedPolygonName = document.getElementById('selectedPolygonName');
        const selectedPolygonId = document.getElementById('selectedPolygonId');
        const selectedAdminLevel = document.getElementById('selectedAdminLevel');
        const quadkeyCount = document.getElementById('quadkeyCount');

        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        // Map layers management
        let mapLayers = {
            route: 'route-line',
            quadkeys: new Map(),
            searchHighlights: new Map(),
            searchMarkers: []
        };

        // Initialize map
        function initMap() {
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [0, 20],
                zoom: 2,
                attributionControl: false
            });

            // Add navigation controls
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            // Add geocoder
            const geocoder = new MapboxGeocoder({
                accessToken: mapboxgl.accessToken,
                mapboxgl: mapboxgl,
                marker: false,
                placeholder: 'Search',
                countries: '',
                types: 'place,locality,neighborhood,address,region',
                bbox: [-180, -90, 180, 90]
            });

            map.addControl(geocoder, 'top-left');

            // Initialize click handler
            map.on('click', handleMapClick);

            // Initialize geocoder result handler
            geocoder.on('result', function(e) {
                const result = e.result;
            });
        }

        // ==================== TAB MANAGEMENT ====================
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                currentTab = tabId;

                // Update tabs
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update tab contents
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `${tabId}-tab`) {
                        content.classList.add('active');
                    }
                });
            });
        });

        // Function to calculate statistics
<!--async function calculateGeojsonsStatistics() {-->
<!--    const quadKeyStats = {};-->

<!--    // Loop through all processed quadkeys-->
<!--    for (const quadKey of Object.keys(stats)) {-->
<!--        const data = stats[quadKey];-->
<!--        let roadLength = 0;-->
<!--        let signCount = 0;-->

<!--        // Calculate statistics for each feature-->
<!--        data.features.forEach(feature => {-->
<!--            if (feature.properties.layer === 'roads' ||-->
<!--                feature.properties.highway ||-->
<!--                feature.properties.layer === 'road' ||-->
<!--                feature.geometry.type === 'LineString') {-->
<!--                // It's a road-->
<!--                roadLength += calculateLineLength(feature.geometry.coordinates);-->
<!--            } else if (feature.properties.highway === 'traffic_signals' ||-->
<!--                      feature.properties.traffic_sign ||-->
<!--                      feature.properties.layer === 'signs' ||-->
<!--                      feature.geometry.type === 'Point') {-->
<!--                // It's a sign-->
<!--                signCount++;-->
<!--            }-->
<!--        });-->

<!--        quadKeyStats[quadKey] = {-->
<!--            roadLength: roadLength,-->
<!--            signCount: signCount-->
<!--        };-->
<!--    }-->

<!--    // Sort by road length descending-->
<!--    const sortedStats = Object.entries(quadKeyStats)-->
<!--        .sort(([, a], [, b]) => b.roadLength - a.roadLength);-->

<!--    // Generate CSV-->
<!--    let csvContent = "QuadKey,Road Length (m),Sign Count,Total Features\n";-->
<!--    sortedStats.forEach(([quadKey, stats]) => {-->
<!--        csvContent += `${quadKey},${stats.roadLength.toFixed(2)},${stats.signCount}\n`;-->
<!--    });-->

<!--    // Display results-->
<!--    const statsResults = document.getElementById('statsResults');-->
<!--    statsResults.innerHTML = `-->
<!--        <div class="card">-->
<!--            <div class="card-header">-->
<!--                <h5 class="mb-0">QuadKey Statistics (Sorted by Road Length)</h5>-->
<!--            </div>-->
<!--            <div class="card-body">-->
<!--                <pre class="bg-light p-3">${csvContent}</pre>-->
<!--                <button id="downloadStats" class="btn btn-success">-->
<!--                    <i class="fas fa-download"></i> Download CSV-->
<!--                </button>-->
<!--            </div>-->
<!--        </div>-->
<!--    `;-->

<!--    // Add download functionality-->
<!--    document.getElementById('downloadStats').addEventListener('click', () => {-->
<!--        downloadCSV(csvContent, 'quadkey_statistics.csv');-->
<!--    });-->
<!--}-->

// Helper function to download CSV
function downloadCSV(content, filename) {
    const blob = new Blob([content], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
}

<!--// Add event listener for the statistics button-->
<!--document.getElementById('calculateStats').addEventListener('click', calculateGeojsonsStatistics);-->

        // ==================== ADMIN BOUNDARIES ====================
        queryAdminBtn.addEventListener('click', queryAdminBoundaries);
        clearAdminBtn.addEventListener('click', clearAdminBoundaries);
        splitQuadkeysBtn.addEventListener('click', generateQuadkeysFromPolygon);

        async function queryAdminBoundaries() {
            const adminLevel = document.getElementById('adminLevel').value;
            const countryFilter = document.getElementById('countryFilter').value;

            const bbox = getCurrentBbox();

            let query = `[out:json][timeout:90];
            (
              relation["boundary"="administrative"]["admin_level"="${adminLevel}"](${bbox});
            `;
            if (countryFilter) {
                const countries = countryFilter.split(',').map(c => c.trim());
                countries.forEach(country => {
                    query += `  relation["boundary"="administrative"]["admin_level"="${adminLevel}"]["name"="${country}"](${bbox});\n`;
                });
            }
            query += `);
            (._;>;);
            out body;
            >;
            out skel qt;`;

            try {
                const encodedQuery = encodeURIComponent(query);
                const response = await fetch(
                    `https://overpass-api.de/api/interpreter?data=${encodedQuery}`
                );

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const osmData = await response.json();
                processAdminData(osmData, adminLevel);

            } catch (error) {
                showStatus(`Error fetching boundaries: ${error.message}`, 'error');
            }
        }

        function processAdminData(osmData, adminLevel) {
            const nodes = {};
            const ways = {};
            const relations = {};
            // Build lookup tables
            osmData.elements.forEach(element => {
                switch (element.type) {
                    case 'node':
                        nodes[element.id] = [element.lon, element.lat];
                        break;
                    case 'way':
                        ways[element.id] = element;
                        break;
                    case 'relation':
                        relations[element.id] = element;
                        break;
                }
            });

            // Process each relation
            adminFeatures = [];

            Object.values(relations).forEach(relation => {
                if (!relation.tags || relation.tags.boundary !== 'administrative') return;

                const relationFeatures = processRelation(relation, ways, nodes);
                if (relationFeatures) {
                    adminFeatures.push(...relationFeatures);
                }
            });

            console.log(`Processed ${adminFeatures.length} admin polygons`);
            showStatus(`Found ${adminFeatures.length} admin boundaries`, 'success');

            displayAdminBoundaries();
            updateStats();
        }

        function processRelation(relation, ways, nodes) {
            if (!relation.members) return null;

            const outerSegments = [];
            const innerSegments = [];

            relation.members.forEach(member => {
                if (member.type === 'way' && ways[member.ref]) {
                    const way = ways[member.ref];
                    const coords = way.nodes
                        .map(nodeId => nodes[nodeId])
                        .filter(coord => coord !== undefined);

                    if (coords.length > 1) {
                        if (member.role === 'outer') {
                            outerSegments.push({
                                coords: coords,
                                first: coords[0],
                                last: coords[coords.length - 1]
                            });
                        } else if (member.role === 'inner') {
                            innerSegments.push({
                                coords: coords,
                                first: coords[0],
                                last: coords[coords.length - 1]
                            });
                        }
                    }
                }
            });

            if (outerSegments.length === 0) return null;

            const outerRings = connectSegments(outerSegments);
            const innerRings = connectSegments(innerSegments);

            const features = [];

            outerRings.forEach((outerRing, index) => {
                const belongingInnerRings = innerRings.filter(innerRing =>
                    isPointInPolygon(innerRing[0], outerRing)
                );

                const coordinates = [outerRing];
                belongingInnerRings.forEach(innerRing => {
                    coordinates.push(innerRing);
                });

                features.push({
                    type: 'Feature',
                    properties: {
                        name: relation.tags.name || relation.tags['name:es'] || 'Unnamed',
                        admin_level: relation.tags.admin_level,
                        osm_id: relation.id,
                        osm_type: 'relation',
                        part_index: index,
                        total_parts: outerRings.length,
                        isClicked: false,
                        isHighlighted: false,
                        ...relation.tags
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: coordinates
                    }
                });
            });

            return features;
        }

        function displayAdminBoundaries() {
            if (adminFeatures.length === 0) {
                showStatus('No admin boundaries to display', 'info');
                return;
            }

            // Clear existing admin layers
            if (map.getSource('admin-boundaries')) {
                map.removeLayer('admin-boundaries-fill');
                map.removeLayer('admin-boundaries-outline');
                map.removeSource('admin-boundaries');
            }

            const geoJson = {
                type: 'FeatureCollection',
                features: adminFeatures
            };

            map.addSource('admin-boundaries', {
                type: 'geojson',
                data: geoJson
            });

            // Add fill layer
            map.addLayer({
                id: 'admin-boundaries-fill',
                type: 'fill',
                source: 'admin-boundaries',
                paint: {
                    'fill-color': [
                        'case',
                        ['==', ['get', 'isClicked'], true], '#FFE66D',
                        ['==', ['get', 'isHighlighted'], true], '#FF6B6B',
                        '#4ECDC4'
                    ],
                    'fill-opacity': [
                        'case',
                        ['==', ['get', 'isClicked'], true], 0.8,
                        ['==', ['get', 'isHighlighted'], true], 0.6,
                        0.4
                    ],
                    'fill-outline-color': '#333'
                }
            });

            // Add outline layer
            map.addLayer({
                id: 'admin-boundaries-outline',
                type: 'line',
                source: 'admin-boundaries',
                paint: {
                    'line-color': [
                        'case',
                        ['==', ['get', 'isClicked'], true], '#333',
                        ['==', ['get', 'isHighlighted'], true], '#C44569',
                        '#333'
                    ],
                    'line-width': [
                        'case',
                        ['==', ['get', 'isClicked'], true], 3,
                        ['==', ['get', 'isHighlighted'], true], 2,
                        1
                    ],
                    'line-opacity': 0.8
                }
            });

            setupAdminInteractions();
        }

        function setupAdminInteractions() {
            map.off('click', 'admin-boundaries-fill');
            map.off('mouseenter', 'admin-boundaries-fill');
            map.off('mouseleave', 'admin-boundaries-fill');

            map.on('click', 'admin-boundaries-fill', (e) => {
                if (removeQuadkeyMode) return;
                if (e.features.length === 0) return;

                const clickedFeature = e.features[0];
                const clickedName = clickedFeature.properties.name;
                const clickedId = clickedFeature.id;

                console.log(`Clicked: ${clickedName} (ID: ${clickedId})`);

                // Update all features
                adminFeatures.forEach(feature => {
                    feature.properties.isClicked = false;
                    feature.properties.isHighlighted = false;

                    if (feature.properties.name === clickedName) {
                        if (feature.properties.osm_id === clickedFeature.properties.osm_id &&
                            feature.properties.part_index === clickedFeature.properties.part_index) {
                            feature.properties.isClicked = true;
                        } else {
                            feature.properties.isHighlighted = true;
                        }
                        selectedAdminPolygon.push(feature);
                    }
                });

                // Update source
                const source = map.getSource('admin-boundaries');
                if (source) {
                    const updatedGeoJson = {
                        type: 'FeatureCollection',
                        features: adminFeatures
                    };
                    source.setData(updatedGeoJson);
                }

                // Update UI
                updateAdminInfo(clickedFeature);
                splitQuadkeysBtn.disabled = false;
                currentHighlightName = clickedName;

                // Show info
                const sameNameCount = adminFeatures.filter(f =>
                    f.properties.name === clickedName
                ).length;

                showStatus(`Selected ${clickedName} (${sameNameCount} polygons)`, 'success');
                updateStats();
            });

            map.on('mouseenter', 'admin-boundaries-fill', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'admin-boundaries-fill', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        function updateAdminInfo(feature) {
            selectedPolygonName.textContent = feature.properties.name;
            selectedPolygonId.textContent = feature.properties.osm_id;
            selectedAdminLevel.textContent = feature.properties.admin_level;
            adminInfo.style.display = 'block';
        }

        function clearAdminBoundaries() {
            if (map.getSource('admin-boundaries')) {
                map.removeLayer('admin-boundaries-fill');
                map.removeLayer('admin-boundaries-outline');
                map.removeSource('admin-boundaries');
            }

            if (map.getSource('admin-quadkeys')) {
                map.removeLayer('admin-quadkeys');
                map.removeSource('admin-quadkeys');
            }

            adminFeatures = [];
            generatedQuadkeys = [];
            selectedAdminPolygon = [];
            adminInfo.style.display = 'none';
            splitQuadkeysBtn.disabled = true;
        }

        async function bindQuadkeyToCountry(qks) {
            await qks.reduce(async (prevPromise, qk) => {
                await prevPromise;
                const countries = await getQuadkeyCountries(qk);
                if (countries.length > 1) {
                    showCountrySelectionModal(qk, countries, 'add');
                } else {
                    addQuadkey(qk, countries);
                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            }, Promise.resolve());
            updateDisplayAndVisualization();
            recalculateStatistics();
        }

        // Handle map click
        async function handleMapClick(e) {
            if (!addQuadkeyMode && !removeQuadkeyMode) return;

            const zoom = parseInt(document.getElementById('zoomLevel').value);
            const tile = tileAtZoom(e.lngLat.lat, e.lngLat.lng, zoom);
            const quadkey = toQuadkey(tile.x, tile.y, zoom);

            // Get countries for this quadkey
            const countries = await getQuadkeyCountries(quadkey);

            if (addQuadkeyMode) {
                if (countries.length > 1) {
                    showCountrySelectionModal(quadkey, countries, 'add');
                } else {
                    addQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            } else if (removeQuadkeyMode) {
                if (!quadkeyCountriesMap.has(quadkey) && (!currentCountryQuadkeys ||
                    !Object.values(currentCountryQuadkeys).flat().includes(quadkey))) {
                    showStatus(`Quadkey ${quadkey} not found in current data`, 'error');
                    return;
                }

                if (countries.length > 1 && quadkeyCountriesMap.has(quadkey)) {
                    const currentCountries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    showCountrySelectionModal(quadkey, currentCountries, 'remove');
                } else {
                    removeQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            }
        }

        // Show country selection modal
        function showCountrySelectionModal(quadkey, countries, action) {
            const modalHTML = `
                <div id="countrySelectionModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <h3>Select Countries for Quadkey: ${quadkey}</h3>
                        <p>This quadkey spans multiple countries. Choose which countries to ${action}:</p>
                        <div id="countrySelectionList">
                            ${countries.map(country => `
                                <div class="country-selection-item">
                                    <label for="sel-${country}">${country}</label>
                                    <input type="checkbox" id="sel-${country}" style="width:20px;height:20px;margin-left:30px; margin-top:3px" value="${country}" checked>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-buttons">
                            <button id="confirmSelection">Confirm</button>
                            <button id="cancelSelection">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer);

            document.getElementById('confirmSelection').addEventListener('click', function() {
                const selectedCountries = [];
                countries.forEach(country => {
                    const checkbox = document.getElementById(`sel-${country}`);
                    if (checkbox.checked) {
                        selectedCountries.push(country);
                    }
                });

                if (selectedCountries.length > 0) {
                    if (action === 'add') {
                        addQuadkey(quadkey, selectedCountries);
                    } else {
                        removeQuadkey(quadkey, selectedCountries);
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }

                document.body.removeChild(modalContainer);
            });

            document.getElementById('cancelSelection').addEventListener('click', function() {
                document.body.removeChild(modalContainer);
            });

            document.getElementById('countrySelectionModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    document.body.removeChild(modalContainer);
                }
            });
        }

        // Convert route to WKT format
        function convertRouteToWKT(route) {
            if (!route || !route.legs) {
                throw new Error('Invalid route data');
            }

            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No coordinates found in route');
            }

            const wktCoordinates = allCoords.map(coord => `${coord[0]} ${coord[1]}`).join(', ');
            return `LINESTRING (${wktCoordinates})`;
        }

                // Calculate intersection length between a complete line and a quadkey bounds
        function calculateIntersectionLength(lineCoordinates, quadkeyBounds) {
            // Check if any part of the line intersects with the bounds
            let totalIntersectionLength = 0;

            for (let i = 1; i < lineCoordinates.length; i++) {
                const segmentStart = lineCoordinates[i - 1];
                const segmentEnd = lineCoordinates[i];

                // Check if this segment intersects with bounds
                if (lineSegmentIntersectsBounds(segmentStart, segmentEnd, quadkeyBounds)) {
                    // Calculate the clipped segment length
                    const clippedSegment = clipSegmentToBounds(segmentStart, segmentEnd, quadkeyBounds);
                    if (clippedSegment) {
                        const [lon1, lat1] = clippedSegment[0];
                        const [lon2, lat2] = clippedSegment[1];

                        // Calculate distance
                        const R = 6371000;
                        const Ï†1 = lat1 * Math.PI / 180;
                        const Ï†2 = lat2 * Math.PI / 180;
                        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
                        const Î”Î» = (lon2 - lon1) * Math.PI / 180;

                        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                                 Math.cos(Ï†1) * Math.cos(Ï†2) *
                                 Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
                        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

                        totalIntersectionLength += R * c;
                    }
                }
            }

            return totalIntersectionLength;
        }

                // Clip a line segment to bounds (returns the portion of segment inside bounds)
        function clipSegmentToBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            // Cohen-Sutherland line clipping algorithm
            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;

                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;

                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    // Both points inside - accept the whole segment
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    // Both points outside on same side - reject
                    break;
                } else {
                    // Some part is inside - clip
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        // Point is above the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        // Point is below the clip rectangle
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        // Point is to the right of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        // Point is to the left of clip rectangle
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }

            if (accept) {
                return [[x1, y1], [x2, y2]];
            }
            return null;
        }

        function createSignFeature(sign, country, quadkey) {
    let maxspeedValue = '';

    if (currentProcessingMode === 'speed_limits') {
        // Speed Limits mode: rename detection_type to maxspeed
        if (sign.detection_type) {
            if (!sign.detection_type.toLowerCase().startsWith("speed_limit")) {
                maxspeedValue = sign.detection_type;
            } else {
                // Extract speed limit value
                const parts = sign.detection_type.toLowerCase().split("speed_limit_");
                maxspeedValue = parts.length > 1 ? parts[1] : sign.detection_type;
            }
        }
    } else {
        // Oneways mode: keep original detection_type
        maxspeedValue = sign.detection_type || '';
    }

    // Parse coordinates
    let lat = 0, lon = 0;
    if (sign.coordinates && Array.isArray(sign.coordinates) && sign.coordinates.length >= 2) {
        lon = sign.coordinates[0];
        lat = sign.coordinates[1];
    } else if (sign.lat && sign.lon) {
        lat = parseFloat(sign.lat);
        lon = parseFloat(sign.lon);
    }

    // Parse angle for URLs
    const angle = parseFloat(sign.angle) || 0;

    // Generate all URLs
    const properties = {
        id: sign.id || '',
        supplementary_type: sign.supplementary_type || '',
        angle: angle.toString(),
        confidence: sign.confidence || '',
        cluster_size: sign.cluster_size || '',
        url_rsd_link: getLvdExplorerLink(lon, lat, 18),
        url_google: withGoogleLink(lon, lat, angle),
        url_bing: getBingLink(lon, lat, angle),
        url_mapillary: getMapillaryLink(lon, lat, angle),
        url_tabula_rasa_link: getTabulaLink(lat, lon)
    };

    // Add maxspeed or detection_type based on mode
    if (currentProcessingMode === 'speed_limits') {
        properties.maxspeed = maxspeedValue;
    } else {
        properties.detection_type = sign.detection_type || '';
        // Also include maxspeed if it exists in original data
        if (sign.maxspeed) {
            properties.maxspeed = sign.maxspeed;
        }
    }

    // Add optional timestamp fields if they exist
    if (sign.creation_timestamp) properties.creation_timestamp = sign.creation_timestamp;
    if (sign.last_modified_timestamp) properties.last_modified_timestamp = sign.last_modified_timestamp;

    return {
        type: 'Feature',
        properties: properties,
        geometry: {
            type: 'Point',
            coordinates: [lon, lat]
        }
    };
}

        function processMaxspeed(detectionType) {
            if (!detectionType) return '';

            if (!detectionType.toLowerCase().startsWith("speed_limit")) {
                return detectionType;
            }

            // Extract speed limit value
            const parts = detectionType.toLowerCase().split("speed_limit_");
            if (parts.length > 1) {
                return parts[1]; // Returns just the speed value, e.g., "50"
            }
            return detectionType;
        }

        // Download combined GeoJSON
        document.getElementById('downloadCombinedResultsBtn').addEventListener('click', async function() {
            if (!combinedGeoJSON || Object.keys(combinedGeoJSON).length === 0) {
                showStatus('No combined data available', 'error');
                return;
            }

            try {
                await loadJSZip();
                const zip = new JSZip();
                let fileCount = 0;
                let csvContent = "QuadKey,Road Length (m),Sign Count,Total Features\n";
                for (const [country, quadkeys] of Object.entries(combinedGeoJSON)) {
                    const countryFolder = zip.folder(country);

                    for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                        if (geojson.features.length > 0) {
                            // Separate roads and signs
                            const roadsFeatures = geojson.features.filter(f => f.geometry.type !== 'LineString');
                            const signsFeatures = geojson.features.filter(f => f.geometry.type === 'Point');

                            // Generate CSV

                            csvContent += `${quadkey},${stats.roadLength.toFixed(2)},${signsFeatures}\n`;


                            // Create combined file
                            const fileName = `${quadkey}.geojson`;
                            countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                            fileCount++;
                        }
                    }
                }

                navigator.clipboard.writeText(f`${csvContent}`).then(() => {
                    showStatus('Stats copied to clipboard!', 'success');
                });

<!--                // Add download functionality-->
<!--                document.getElementById('downloadStats').addEventListener('click', () => {-->
<!--                    downloadCSV(csvContent, 'quadkey_statistics.csv');-->
<!--                });-->

<!--                // Display results-->
<!--                const statsResults = document.getElementById('statsResults');-->
<!--                statsResults.innerHTML = `-->
<!--                    <div class="card">-->
<!--                        <div class="card-header">-->
<!--                            <h5 class="mb-0">QuadKey Statistics (Sorted by Road Length)</h5>-->
<!--                        </div>-->
<!--                        <div class="card-body">-->
<!--                            <pre class="bg-light p-3">${csvContent}</pre>-->
<!--                            <button id="downloadStats" class="btn btn-success">-->
<!--                                <i class="fas fa-download"></i> Download CSV-->
<!--                            </button>-->
<!--                        </div>-->
<!--                    </div>-->
<!--                `;-->

                // Generate and download zip file
                zip.generateAsync({ type: 'blob' }).then(function(content) {
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    let currentDate = new Date();
                    let iso = currentDate.toISOString()
                    a.download = `roads_signs_${currentProcessingMode}_${iso}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    // Count totals
                    let totalRoads = 0;
                    let totalSigns = 0;

                    for (const [country, quadkeys] of Object.entries(combinedGeoJSON)) {
                        for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                            totalRoads += geojson.features.filter(f => f.properties.type !== 'sign').length;
                            totalSigns += geojson.features.filter(f => f.properties.type === 'sign').length;
                        }
                    }

                    showStatus(`Downloaded ${fileCount} GeoJSON files with ${totalRoads} roads and ${totalSigns} signs`, 'success');
                });

            } catch (error) {
                showStatus('Error creating zip file: ' + error.message, 'error');
                console.error(error);
            }
        });

        // Geographic utility functions for URL generation
        function normalizeDeg360(deg) {
            let normalized = deg;
            while (normalized >= 360) {
                normalized -= 360;
            }
            while (normalized < 0) {
                normalized += 360;
            }
            return normalized;
        }

        function getOppositeAngle(deg) {
            return normalizeDeg360(deg + 180.0);
        }

                // Calculate destination point given start point, bearing, and distance
        function calculateDestination(lat, lon, bearing, distanceMeters) {
            // Simple spherical Earth calculation (good enough for short distances)
            const R = 6371000; // Earth's radius in meters
            const bearingRad = bearing * Math.PI / 180;
            const latRad = lat * Math.PI / 180;
            const lonRad = lon * Math.PI / 180;

            const angularDistance = distanceMeters / R;

            const lat2Rad = Math.asin(
                Math.sin(latRad) * Math.cos(angularDistance) +
                Math.cos(latRad) * Math.sin(angularDistance) * Math.cos(bearingRad)
            );

            const lon2Rad = lonRad + Math.atan2(
                Math.sin(bearingRad) * Math.sin(angularDistance) * Math.cos(latRad),
                Math.cos(angularDistance) - Math.sin(latRad) * Math.sin(lat2Rad)
            );

            return {
                lat: lat2Rad * 180 / Math.PI,
                lon: lon2Rad * 180 / Math.PI
            };
        }

        // URL generation functions
        function withGoogleLink(lon, lat, hdg, distance = 10) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, distance);
            return `https://maps.google.com/maps?q=&layer=c&cbll=${dest.lat},${dest.lon}&cbp=11,${hdgNum},0,0,0`;
        }

        function getTabulaLink(lat, lon) {
            const disable_features = "points,service_roads,paths,buildings,building_parts,indoor,landuse,boundaries,water,rail,pistes,aerialways,power,past_future,others";
            return `https://tabula-rasa-roads-production.tilestream.net/id-internal/index.html#disable_features=${disable_features}&map=20.90/${lat}/${lon}`;
        }

        function getMapillaryLink(lon, lat, hdg, zoom = 17) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, 10);
            return `https://www.mapillary.com/app/?lat=${dest.lat}&lng=${dest.lon}&z=${zoom}`;
        }

        function getBingLink(lon, lat, hdg) {
            const hdgNum = parseFloat(hdg) || 0;
            const oppositeAngle = getOppositeAngle(hdgNum);
            const dest = calculateDestination(lat, lon, oppositeAngle, 10);
            return `https://www.bing.com/maps?cp=${dest.lat}~${dest.lon}&lvl=15&dir=${hdgNum}&style=x&v=2&sV=1`;
        }

        function getLvdExplorerLink(lon, lat, zoom = 18) {
            return `https://sites.mapbox.com/lvd-explorer/#${zoom}/${lat}/${lon}`;
        }

        function isQuadkeyInResults(quadkey) {
            if (!currentCountryQuadkeys) return false;

            for (const quadkeys of Object.values(currentCountryQuadkeys)) {
                if (quadkeys.includes(quadkey)) {
                    return true;
                }
            }
            return false;
        }

                function generateHereRoadsSQL(countryQuadkeys) {
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            const countryConditions = [];
            let escapedWKT;
            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];
                if (quadkeys.length === 0) continue;
                const wktMultipolygon = generateMultipolygonWKT(quadkeys);
                escapedWKT = wktMultipolygon.replace(/'/g, "''");
            }

            const query = `WITH ways AS (
          SELECT
            id,
            osmium_id,
            mapbox_id,
            type,
            tags,
            nds,
            dt
          FROM
            roads_hereproduction.road_pipeline_v3_0_0_road_here
          WHERE
            dt = '2026-01-15'
            AND region = 'Europe_West'
            AND type = 'way'
            and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')
        ),
        nodes AS (
          SELECT
            id,
            lat,
            lon
          FROM
            roads_hereproduction.road_pipeline_v3_0_0_road_here
          WHERE
            dt = '2026-01-15'
            AND region = 'Europe_West'
            AND type = 'node'
            AND lat IS NOT NULL
            AND lon IS NOT NULL
        ),
        unique_way_points AS (
          SELECT
            *
          FROM (
            SELECT
              w.id,
              w.osmium_id,
              w.mapbox_id,
              w.type,
              w.tags,
              w.dt,
              t.node_index,
              ST_Point(n.lon, n.lat) AS point_geom,
              LAG(ST_Point(n.lon, n.lat), 1) OVER (PARTITION BY w.id ORDER BY t.node_index) AS prev_point_geom
            FROM
              ways AS w
            CROSS JOIN
              UNNEST(w.nds) WITH ORDINALITY AS t(node_id, node_index)
            JOIN
              nodes AS n ON t.node_id = n.id
          )
          WHERE
            prev_point_geom IS NULL OR NOT ST_Equals(point_geom, prev_point_geom)
        ),
        geom AS (
            SELECT
              uwp.id,
              uwp.osmium_id,
              uwp.mapbox_id,
              uwp.type,
              uwp.tags,
              uwp.dt,
              array_agg(uwp.point_geom ORDER BY uwp.node_index) as geometry_arr,
              ST_LineString(array_agg(uwp.point_geom ORDER BY uwp.node_index)) AS geometry
            FROM
              unique_way_points AS uwp
            GROUP BY
              uwp.id,
              uwp.osmium_id,
              uwp.mapbox_id,
              uwp.type,
              uwp.tags,
              uwp.dt
            HAVING
              count(uwp.point_geom) >= 2
        )
        SELECT
              id,
              tags,
              ST_AsText(geometry) as geometry_wkt
        FROM geom
        WHERE
            ST_Intersects(
                geometry,
                st_geometryfromtext('${escapedWKT}')
            )`;
            return query;
        }

        // Copy WKT to clipboard
        document.getElementById('copyWktBtn').addEventListener('click', function() {
            if (!currentRouteData) {
                showStatus('No route data available', 'error');
                return;
            }

            try {
                const route = currentRouteData.routes[currentRouteIndex];
                const wkt = convertRouteToWKT(route);

                navigator.clipboard.writeText(wkt).then(() => {
                    showStatus('WKT copied to clipboard!', 'success');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = wkt;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('WKT copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating WKT: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Add a quadkey to results
        function addQuadkey(quadkey, countries) {
            if (!quadkeyCountriesMap) {
                quadkeyCountriesMap = new Map();
            }
            if (!currentCountryQuadkeys) {
                currentCountryQuadkeys = {};
            }
            if (!countryControlsState) {
                countryControlsState = {};
            }

            quadkeyCountriesMap.set(quadkey, new Set(countries));

            countries.forEach(country => {
                if (!currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = [];
                }
                if (!currentCountryQuadkeys[country].includes(quadkey)) {
                    currentCountryQuadkeys[country].push(quadkey);
                    currentCountryQuadkeys[country].sort();
                }

                countryControlsState[country] = true;
            });

            showStatus(`Added quadkey ${quadkey} for countries: ${countries.join(', ')}`, 'success');

            if (Object.keys(currentCountryQuadkeys).length > 0) {
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            }
        }

        // Remove a quadkey
        function removeQuadkey(quadkey, countries) {
            countries.forEach(country => {
                if (currentCountryQuadkeys && currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = currentCountryQuadkeys[country].filter(q => q !== quadkey);
                    if (currentCountryQuadkeys[country].length === 0) {
                        delete currentCountryQuadkeys[country];
                        delete countryControlsState[country];
                    }
                }
            });

            if (quadkeyCountriesMap) {
                const currentCountries = quadkeyCountriesMap.get(quadkey);
                if (currentCountries) {
                    countries.forEach(country => currentCountries.delete(country));
                    if (currentCountries.size === 0) {
                        quadkeyCountriesMap.delete(quadkey);
                    }
                }
            }

            showStatus(`Removed quadkey ${quadkey} from countries: ${countries.join(', ')}`, 'success');

            if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
                document.getElementById('copySqlResultsBtn').disabled = true;
                document.getElementById('copySignsSqlBtn').disabled = true;
                document.getElementById('countryControlsContainer').style.display = 'none';
            }
        }

        // Initialize processing mode
        function initProcessingMode() {
            const processingModeSelect = document.getElementById('processingMode');
            currentProcessingMode = processingModeSelect.value;

            processingModeSelect.addEventListener('change', function() {
                currentProcessingMode = this.value;
                if (currentCountryQuadkeys) {
                    updateDisplayAndVisualization();
                }
            });
        }

        // Recalculate statistics
        function recalculateStatistics() {
            if (!currentCountryQuadkeys) return;

            let totalQuadkeys = 0;
            let borderQuadkeys = 0;
            let totalCountries = new Set();
            const seenQuadkeys = new Set();

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                totalCountries.add(country);
                quadkeys.forEach(quadkey => {
                    if (!seenQuadkeys.has(quadkey)) {
                        seenQuadkeys.add(quadkey);
                        totalQuadkeys++;
                        const countries = quadkeyCountriesMap.get(quadkey);
                        if (countries && countries.size > 1) {
                            borderQuadkeys++;
                        }
                    }
                });
            }

            const statsEl = document.getElementById('statsDetails');
            statsEl.textContent = `Found ${totalQuadkeys} quadkeys, ${borderQuadkeys} border quadkeys across ${totalCountries.size} countries`;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Show/hide loading indicator
        function setLoading(loading) {
            document.getElementById('loadingIndicator').style.display = loading ? 'block' : 'none';
            document.getElementById('processBtn').disabled = loading;

            if (loading && processingController) {
                processingController.abort();
            }
            processingController = new AbortController();
        }

        // Fast country detection using Mapbox Geocoding
        async function reverseGeocodeCountry(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;

            if (countryCache[cacheKey]) {
                return countryCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=country&access_token=${MAPBOX_TOKEN}`,
                    {
                        signal: processingController?.signal
                    }
                );

                if (!response.ok) {
                    throw new Error(`Mapbox API error: ${response.status}`);
                }

                const data = await response.json();
                let countryCode = 'UNKNOWN';
                if (data.features && data.features.length > 0) {
                    const place = data.features[0];
                    countryCode = place.properties?.short_code?.toUpperCase() || 'UNKNOWN';
                }

                countryCache[cacheKey] = countryCode;
                return countryCode;

            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.warn(`Mapbox geocoding failed for (${lat}, ${lng}):`, error);
                return 'UNKNOWN';
            }
        }

        // Get countries for a quadkey
        async function getQuadkeyCountries(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            const countries = new Set();

            const samplePoints = [
                [bounds.north, bounds.west],
                [bounds.north, bounds.east],
                [bounds.south, bounds.west],
                [bounds.south, bounds.east],
                [(bounds.north + bounds.south) / 2, (bounds.west + bounds.east) / 2]
            ];

            const promises = samplePoints.map(([lat, lng]) => reverseGeocodeCountry(lat, lng));
            const results = await Promise.all(promises);

            results.forEach(country => {
                if (country && country !== 'UNKNOWN') {
                    countries.add(country);
                }
            });

            return Array.from(countries);
        }

        // Parse uploaded JSON file
        document.getElementById('routeFile').addEventListener('change', function(e) {
            currentCountryQuadkeys = null;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.routes || !Array.isArray(data.routes)) {
                        throw new Error('Invalid route file format. Expected "routes" array.');
                    }

                    currentRouteData = data;
                    countryCache = {};

                    document.getElementById('fileInputLabel').textContent = file.name;

                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '';

                    data.routes.forEach((route, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Route ${index + 1}`;
                        routeSelect.appendChild(option);
                    });

                    document.getElementById('routeSelectorContainer').style.display = 'block';
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('downloadRouteBtn').disabled = false;
                    document.getElementById('copyWktBtn').disabled = false;

                    loadRoute(0);
                    showStatus('Route file loaded successfully!', 'success');
                } catch (error) {
                    showStatus(`Error parsing JSON: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Handle route selection change
        document.getElementById('routeSelect').addEventListener('change', function(e) {
            const routeIndex = parseInt(e.target.value);
            loadRoute(routeIndex);
        });

        // Load a route onto the map
        function loadRoute(routeIndex) {
            if (!currentRouteData || !currentRouteData.routes[routeIndex]) {
                showStatus('Invalid route selected', 'error');
                return;
            }

            currentRouteIndex = routeIndex;
            const route = currentRouteData.routes[routeIndex];

            // Remove existing route layer
            if (map.getSource('route')) {
                map.removeLayer('route-line');
                map.removeSource('route');
            }

            const allCoords = [];
            let totalDistance = 0;
            let waypointCount = 0;

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    const geom = step.geometry;
                    if (geom.type === 'LineString' && geom.coordinates) {
                        const latLngs = geom.coordinates.map(coord => [coord[0], coord[1]]);
                        allCoords.push(...latLngs);

                        if (latLngs.length > 1) {
                            for (let i = 1; i < latLngs.length; i++) {
                                totalDistance += calculateDistance(latLngs[i-1], latLngs[i]);
                            }
                        }

                        waypointCount += latLngs.length;
                    }
                });
            });

            // Create route GeoJSON
            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`
                }
            };

            // Add route to map
            map.addSource('route', {
                type: 'geojson',
                data: routeFeature
            });

            map.addLayer({
                id: 'route-line',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#3498db',
                    'line-width': 4,
                    'line-opacity': 0.7
                }
            });

            // Fit bounds to route
            const bounds = getBoundingBox(routeFeature);
            map.fitBounds([[bounds.xMin, bounds.yMin], [bounds.xMax, bounds.yMax]], {
                padding: 50
            });

            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('routeDetails').textContent =
                `Distance: ${(totalDistance / 1000).toFixed(2)} km, Waypoints: ${waypointCount}, Legs: ${route.legs.length}`;

            clearQuadkeyLayers();
            document.getElementById('resultsOutput').textContent =
                'No results yet. Click "Calculate Quadkeys" to process this route.';
            document.getElementById('copyResultsBtn').disabled = true;
            document.getElementById('copySqlResultsBtn').disabled = true;
            document.getElementById('copySignsSqlBtn').disabled = true;
            document.getElementById('downloadGeoJSONBtn').disabled = true;
            document.getElementById('statsInfo').style.display = 'none';
            document.getElementById('countryControlsContainer').style.display = 'none';
            document.getElementById('copyWktBtn').style.display = 'block';

            // Reset modes
            addQuadkeyMode = false;
            removeQuadkeyMode = false;
            document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
            document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
        }

        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371e3;
            const Ï†1 = coord1[0] * Math.PI / 180;
            const Ï†2 = coord2[0] * Math.PI / 180;
            const Î”Ï† = (coord2[0] - coord1[0]) * Math.PI / 180;
            const Î”Î» = (coord2[1] - coord1[1]) * Math.PI / 180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                     Math.cos(Ï†1) * Math.cos(Ï†2) *
                     Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Get bounding box
        function getBoundingBox(data) {
            var bounds = {}, coords, point, latitude, longitude;
            coords = data.geometry.coordinates;
            for (var j = 0; j < coords.length; j++) {
                longitude = coords[j][0];
                latitude = coords[j][1];
                bounds.xMin = bounds.xMin < longitude ? bounds.xMin : longitude;
                bounds.xMax = bounds.xMax > longitude ? bounds.xMax : longitude;
                bounds.yMin = bounds.yMin < latitude ? bounds.yMin : latitude;
                bounds.yMax = bounds.yMax > latitude ? bounds.yMax : latitude;
            }
            return bounds;
        }

        // Process route to calculate quadkeys
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!currentRouteData) {
                showStatus('Please upload a route file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Calculating quadkeys using bounding box approach...', 'info');

            try {
                const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
                currentZoomLevel = zoomLevel;
                const route = currentRouteData.routes[currentRouteIndex];

                const startTime = Date.now();
                var { countryQuadkeys, stats, quadkeyCountries } = await getRouteQuadkeysWithCountriesBBox(
                    route,
                    zoomLevel
                );
                const processingTime = (Date.now() - startTime) / 1000;

                currentCountryQuadkeys = countryQuadkeys;
                quadkeyCountriesMap = quadkeyCountries;
                originalStats = stats;

                // Initialize all countries as enabled
                countryControlsState = {};
                countryBorderExclusions.clear();
                Object.keys(countryQuadkeys).forEach(country => {
                    countryControlsState[country] = true;
                });

                createCountryControls(countryQuadkeys, false);
                updateDisplayAndVisualization();

                // Show statistics
                document.getElementById('statsInfo').style.display = 'block';
                document.getElementById('statsDetails').textContent =
                    `Found ${stats.totalQuadkeys} quadkeys, ${stats.borderQuadkeys} border quadkeys in ${processingTime.toFixed(1)}s`;

                showStatus(`Found ${stats.totalQuadkeys} quadkeys across ${Object.keys(countryQuadkeys).length} countries`, 'success');

                document.getElementById('downloadGeoJSONBtn').disabled = false;
                document.getElementById('copyResultsBtn').disabled = false;
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`Error calculating quadkeys: ${error.message}`, 'error');
                    console.error(error);
                }
            } finally {
                setLoading(false);
            }
        });

        // Get quadkeys for a route using bounding box approach
        async function getRouteQuadkeysWithCountriesBBox(route, zoom) {
            var stats = {
                totalQuadkeys: 0,
                borderQuadkeys: 0
            };

            // Extract all coordinates
            const allLineStrings = [];
            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allLineStrings.push(step.geometry.coordinates);
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No valid coordinates found in route');
            }

            // Get bounding box
            const lats = allCoords.map(coord => coord[1]);
            const lngs = allCoords.map(coord => coord[0]);

            const minLon = Math.min(...lngs);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lngs);
            const maxLat = Math.max(...lats);

            showStatus(`Route bounds: ${minLon.toFixed(4)}, ${minLat.toFixed(4)} to ${maxLon.toFixed(4)}, ${maxLat.toFixed(4)}`, 'info');

            // Get all tiles in bounding box
            const tiles = getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom);
            showStatus(`Checking ${tiles.length} tiles for intersection...`, 'info');

            const quadkeyCountries = new Map();

            // Check which tiles intersect with route
            for (let i = 0; i < tiles.length; i++) {
                if (processingController?.signal.aborted) {
                    throw new DOMException('Aborted', 'AbortError');
                }

                const tile = tiles[i];
                const quadkey = toQuadkey(tile.x, tile.y, zoom);
                const tileBounds = tileToBounds(tile);

                let intersects = false;
                for (const lineString of allLineStrings) {
                    if (lineStringIntersectsBounds(lineString, tileBounds)) {
                        intersects = true;
                        break;
                    }
                }

                if (intersects) {
                    const countries = await getQuadkeyCountries(quadkey);
                    if (countries.length > 1) {
                        stats.borderQuadkeys++;
                    }
                    quadkeyCountries.set(quadkey, new Set(countries));

                    if (i % 10 === 0) {
                        showStatus(`Processing tiles... ${Math.round((i / tiles.length) * 100)}%`, 'info');
                    }
                }
            }

            stats.totalQuadkeys = quadkeyCountries.size;

            // Convert to country->quadkeys mapping
            const countryQuadkeys = {};
            for (const [quadkey, countries] of quadkeyCountries.entries()) {
                for (const country of countries) {
                    if (!countryQuadkeys[country]) {
                        countryQuadkeys[country] = new Set();
                    }
                    countryQuadkeys[country].add(quadkey);
                }
            }

            // Convert Sets to Arrays and sort
            const result = {};
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                result[country] = Array.from(quadkeys).sort();
            }

            return {
                countryQuadkeys: result,
                stats,
                quadkeyCountries: quadkeyCountries
            };
        }

        // Create country controls UI
        function createCountryControls(countryQuadkeys, qkManipulationEvent) {
            const container = document.getElementById('countryControls');
            container.innerHTML = '';

            const sortedCountries = Object.keys(countryQuadkeys).sort();

            sortedCountries.forEach(country => {
                const quadkeys = countryQuadkeys[country];
                const count = quadkeys.length;

                const controlDiv = document.createElement('div');
                controlDiv.className = 'country-control';
                const check = qkManipulationEvent ? (countryControlsState[country] ? 'checked' : '') : 'checked';

                controlDiv.innerHTML = `
                    <input type="checkbox" class="country-checkbox" id="chk-${country}" ${check}>
                    <div class="country-label">
                        <span class="country-name">${country}</span>
                        <span class="country-count">${count}</span>
                    </div>
                    <button class="border-control" data-country="${country}" title="Exclude border quadkeys for ${country}">No Borders</button>
                `;

                container.appendChild(controlDiv);

                // Add event listener for checkbox
                const checkbox = controlDiv.querySelector('.country-checkbox');
                checkbox.addEventListener('change', function() {
                    countryControlsState[country] = this.checked;
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });

                // Add event listener for border control
                const borderBtn = controlDiv.querySelector('.border-control');
                borderBtn.addEventListener('click', function() {
                    const country = this.getAttribute('data-country');
                    if (countryBorderExclusions.has(country)) {
                        countryBorderExclusions.delete(country);
                        this.classList.remove('excluded');
                        this.textContent = 'No Borders';
                    } else {
                        countryBorderExclusions.add(country);
                        this.classList.add('excluded');
                        this.textContent = 'With Borders';
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });
            });
        }

        // Update display and visualization
        function updateDisplayAndVisualization() {
            if (!currentCountryQuadkeys) {
                document.getElementById('resultsOutput').textContent = 'No quadkeys found.';
                clearQuadkeyLayers();
                return;
            }

            // Filter quadkeys based on country controls and border exclusions
            const filteredCountryQuadkeys = {};

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (countryControlsState[country]) {
                    let filteredQuadkeys = [...quadkeys];

                    if (countryBorderExclusions && countryBorderExclusions.has(country)) {
                        filteredQuadkeys = filteredQuadkeys.filter(quadkey => {
                            const countries = quadkeyCountriesMap.get(quadkey);
                            return countries && countries.size === 1 && countries.has(country);
                        });
                    }

                    if (filteredQuadkeys.length > 0) {
                        filteredCountryQuadkeys[country] = filteredQuadkeys;
                    }
                }
            }

            displayResults(filteredCountryQuadkeys);
            visualizeQuadkeys(filteredCountryQuadkeys, currentZoomLevel);
        }

        // Select all countries
        document.getElementById('selectAllBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = true;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = true;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Select none countries
        document.getElementById('selectNoneBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = false;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = false;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Visualize quadkeys on map
        function visualizeQuadkeys(countryQuadkeys, zoom) {
            clearQuadkeyLayers();

            if (!countryQuadkeys || Object.keys(countryQuadkeys).length === 0) {
                return;
            }

            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
            ];

            let colorIndex = 0;
            const countryColors = {};
            const quadkeyCountries = new Map();

            // First pass: count how many countries each quadkey belongs to
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                for (const quadkey of quadkeys) {
                    if (!quadkeyCountries.has(quadkey)) {
                        quadkeyCountries.set(quadkey, new Set());
                    }
                    quadkeyCountries.get(quadkey).add(country);
                }
            }

            // Second pass: visualize with appropriate colors
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                if (!countryColors[country]) {
                    countryColors[country] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const baseColor = countryColors[country];

                for (const quadkey of quadkeys) {
                    const bounds = quadkeyToBounds(quadkey);
                    const countriesForQuadkey = quadkeyCountries.get(quadkey);

                    let color, fillOpacity;
                    if (countriesForQuadkey.size > 1) {
                        color = '#ffeb3b';
                        fillOpacity = 0.3;
                    } else {
                        color = baseColor;
                        fillOpacity = 0.3;
                    }

                    // Create polygon GeoJSON for quadkey
                    const polygonGeoJSON = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                [bounds.west, bounds.south],
                                [bounds.west, bounds.north],
                                [bounds.east, bounds.north],
                                [bounds.east, bounds.south],
                                [bounds.west, bounds.south]
                            ]]
                        },
                        properties: {
                            quadkey: quadkey,
                            country: country,
                            isBorder: countriesForQuadkey.size > 1
                        }
                    };

                    const sourceId = `quadkey-${quadkey}`;
                    const layerId = `quadkey-layer-${quadkey}`;

                    // Add source
                    map.addSource(sourceId, {
                        type: 'geojson',
                        data: polygonGeoJSON
                    });

                    // Add fill layer
                    map.addLayer({
                        id: layerId + '-fill',
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': color,
                            'fill-opacity': fillOpacity
                        }
                    });

                    // Add outline layer
                    map.addLayer({
                        id: layerId + '-outline',
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': color,
                            'line-width': 2
                        }
                    });

                    // Store layer references
                    if (!mapLayers.quadkeys.has(quadkey)) {
                        mapLayers.quadkeys.set(quadkey, []);
                    }
                    mapLayers.quadkeys.get(quadkey).push(layerId + '-fill', layerId + '-outline');

                    // Add click handler
                    map.on('click', layerId + '-fill', (e) => {
                        if (removeQuadkeyMode) {
                            const clickedQuadkey = quadkey;
                            const countries = Array.from(quadkeyCountriesMap.get(clickedQuadkey) || []);

                            if (countries.length > 1) {
                                showCountrySelectionModal(clickedQuadkey, countries, 'remove');
                            } else {
                                removeQuadkey(clickedQuadkey, countries);
                                updateDisplayAndVisualization();
                                recalculateStatistics();
                                if (currentCountryQuadkeys) {
                                    createCountryControls(currentCountryQuadkeys, true);
                                }
                            }
                        } else {
                            navigator.clipboard.writeText(quadkey).then(() => {
                                showStatus('Quadkey copied to clipboard!', 'success');
                            }).catch(err => {
                                console.error('Copy failed:', err);
                            });
                        }
                    });

                    // Change cursor on hover
                    map.on('mouseenter', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });

                    map.on('mouseleave', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = '';
                    });
                }
            }
        }

        // Clear quadkey layers from map
        function clearQuadkeyLayers() {
            mapLayers.quadkeys.forEach((layers, quadkey) => {
                layers.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });
                const sourceId = `quadkey-${quadkey}`;
                if (map.getSource(sourceId)) {
                    map.removeSource(sourceId);
                }
            });
            mapLayers.quadkeys.clear();
        }

        document.getElementById('zoomLevel').addEventListener('click', function() {
            currentZoomLevel = document.getElementById('zoomLevel').value;
        })

        // Copy results to clipboard
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsText = document.getElementById('resultsOutput').textContent;

            navigator.clipboard.writeText(resultsText).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });

        // Quadkey utility functions
        function tileAtZoom(lat, lng, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);
            return { x, y, z: zoom };
        }

        function toQuadkey(x, y, z) {
            let quadkey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit += 1;
                if ((y & mask) !== 0) digit += 2;
                quadkey += digit.toString();
            }
            return quadkey;
        }

        function quadkeyToBounds(quadkey) {
            let x = 0, y = 0;
            const z = quadkey.length;

            for (let i = z; i > 0; i--) {
                const mask = 1 << (i - 1);
                const q = parseInt(quadkey[z - i]);
                if (q & 1) x |= mask;
                if (q & 2) y |= mask;
            }

            return calculateTileBounds(x, y, z);
        }

        function calculateTileBounds(x, y, z) {
            const n = Math.pow(2, z);
            const west = x / n * 360 - 180;
            const east = (x + 1) / n * 360 - 180;
            const north = (Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI);
            const south = (Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI);
            return { west, south, east, north };
        }

        function tileToBounds(tile) {
            return calculateTileBounds(tile.x, tile.y, tile.z);
        }

        function getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom) {
            const tiles = [];
            const topLeft = [maxLat, minLon];
            const bottomRight = [minLat, maxLon];
            const topLeftTile = tileAtZoom(topLeft[0], topLeft[1], zoom);
            const bottomRightTile = tileAtZoom(bottomRight[0], bottomRight[1], zoom);

            for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {
                for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                    tiles.push({ x, y, z: zoom });
                }
            }
            return tiles;
        }

        // Line intersection functions
        function lineStringIntersectsBounds(lineString, bounds) {
            const lineBounds = getLineStringBounds(lineString);
            if (!boundsIntersect(lineBounds, bounds)) {
                return false;
            }

            for (let i = 1; i < lineString.length; i++) {
                const prevCoord = lineString[i - 1];
                const currCoord = lineString[i];
                if (lineSegmentIntersectsBounds(prevCoord, currCoord, bounds)) {
                    return true;
                }
            }
            return false;
        }

        function getLineStringBounds(lineString) {
            const lats = lineString.map(coord => coord[1]);
            const lngs = lineString.map(coord => coord[0]);
            return {
                west: Math.min(...lngs),
                east: Math.max(...lngs),
                south: Math.min(...lats),
                north: Math.max(...lats)
            };
        }

        function boundsIntersect(bounds1, bounds2) {
            return !(bounds1.east < bounds2.west ||
                     bounds1.west > bounds2.east ||
                     bounds1.south > bounds2.north ||
                     bounds1.north < bounds2.south);
        }

        function lineSegmentIntersectsBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;
                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;
                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    break;
                } else {
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }
            return accept;
        }

        let currentFilteredCountryQuadkeys = null;

        // Display results
        function displayResults(countryQuadkeys) {
            currentFilteredCountryQuadkeys = countryQuadkeys;
            const firstRoutePoint = getFirstRoutePoint();
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            let output = '';
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            let strFormattedDate = `'${formattedDate}'`;

            let countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                // Sort quadkeys by distance from first route point
                const sortedQuadkeys = quadkeys.map(quadkey => {
                    const bounds = quadkeyToBounds(quadkey);
                    const centerLat = (bounds.north + bounds.south) / 2;
                    const centerLng = (bounds.west + bounds.east) / 2;
                    const distance = calculateDistance(
                        [firstRoutePoint.lat, firstRoutePoint.lng],
                        [centerLat, centerLng]
                    );
                    return { quadkey, distance };
                }).sort((a, b) => a.distance - b.distance)
                  .map(item => item.quadkey);

                // Group quadkeys by zoom level
                const quadkeysByZoom = {};
                for (let qk of sortedQuadkeys) {
                    const zoomLevel = qk.length;
                    if (zoomLevel in quadkeysByZoom) {
                        quadkeysByZoom[zoomLevel].push(qk);
                    } else {
                        quadkeysByZoom[zoomLevel] = [qk];
                    }
                }

                // Build cardinality condition
                let cardinalityCondition = '';
                for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
                    let quads = getQkStringifyArray(qks);
                    cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
                }

                if (cardinalityCondition) {
                    cardinalityCondition = cardinalityCondition.slice(0, -4);
                    const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
                    countryConditions.push(countryCondition);
                }

                const count = sortedQuadkeys.length;
                output += `${country}: ${count} quadkeys\n`;
                output += sortedQuadkeys.join(',') + '\n\n';
            }

            // Combine all country conditions
            let finalCountryCondition = '';
            if (countryConditions.length > 0) {
                if (countryConditions.length === 1) {
                    finalCountryCondition = countryConditions[0];
                } else {
                    finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
                }
            }
<!--            let polygonCondition = '';-->
<!--            if (selectedAdminPolygon){-->
<!--                console.log(selectedAdminPolygon);-->
<!--                for (let poly = 0; poly < selectedAdminPolygon.length; poly++){-->
<!--                    let base = `and st_intersects(-->
<!--                        st_geometryfromtext(geometry_wkt,-->
<!--                                            ${coordinatesToWktPolygon(selectedAdminPolygon[poly].geometry.coordinates[0])}))`;-->
<!--                    polygonCondition += base;-->
<!--                }-->
<!--            }-->

            // Build the complete query
            query = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country
                from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
                where dt = ${strFormattedDate}
                and ${finalCountryCondition}
                and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;

            document.getElementById('resultsOutput').textContent = output.trim() || 'No quadkeys found for this route.';
        }

        // Get QK stringify array
        function getQkStringifyArray(qk_array){
            let qks = "";
            for (let item of qk_array){
                qks+=`'${item}',`
            }
            return qks.slice(0, -1);
        }

        // Get first point of current route
        function getFirstRoutePoint() {
            if (!currentRouteData || !currentRouteData.routes[currentRouteIndex]) {
                return { lat: 0, lng: 0 };
            }

            const route = currentRouteData.routes[currentRouteIndex];
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates && step.geometry.coordinates.length > 0) {
                        const firstCoord = step.geometry.coordinates[0];
                        return { lat: firstCoord[1], lng: firstCoord[0] };
                    }
                }
            }
            return { lat: 0, lng: 0 };
        }

        function initQuadkeySearch() {
    const searchInput = document.getElementById('searchQuadkey');
    const searchBtn = document.getElementById('searchQuadkeyBtn');
    const searchResult = document.getElementById('searchResult');
    const searchActions = document.getElementById('searchActions');
    const addSearchedBtn = document.getElementById('addSearchedQuadkeysBtn');
    const removeSearchedBtn = document.getElementById('removeSearchedQuadkeysBtn');

    let searchedQuadkeys = [];
    let searchedQuadkeysData = new Map();
    let currentHighlights = [];
    let currentSearchMarker = null;

    // Search and zoom to quadkeys
    searchBtn.addEventListener('click', async function() {
        const input = searchInput.value.trim();
        if (!input) {
            searchResult.textContent = 'Please enter quadkeys';
            searchResult.style.color = '#e74c3c';
            searchActions.style.display = 'none';
            return;
        }

        // Parse comma-separated quadkeys
        const quadkeyStrings = input.split(',').map(q => q.trim()).filter(q => q.length > 0);

        // Validate quadkey formats
        const invalidQuadkeys = quadkeyStrings.filter(q => !/^\d+$/.test(q));
        if (invalidQuadkeys.length > 0) {
            searchResult.textContent = `Invalid quadkey format: ${invalidQuadkeys.join(', ')}. Quadkeys should contain only digits.`;
            searchResult.style.color = '#e74c3c';
            searchActions.style.display = 'none';
            return;
        }

        try {
            // Clear previous highlights
            clearSearchHighlight();
            searchedQuadkeys = [];
            searchedQuadkeysData.clear();

            let combinedBounds = null;
            const results = [];

            // Process each quadkey
            for (let i = 0; i < quadkeyStrings.length; i++) {
                const quadkey = quadkeyStrings[i];

                // Get bounds for the quadkey
                const bounds = quadkeyToBounds(quadkey);

                // Store quadkey data
                searchedQuadkeys.push(quadkey);
                searchedQuadkeysData.set(quadkey, { bounds, index: i });

                // Highlight this quadkey on the map
                highlightQuadkeyOnMap(quadkey, bounds, i);

                // Get countries for this quadkey
                const countries = await getQuadkeyCountries(quadkey);

                // Create bounding box for Mapbox
                const quadkeyBounds = [
                    [bounds.west, bounds.south],
                    [bounds.east, bounds.north]
                ];

                // Update combined bounds
                if (!combinedBounds) {
                    combinedBounds = quadkeyBounds;
                } else {
                    // Extend bounds
                    combinedBounds[0][0] = Math.min(combinedBounds[0][0], quadkeyBounds[0][0]);
                    combinedBounds[0][1] = Math.min(combinedBounds[0][1], quadkeyBounds[0][1]);
                    combinedBounds[1][0] = Math.max(combinedBounds[1][0], quadkeyBounds[1][0]);
                    combinedBounds[1][1] = Math.max(combinedBounds[1][1], quadkeyBounds[1][1]);
                }

                // Add to results display
            }

            // Zoom to show all quadkeys
            if (combinedBounds) {
                map.fitBounds(combinedBounds, {
                    padding: 50,
                    maxZoom: 18
                });
            }

            // Show search results
            searchResult.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>Found ${quadkeyStrings.length} quadkey(s):</strong>
                </div>
                ${results.join('')}
            `;
            searchResult.style.color = '#333';

            // Show action buttons
            searchActions.style.display = 'block';

            // Update button states
            updateSearchActionButtons();

        } catch (error) {
            searchResult.textContent = `Error: ${error.message}`;
            searchResult.style.color = '#e74c3c';
            searchActions.style.display = 'none';
            console.error('Quadkey search error:', error);
        }
    });

    // Add all searched quadkeys to results
    addSearchedBtn.addEventListener('click', async function() {
        if (searchedQuadkeys.length === 0) {
            showStatus('No quadkeys to add', 'error');
            return;
        }

        try {
            setLoading(true);
            let addedCount = 0;

            for (const quadkey of searchedQuadkeys) {
                if (!isQuadkeyInResults(quadkey)) {
                    const data = searchedQuadkeysData.get(quadkey);
                    if (data) {
                        const countries = await getQuadkeyCountries(quadkey);
                        if (countries.length > 0) {
                            addQuadkey(quadkey, countries);
                            addedCount++;
                        }
                    }
                }
            }

            if (addedCount > 0) {
                updateDisplayAndVisualization();
                recalculateStatistics();
                if (currentCountryQuadkeys) {
                    createCountryControls(currentCountryQuadkeys, true);
                }
                showStatus(`Added ${addedCount} quadkey(s) to results`, 'success');
                updateSearchResultStatus();
            } else {
                showStatus('All quadkeys are already in results', 'info');
            }

        } catch (error) {
            showStatus(`Error adding quadkeys: ${error.message}`, 'error');
        } finally {
            setLoading(false);
        }
    });

    // Remove all searched quadkeys from results
    removeSearchedBtn.addEventListener('click', function() {
        if (searchedQuadkeys.length === 0) {
            showStatus('No quadkeys to remove', 'error');
            return;
        }

        let removedCount = 0;

        for (const quadkey of searchedQuadkeys) {
            if (isQuadkeyInResults(quadkey)) {
                const data = searchedQuadkeysData.get(quadkey);
                if (data) {
                    const countries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    if (countries.length > 0) {
                        removeQuadkey(quadkey, countries);
                        removedCount++;
                    }
                }
            }
        }

        if (removedCount > 0) {
            updateDisplayAndVisualization();
            recalculateStatistics();
            if (currentCountryQuadkeys) {
                createCountryControls(currentCountryQuadkeys, true);
            }
            showStatus(`Removed ${removedCount} quadkey(s) from results`, 'success');
            updateSearchResultStatus();
        } else {
            showStatus('None of the searched quadkeys are in results', 'info');
        }
    });

    // Allow Enter key to search
    searchInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            searchBtn.click();
        }
    });

    function clearSearchHighlight() {
        // Remove polygon highlights
        currentHighlights.forEach(sourceId => {
            if (map.getSource(sourceId)) {
                map.removeLayer(sourceId + '-fill');
                map.removeLayer(sourceId + '-line');
                map.removeSource(sourceId);
            }
        });
        currentHighlights = [];
    }

    function highlightQuadkeyOnMap(quadkey, bounds, index) {
        const sourceId = `search-highlight-${quadkey}`;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        const color = colors[index % colors.length];

        // Create GeoJSON polygon for the quadkey bounds
        const polygon = {
            type: 'Feature',
            geometry: {
                type: 'Polygon',
                coordinates: [[
                    [bounds.west, bounds.south],
                    [bounds.east, bounds.south],
                    [bounds.east, bounds.north],
                    [bounds.west, bounds.north],
                    [bounds.west, bounds.south]
                ]]
            },
            properties: {
                quadkey: quadkey,
                index: index
            }
        };

        // Add source and layers to map
        if (!map.getSource(sourceId)) {
            map.addSource(sourceId, {
                type: 'geojson',
                data: polygon
            });

            // Add fill layer
            map.addLayer({
                id: sourceId + '-fill',
                type: 'fill',
                source: sourceId,
                paint: {
                    'fill-color': color,
                    'fill-opacity': 0.3
                }
            });

            // Add border layer
            map.addLayer({
                id: sourceId + '-line',
                type: 'line',
                source: sourceId,
                paint: {
                    'line-color': color,
                    'line-width': 2,
                    'line-opacity': 0.8
                }
            });

            currentHighlights.push(sourceId);
        }
    }

    // Clear search result when input changes
    searchInput.addEventListener('input', function() {
        searchResult.textContent = '';
        searchActions.style.display = 'none';
        clearSearchHighlight();
        searchedQuadkeys = [];
        searchedQuadkeysData.clear();
    });

    // Helper function to update button states
    function updateSearchActionButtons() {
        // Enable/disable buttons based on whether quadkeys are already in results
        const hasQuadkeysNotInResults = searchedQuadkeys.some(q => !isQuadkeyInResults(q));
        const hasQuadkeysInResults = searchedQuadkeys.some(q => isQuadkeyInResults(q));

        addSearchedBtn.disabled = !hasQuadkeysNotInResults;
        removeSearchedBtn.disabled = hasQuadkeysInResults;
    }

    // Helper function to update search result status
    function updateSearchResultStatus() {
        // Update the "Already in results" status in the search results display
        updateSearchActionButtons();
    }
}

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initProcessingMode();
            initQuadkeySearch();
            // Add quadkey mode button
            document.getElementById('addQuadkeyModeBtn').addEventListener('click', function() {
                addQuadkeyMode = !addQuadkeyMode;
                removeQuadkeyMode = false;
                if (addQuadkeyMode) {
                    this.style.backgroundColor = '#28a745';
                    document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Add Quadkey Mode: Click on map to add quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Add Quadkey Mode disabled', 'info');
                }
            });

            // Remove quadkey mode button
            document.getElementById('removeQuadkeyModeBtn').addEventListener('click', function() {
                removeQuadkeyMode = !removeQuadkeyMode;
                addQuadkeyMode = false;
                if (removeQuadkeyMode) {
                    this.style.backgroundColor = '#dc3545';
                    document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode: Click on map to remove quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode disabled', 'info');
                }
            });

            showStatus('Ready. Upload a route file to begin.', 'info');
        });

        function getCurrentBbox() {
            const bounds = map.getBounds();
            return `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
        }

        function pointsEqual(p1, p2) {
            return Math.abs(p1[0] - p2[0]) < 0.000001 &&
                   Math.abs(p1[1] - p2[1]) < 0.000001;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                const intersect = ((yi > point[1]) !== (yj > point[1])) &&
                    (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function calculateLineLength(coords) {
            let totalLength = 0;

            for (let i = 0; i < coords.length - 1; i++) {
                const [lon1, lat1] = coords[i];
                const [lon2, lat2] = coords[i + 1];

                // Haversine formula
                const R = 6371000; // Earth's radius in meters
                const Ï†1 = lat1 * Math.PI / 180;
                const Ï†2 = lat2 * Math.PI / 180;
                const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
                const Î”Î» = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                         Math.cos(Ï†1) * Math.cos(Ï†2) *
                         Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                const distance = R * c;

                totalLength += distance;
            }

            return totalLength;
        }

        function connectSegments(segments) {
            if (segments.length === 0) return [];
            if (segments.length === 1) {
                const ring = segments[0].coords;
                if (!pointsEqual(ring[0], ring[ring.length - 1])) {
                    ring.push([ring[0][0], ring[0][1]]);
                }
                return [ring];
            }

            const rings = [];
            const used = new Set();

            while (used.size < segments.length) {
                let startIdx = -1;
                for (let i = 0; i < segments.length; i++) {
                    if (!used.has(i)) {
                        startIdx = i;
                        break;
                    }
                }

                if (startIdx === -1) break;

                const start = segments[startIdx];
                let ring = [...start.coords];
                used.add(startIdx);
                let currentEnd = start.last;

                let found;
                do {
                    found = false;
                    for (let i = 0; i < segments.length; i++) {
                        if (used.has(i)) continue;

                        const seg = segments[i];

                        if (pointsEqual(currentEnd, seg.first)) {
                            ring.push(...seg.coords.slice(1));
                            currentEnd = seg.last;
                            used.add(i);
                            found = true;
                            break;
                        } else if (pointsEqual(currentEnd, seg.last)) {
                            ring.push(...seg.coords.slice(0, -1).reverse());
                            currentEnd = seg.first;
                            used.add(i);
                            found = true;
                            break;
                        }
                    }
                } while (found);

                if (!pointsEqual(ring[0], ring[ring.length - 1])) {
                    ring.push([ring[0][0], ring[0][1]]);
                }

                rings.push(ring);
            }

            return rings;
        }


        function coordinatesToWktPolygon(coords) {
            // WKT requires longitude first, then latitude
            const swappedCoords = coords.map(coord => `${coord[0]} ${coord[1]}`);
            const coordsString = swappedCoords.join(',');
            return `POLYGON((${coordsString}))`;
        }


        function clearAdminQuadkeys() {
            const allLayers = map.getStyle().layers;

            // 2. Iterate and remove if name matches
            allLayers.forEach(layer => {
<!--              if (layer.id === layerNameToRemove) {-->
<!--                map.removeLayer(layer.id);-->
<!--                console.log(`Removed layer: ${layer.id}`);-->
<!--              }-->
            })
        }

        // ==================== QUADKEY GENERATION ====================
        function generateQuadkeysFromPolygon() {
            clearQuadkeyLayers();
            if (!selectedAdminPolygon) {
                return;
            }
            const zoomLevel = currentZoomLevel;
            let tmp = new Set();
            clearAdminQuadkeys();
            for (let poly_index = 0; poly_index < selectedAdminPolygon.length; poly_index++){
                const polygon = selectedAdminPolygon[poly_index].geometry;
                // Get bounding box of polygon
                const bbox = getPolygonBbox(polygon);

                // Generate quadkeys for the bounding box
                const quadkeys = generateQuadkeysForBbox(bbox, zoomLevel);
                quadkeys.forEach(qk => {
<!--                    if (!mapLayers.quadkeys.has(qk)) {-->
<!--                        mapLayers.quadkeys.set(qk, []);-->
<!--                        const layerId = `quadkey-layer-${qk}`;-->
<!--                        mapLayers.quadkeys.get(qk).push(layerId + '-fill', layerId + '-outline');-->
<!--                    }-->

                    const qk_bbox = quadkeyToBbox(qk, zoomLevel);
                    const bboxCoordinates = [[
                        [qk_bbox[0], qk_bbox[1]],
                        [qk_bbox[2], qk_bbox[1]],
                        [qk_bbox[2], qk_bbox[3]],
                        [qk_bbox[0], qk_bbox[3]],
                        [qk_bbox[0], qk_bbox[1]]
                    ]]
                    if (intersects(qk_bbox, polygon.coordinates[0])){
                        tmp.add(qk);
                    }else{
                        console.log('not intersects')
                    }
                });
                bindQuadkeyToCountry([...tmp]);
                //Filter quadkeys that are inside the polygon
                //const filteredQuadkeys = filterQuadkeysByPolygon(quadkeys, polygon, zoomLevel);

                //generatedQuadkeys = filteredQuadkeys;
            }
            //console.log(tmp)
            // Display quadkeys on map
            //displayAdminQuadkeys([...tmp], zoomLevel);

            // Update UI
            //quadkeyCount.textContent = quadkeys.length;
            //updateAdminResults(filteredQuadkeys);
        }

        function intersects(bbox, polygon) {
            const [xmin, ymin, xmax, ymax] = bbox;

            // Fast bounding box check
            if (!bboxIntersectsPolygonBbox(bbox, polygon)) {
                return false;
            }

            // Check if any polygon vertex is inside bbox
            for (const [x, y] of polygon) {
                if (x >= xmin && x <= xmax && y >= ymin && y <= ymax) {
                    return true;
                }
            }

            // Check if any bbox corner is inside polygon
            const bboxCorners = [
                [xmin, ymin],
                [xmax, ymin],
                [xmax, ymax],
                [xmin, ymax]
            ];

            for (const [x, y] of bboxCorners) {
                if (pointInPolygon(x, y, polygon)) {
                    return true;
                }
            }

            // Check for edge intersections
            return edgesIntersect(bbox, polygon);
        }

        /**
         * Fast bounding box intersection check
         */
        function bboxIntersectsPolygonBbox(bbox, polygon) {
            const [xmin, ymin, xmax, ymax] = bbox;

            // Compute polygon's bounding box
            let polyMinX = Infinity, polyMinY = Infinity;
            let polyMaxX = -Infinity, polyMaxY = -Infinity;

            for (const [x, y] of polygon) {
                polyMinX = Math.min(polyMinX, x);
                polyMinY = Math.min(polyMinY, y);
                polyMaxX = Math.max(polyMaxX, x);
                polyMaxY = Math.max(polyMaxY, y);
            }

            // Check if bounding boxes overlap
            return !(xmax < polyMinX || xmin > polyMaxX ||
                     ymax < polyMinY || ymin > polyMaxY);
        }

        /**
         * Robust point-in-polygon test (winding number algorithm)
         */
        function pointInPolygon(x, y, polygon) {
            let wn = 0; // Winding number

            for (let i = 0; i < polygon.length; i++) {
                const [x1, y1] = polygon[i];
                const [x2, y2] = polygon[(i + 1) % polygon.length];

                // Check if point is on vertex
                if (x === x1 && y === y1) {
                    return true;
                }

                // Check if point is on horizontal segment
                if (y1 === y2 && y === y1 && x > Math.min(x1, x2) && x < Math.max(x1, x2)) {
                    return true;
                }

                // Check if point is above/below the segment
                if (y1 <= y) {
                    if (y2 > y && isLeft(x1, y1, x2, y2, x, y) > 0) {
                        wn++;
                    }
                } else {
                    if (y2 <= y && isLeft(x1, y1, x2, y2, x, y) < 0) {
                        wn--;
                    }
                }
            }

            return wn !== 0;
        }

        /**
         * Check if edges intersect
         */
        function edgesIntersect(bbox, polygon) {
            const [xmin, ymin, xmax, ymax] = bbox;

            // Create bbox edges
            const bboxEdges = [
                [[xmin, ymin], [xmax, ymin]], // bottom
                [[xmax, ymin], [xmax, ymax]], // right
                [[xmax, ymax], [xmin, ymax]], // top
                [[xmin, ymax], [xmin, ymin]]  // left
            ];

            // Check each polygon edge against each bbox edge
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];

                for (const [b1, b2] of bboxEdges) {
                    if (segmentIntersectsSegment(p1, p2, b1, b2)) {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Check if two segments intersect
         */
        function segmentIntersectsSegment(a, b, c, d) {
            const [ax, ay] = a;
            const [bx, by] = b;
            const [cx, cy] = c;
            const [dx, dy] = d;

            // Check if segments share an endpoint
            if ((ax === cx && ay === cy) || (ax === dx && ay === dy) ||
                (bx === cx && by === cy) || (bx === dx && by === dy)) {
                return true;
            }

            const orient1 = orientation(ax, ay, bx, by, cx, cy);
            const orient2 = orientation(ax, ay, bx, by, dx, dy);
            const orient3 = orientation(cx, cy, dx, dy, ax, ay);
            const orient4 = orientation(cx, cy, dx, dy, bx, by);

            // General case
            if (orient1 !== orient2 && orient3 !== orient4) {
                return true;
            }

            // Special cases (collinear)
            if (orient1 === 0 && onSegment(ax, ay, cx, cy, bx, by)) return true;
            if (orient2 === 0 && onSegment(ax, ay, dx, dy, bx, by)) return true;
            if (orient3 === 0 && onSegment(cx, cy, ax, ay, dx, dy)) return true;
            if (orient4 === 0 && onSegment(cx, cy, bx, by, dx, dy)) return true;

            return false;
        }

        /**
         * Helper: orientation of three points
         * Returns: 0=collinear, 1=clockwise, 2=counterclockwise
         */
        function orientation(px, py, qx, qy, rx, ry) {
            const val = (qy - py) * (rx - qx) - (qx - px) * (ry - qy);

            if (Math.abs(val) < 1e-10) return 0; // Using epsilon for floating point
            return val > 0 ? 1 : 2;
        }

        /**
         * Helper: check if point q lies on segment pr
         */
        function onSegment(px, py, qx, qy, rx, ry) {
            return qx <= Math.max(px, rx) && qx >= Math.min(px, rx) &&
                   qy <= Math.max(py, ry) && qy >= Math.min(py, ry);
        }

        /**
         * Helper: left test for winding number algorithm
         */
        function isLeft(x1, y1, x2, y2, x, y) {
            return (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1);
        }

        let united_features = new Set();

        function displayAdminQuadkeys(quadkeys, zoom) {
            // Clear existing admin quadkey layer
            if (map.getSource('admin-quadkeys')) {
                map.removeLayer('admin-quadkeys');
                map.removeSource('admin-quadkeys');
            }
            const features = quadkeys.map(quadkey => {
                const bbox = quadkeyToBbox(quadkey, zoom);
                return {
                    type: 'Feature',
                    properties: { quadkey: quadkey, source: 'admin' },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[
                            [bbox[0], bbox[1]],
                            [bbox[2], bbox[1]],
                            [bbox[2], bbox[3]],
                            [bbox[0], bbox[3]],
                            [bbox[0], bbox[1]]
                        ]]
                    }
                };
            });

            const geoJson = {
                type: 'FeatureCollection',
                features: features
            };
            map.addSource('admin-quadkeys', {
                type: 'geojson',
                data: geoJson
            });

            map.addLayer({
                id: 'admin-quadkeys',
                type: 'fill',
                source: 'admin-quadkeys',
                paint: {
                    'fill-color': '#e74c3c',
                    'fill-opacity': 0.3,
                    'fill-outline-color': '#c0392b'
                }
            });
        }

        function getPolygonBbox(polygon) {
            let minLng = Infinity, minLat = Infinity;
            let maxLng = -Infinity, maxLat = -Infinity;

            polygon.coordinates[0].forEach(coord => {
                const [lng, lat] = coord;
                minLng = Math.min(minLng, lng);
                minLat = Math.min(minLat, lat);
                maxLng = Math.max(maxLng, lng);
                maxLat = Math.max(maxLat, lat);
            });

            return [minLng, minLat, maxLng, maxLat];
        }

        function generateQuadkeysForBbox(bbox, zoom) {
            const [minLng, minLat, maxLng, maxLat] = bbox;
            const quadkeys = new Set();

            // Convert to tile coordinates
            const minTile = lngLatToTile(minLng, minLat, zoom);
            const maxTile = lngLatToTile(maxLng, maxLat, zoom);

            minTile_x = Math.min(minTile.x, maxTile.x)
            minTile_y = Math.min(minTile.y, maxTile.y)
            maxTile_x = Math.max(minTile.x, maxTile.x)
            maxTile_y = Math.max(minTile.y, maxTile.y)

            for (let x = minTile_x; x <= maxTile_x; x++) {
                for (let y = minTile_y; y <= maxTile_y; y++) {
                    const quadkey = tileToQuadkey(x, y, zoom);
                    quadkeys.add(quadkey);
                }
            }
            return Array.from(quadkeys);
        }

        function filterQuadkeysByPolygon(quadkeys, polygon, zoom) {
            return quadkeys.filter(quadkey => {
                const bbox = quadkeyToBbox(quadkey, zoom);
                const tileCenter = [
                    (bbox[0] + bbox[2]) / 2,
                    (bbox[1] + bbox[3]) / 2
                ];
                return isPointInPolygon(tileCenter, polygon.coordinates[0]);
            });
        }

        // ==================== QUADKEY UTILITIES ====================
        function lngLatToTile(lng, lat, zoom) {
            const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
            const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) +
                1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            return { x, y };
        }

        function tileToQuadkey(x, y, zoom) {
            let quadkey = '';
            for (let i = zoom; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit += 1;
                if ((y & mask) !== 0) digit += 2;
                quadkey += digit;
            }
            return quadkey;
        }

        function quadkeyToBbox(quadkey, zoom) {
            let x = 0, y = 0;
            for (let i = zoom; i > 0; i--) {
                const mask = 1 << (i - 1);
                const digit = parseInt(quadkey[zoom - i]);
                if ((digit & 1) !== 0) x |= mask;
                if ((digit & 2) !== 0) y |= mask;
            }

            const n = Math.pow(2, zoom);
            const lon1 = x / n * 360 - 180;
            const lat1 = radToDeg(Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))));
            const lon2 = (x + 1) / n * 360 - 180;
            const lat2 = radToDeg(Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))));

            return [lon1, lat2, lon2, lat1];
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }

        function generateRoadsSQL(countryQuadkeys) {
            const firstRoutePoint = getFirstRoutePoint();
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            let strFormattedDate = `'${formattedDate}'`;

            // Build country-specific conditions
            let countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                // Sort quadkeys by distance from first route point
                const sortedQuadkeys = quadkeys.map(quadkey => {
                    const bounds = quadkeyToBounds(quadkey);
                    const centerLat = (bounds.north + bounds.south) / 2;
                    const centerLng = (bounds.west + bounds.east) / 2;
                    const distance = calculateDistance(
                        [firstRoutePoint.lat, firstRoutePoint.lng],
                        [centerLat, centerLng]
                    );
                    return { quadkey, distance };
                }).sort((a, b) => a.distance - b.distance)
                  .map(item => item.quadkey);

                // Group quadkeys by zoom level for this country
                const quadkeysByZoom = {};
                for (let qk of sortedQuadkeys) {
                    const zoomLevel = qk.length;
                    if (zoomLevel in quadkeysByZoom) {
                        quadkeysByZoom[zoomLevel].push(qk);
                    } else {
                        quadkeysByZoom[zoomLevel] = [qk];
                    }
                }

                // Build cardinality condition for this country
                let cardinalityCondition = '';
                for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
                    let quads = getQkStringifyArray(qks);
                    cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
                }

                if (cardinalityCondition) {
                    cardinalityCondition = cardinalityCondition.slice(0, -4);
                    // Create country-specific condition
                    const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
                    countryConditions.push(countryCondition);
                }
            }

            let finalCountryCondition = '';
            if (countryConditions.length > 0) {
                if (countryConditions.length === 1) {
                    finalCountryCondition = countryConditions[0];
                } else {
                    finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
                }
            }

            // Build the complete query with appropriate fields based on mode
            let selectFields = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country`;
            let endFields = '';
            if (currentProcessingMode === 'speed_limits' || currentProcessingMode === 'here_oneways') {
                endFields = `tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;
            } else if (currentProcessingMode === 'oneways'){
                endFields = `tags['highway'] in ('unclassified', 'residential', 'living_street')`;
            }
            return `${selectFields}
                from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
                where dt = ${strFormattedDate}
                and ${finalCountryCondition}
                and ${endFields}`;
        }

        // Copy SQL results to clipboard
        document.getElementById('copySqlResultsBtn').addEventListener('click', function() {
            if (!currentFilteredCountryQuadkeys && (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0)) {
                showStatus('No quadkey data available. Please add quadkeys first.', 'error');
                return;
            }

            try {
                let roadsSQL;
                   if (currentProcessingMode === 'here_oneways'){
                       roadsSQL = generateHereRoadsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});
                   } else{
                       roadsSQL = generateRoadsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});
                   }
                navigator.clipboard.writeText(roadsSQL).then(() => {
                    showStatus('Roads SQL copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = roadsSQL;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('Roads SQL copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating roads SQL: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Parse CSV file
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    csvRoadsData = parseCSV(csvContent);

                    if (csvRoadsData.length === 0) {
                        showStatus('No valid roads found in CSV file', 'error');
                        return;
                    }

                    document.getElementById('csvInputLabel').textContent = file.name;
                    document.getElementById('processCSVBtn').disabled = false;
                    showStatus(`Loaded ${csvRoadsData.length} roads from CSV`, 'success');

                } catch (error) {
                    showStatus(`Error parsing CSV: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Parse CSV content
        function parseCSV(csvContent) {
            const roads = [];
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                throw new Error('CSV file must have at least a header and one data row');
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = parseCSVLine(line);

                if (values.length < headers.length) {
                    console.warn(`Skipping line ${i}: insufficient columns`);
                    continue;
                }

                const road = {
                    id: values[headers.indexOf('\"id\"')] || '',
                    tags: values[headers.indexOf('\"tags\"')] || '{}',
                    geometry: values[headers.indexOf('\"geometry_wkt\"')] || '',
                    // Try to find country in any column
                    country: ''
                };

                // Look for country in metadata_str['iso:3166_1'] column or similar
                for (let j = 0; j < headers.length; j++) {
                    if (headers[j].includes('iso:3166_1') || headers[j].includes('country')) {
                        road.country = values[j] || '';
                        break;
                    }
                }

                // Parse tags JSON and convert to key-value pairs
                parseTags(road);

                // Parse WKT geometry
                const coords = parseWKTGeometry(road.geometry);
                if (coords && coords.length >= 2) {
                    road.coordinates = coords;
                    roads.push(road);
                } else {
                    console.warn(`Skipping road ${road.id} - invalid geometry`);
                }
            }

            return roads;
        }

        // Parse tags JSON string to key-value object
        function parseTags(road) {
            let tagsString = road.tags;
            if (!tagsString || tagsString.trim() === '') {
                return;
            }

            try {
                // Clean the tags string
                let cleanTags = tagsString.trim();
                if (cleanTags.startsWith('"') && cleanTags.endsWith('"')) {
                    cleanTags = cleanTags.slice(1, -1);
                }
                if (cleanTags.startsWith("'") && cleanTags.endsWith("'")) {
                    cleanTags = cleanTags.slice(1, -1);
                }

                // Replace single quotes with double quotes for JSON parsing
                cleanTags = cleanTags.replace(/'/g, '"');
                cleanTags = cleanTags.replace('{', '');
                cleanTags = cleanTags.replace('}', '');

                // Parse tags
                const tags = cleanTags.split(", ");
                for (let pair of tags) {
                    if (pair.includes('=')) {
                        const p = pair.indexOf('=');
                        let key = pair.substring(0, p)
                        let value = pair.substring(p+1)
                        if (key === 'geometry' || key === 'id' || key === 'tags') {
                            continue;
                        }
                        road[key] = value;
                    }
                }
            } catch (error) {
                console.warn('Error parsing tags:', error);
            }
        }

        // Extract key-value pairs from a string
        function extractKeyValuePairs(str) {
            const result = {};
            const pairs = str.match(/(\w+)\s*:\s*("[^"]*"|[^,}\s]+)/g);

            if (pairs) {
                pairs.forEach(pair => {
                    const [key, value] = pair.split(':').map(s => s.trim());
                    const cleanValue = value.replace(/^["']|["']$/g, '');
                    result[key] = cleanValue;
                });
            }

            return result;
        }

        // Simple CSV line parser
        function parseCSVLine(line) {
            const values = [];
            let currentValue = '';
            let insideQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];

                if (char === '"' && !insideQuotes) {
                    insideQuotes = true;
                } else if (char === '"' && insideQuotes) {
                    if (nextChar === '"') {
                        currentValue += '"';
                        i++; // Skip next quote
                    } else {
                        insideQuotes = false;
                    }
                } else if (char === ',' && !insideQuotes) {
                    values.push(currentValue);
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }

            values.push(currentValue);
            return values;
        }

        // Parse WKT geometry string
        function parseWKTGeometry(wkt) {
            if (!wkt) return null;

            // Handle LINESTRING WKT format
            if (wkt.toUpperCase().startsWith('LINESTRING')) {
                // Remove LINESTRING( and )
                const coordsStr = wkt.replace(/LINESTRING\s*\(/i, '').replace(/\)$/, '');
                const coordPairs = coordsStr.split(',');
                return coordPairs.map(pair => {
                    const coords = pair.trim().split(/\s+/);
                    if (coords.length >= 2) {
                        return [parseFloat(coords[0]), parseFloat(coords[1])]; // [lng, lat]
                    }
                    return null;
                }).filter(coord => coord !== null);
            }

            return null;
        }

        document.getElementById('processCSVBtn').addEventListener('click', async function() {
    if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
        showStatus('Please calculate quadkeys from a route first', 'error');
        return;
    }

    if (csvRoadsData.length === 0) {
        showStatus('Please upload a CSV file first', 'error');
        return;
    }

    setLoading(true);
    showStatus(`Processing CSV roads in ${currentProcessingMode === 'speed_limits' ? 'Speed Limits' : 'Oneways'} mode...`, 'info');

    try {
        processedRoadsGeoJSON = await processRoadsCSV(csvRoadsData, currentZoomLevel);
        document.getElementById('downloadCSVResultsBtn').disabled = false;

        const modeName = currentProcessingMode === 'speed_limits' ? 'Speed Limits' : 'Oneways';
        showStatus(`Processed ${csvRoadsData.length} roads in ${modeName} mode`, 'success');

    } catch (error) {
        showStatus(`Error processing CSV: ${error.message}`, 'error');
        console.error(error);
    } finally {
        setLoading(false);
    }
});

    let quadKeyStats = {}

        // Process CSV roads and create GeoJSON organized by country/quadkey (roads NOT shared)
async function processRoadsCSV(roads, zoomLevel) {
    quadKeyStats = {}
    // Create a map of quadkey to countries for faster lookup
    const quadkeyToCountries = new Map();
    for (const [quadkey, countries] of quadkeyCountriesMap.entries()) {
        quadkeyToCountries.set(quadkey, Array.from(countries));
    }

    // Get all quadkey bounds for intersection calculations
    const quadkeyBounds = new Map();
    for (const quadkey of quadkeyToCountries.keys()) {
        quadkeyBounds.set(quadkey, quadkeyToBounds(quadkey));
    }

    // Create GeoJSON structure organized by country and quadkey
    const geoJSONByCountryQuadkey = {};

    let assignedCount = 0;
    let totalRoads = roads.length;
    let processedCount = 0;

    for (let roadIndex = 0; roadIndex < roads.length; roadIndex++) {
        const road = roads[roadIndex];
        if (!road.coordinates || road.coordinates.length < 2) continue;

        // Get the road's country from metadata
        const roadCountry = road.country || 'UNKNOWN';

        // Find all quadkeys this road intersects with
        const intersectingQuadkeys = new Map(); // quadkey -> intersection length

        for (const [quadkey, bounds] of quadkeyBounds.entries()) {
            // Check if road intersects with this quadkey
            if (lineStringIntersectsBounds(road.coordinates, bounds)) {
                // Calculate intersection length
                const intersectionLength = calculateIntersectionLength(road.coordinates, bounds);
                if (intersectionLength > 0) {
                    intersectingQuadkeys.set(quadkey, intersectionLength);
                }
            }
        }

        // If road intersects with any quadkey, assign it to the one with largest intersection
        if (intersectingQuadkeys.size > 0) {
            // Find quadkey with maximum intersection length
            let bestQuadkey = null;
            let maxLength = 0;

            for (const [quadkey, length] of intersectingQuadkeys.entries()) {
                if (length > maxLength) {
                    maxLength = length;
                    bestQuadkey = quadkey;
                }
            }

            if (bestQuadkey) {
                assignedCount++;

                // Filter tags with default maxspeed values
                const filteredRoad = filterRoadTags(road);

                // Initialize country structure if not exists
                if (!geoJSONByCountryQuadkey[roadCountry]) {
                    geoJSONByCountryQuadkey[roadCountry] = {};
                }

                // Initialize quadkey structure if not exists
                if (!geoJSONByCountryQuadkey[roadCountry][bestQuadkey]) {
                    geoJSONByCountryQuadkey[roadCountry][bestQuadkey] = {
                        type: 'FeatureCollection',
                        features: []
                    };
                }

                // Create road feature
                const feature = {
                    type: 'Feature',
                    properties: filteredRoad,
                    geometry: {
                        type: 'LineString',
                        coordinates: road.coordinates
                    }
                };
                geoJSONByCountryQuadkey[roadCountry][bestQuadkey].features.push(feature);
            }
        }

        processedCount++;
        // Update progress percentage
        const percentage = Math.round((processedCount / totalRoads) * 100);
        if (roadIndex % 100 === 0) {
            showStatus(`Processing roads: ${percentage}% complete`, 'info');
        }

        // Allow UI to update
        if (roadIndex % 10 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    showStatus(`Processing complete: 100%`, 'success');
    showStatus(`Assigned ${assignedCount} roads to quadkeys (${roads.length - assignedCount} not assigned)`, 'success');

    return geoJSONByCountryQuadkey;
}

        document.getElementById('copySignsSqlBtn').addEventListener('click', function() {
            if (!currentFilteredCountryQuadkeys && (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0)) {
                showStatus('No quadkey data available. Please add quadkeys first.', 'error');
                return;
            }

            try {
                const signsSQL = generateSignsSQL(currentFilteredCountryQuadkeys || currentCountryQuadkeys || {});

                navigator.clipboard.writeText(signsSQL).then(() => {
                    showStatus('Signs SQL copied to clipboard!', 'success');
                }).catch(err => {
                    console.error('Copy failed:', err);
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = signsSQL;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('Signs SQL copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating signs SQL: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Global variables for signs data
        let signsCsvData = [];
        let combinedGeoJSON = null;

        // Parse Signs CSV
        document.getElementById('signsCsvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    signsCsvData = parseSignsCSV(csvContent);

                    if (signsCsvData.length === 0) {
                        showStatus('No valid signs found in CSV file', 'error');
                        return;
                    }

                    document.getElementById('signsCsvInputLabel').textContent = file.name;
                    document.getElementById('processSignsCSVBtn').disabled = false;
                    showStatus(`Loaded ${signsCsvData.length} signs from CSV`, 'success');

                } catch (error) {
                    showStatus(`Error parsing Signs CSV: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Parse Signs CSV content
        function parseSignsCSV(csvContent) {
            const signs = [];
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');

            if (lines.length < 2) {
                throw new Error('Signs CSV file must have at least a header and one data row');
            }

            const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));

            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                const values = parseCSVLine(line);

                if (values.length < headers.length) {
                    console.warn(`Skipping line ${i}: insufficient columns`);
                    continue;
                }

                const sign = {};

                // Map values to headers
                headers.forEach((header, index) => {
                    let value = values[index] || '';
                    // Remove surrounding quotes
                    if (typeof value === 'string') {
                        value = value.replace(/^["']|["']$/g, '').trim();
                    }
                    sign[header] = value;
                });

                // Try to get coordinates from different sources
                let lat = null, lon = null;

                // 1. Try from explicit lat/lon columns
                if (sign.lat && sign.lon) {
                    lat = parseFloat(sign.lat);
                    lon = parseFloat(sign.lon);
                }

                // 2. Try from geometry_wkt
                if ((!lat || !lon) && sign.geometry_wkt) {
                    const coords = parseWKTGeometry(sign.geometry_wkt);
                    if (coords && coords.length > 0) {
                        if (sign.geometry_wkt.toUpperCase().includes('POINT')) {
                            lon = coords[0][0];
                            lat = coords[0][1];
                        }
                    }
                }

                // 3. Try from coordinates column (if exists)
                if ((!lat || !lon) && sign.coordinates) {
                    try {
                        const coords = JSON.parse(sign.coordinates);
                        if (Array.isArray(coords) && coords.length >= 2) {
                            lon = coords[0];
                            lat = coords[1];
                        }
                    } catch (e) {
                        // Not JSON, try to parse as string
                        const match = sign.coordinates.match(/[-+]?\d*\.\d+|\d+/g);
                        if (match && match.length >= 2) {
                            lon = parseFloat(match[0]);
                            lat = parseFloat(match[1]);
                        }
                    }
                }

                if (lat !== null && lon !== null) {
                    sign.coordinates = [lon, lat];
                    sign.lat = lat.toString();
                    sign.lon = lon.toString();

                    // Process maxspeed
                    if (sign.detection_type) {
                        if (!sign.detection_type.toLowerCase().startsWith("speed_limit")) {
                            sign.maxspeed = sign.detection_type;
                        } else {
                            const parts = sign.detection_type.toLowerCase().split("speed_limit_");
                            sign.maxspeed = parts.length > 1 ? parts[1] : sign.detection_type;
                        }
                    }

                    // Ensure angle is a number
                    if (sign.angle) {
                        sign.angle = parseFloat(sign.angle) || 0;
                    } else {
                        sign.angle = 0;
                    }

                    signs.push(sign);
                } else {
                    console.warn(`Skipping sign ${sign.id || 'unknown'} - no valid coordinates found`);
                }
            }

            return signs;
        }

        // Process detection_type field
        function processDetectionType(detectionType) {
            if (!detectionType) return '';

            if (!detectionType.toLowerCase().startsWith("speed_limit")) {
                return detectionType;
            }

            // Extract speed limit value
            const parts = detectionType.toLowerCase().split("speed_limit_");
            if (parts.length > 1) {
                return parts[1];
            }
            return detectionType;
        }

        // Process Signs CSV and combine with roads
        document.getElementById('processSignsCSVBtn').addEventListener('click', async function() {
            if (!processedRoadsGeoJSON && signsCsvData.length === 0) {
                showStatus('Please upload CSV files first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Processing signs and combining with roads...', 'info');

            try {
                combinedGeoJSON = await combineSignsWithRoads(signsCsvData, processedRoadsGeoJSON);
                document.getElementById('downloadCombinedResultsBtn').disabled = false;
                showStatus(`Combined ${signsCsvData.length} signs with roads data`, 'success');

            } catch (error) {
                showStatus(`Error processing signs: ${error.message}`, 'error');
                console.error(error);
            } finally {
                setLoading(false);
            }
        });

        // Generate signs SQL with WKT multipolygons for each country
        function generateSignsSQL(countryQuadkeys) {
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            const strFormattedDate = `'${formattedDate}'`;

            // Get sorted countries
            const sortedCountries = Object.keys(countryQuadkeys).sort();

            // Build country-specific conditions with WKT multipolygons
            const countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                if (quadkeys.length === 0) continue;

                // Generate WKT multipolygon for this country's quadkeys
                const wktMultipolygon = generateMultipolygonWKT(quadkeys);

                if (wktMultipolygon) {
                    // Escape single quotes in WKT by doubling them
                    const escapedWKT = wktMultipolygon.replace(/'/g, "''");

                    const countryCondition = `(country in ('${country}')
                    and st_intersects(
                          st_point(lon, lat),
                          st_geometryfromtext('${escapedWKT}')
                       )
                    )`;
                    countryConditions.push(countryCondition);
                }
            }

            if (countryConditions.length === 0) {
                return '-- No quadkeys found for any country';
            }

            // Combine all country conditions with OR
            let finalCondition = '';
            if (countryConditions.length === 1) {
                finalCondition = countryConditions[0];
            } else {
                finalCondition = '(' + countryConditions.join('\nor ') + '\n)';
            }

            if (currentProcessingMode === 'speed_limits') {
                endFields = `((detection_type like ('%speed_limit%') and detection_type not like ('%road_marking%'))
                    or detection_type like ('%city%')
                    or detection_type like ('%end_of_speedlimit%')
                    or detection_type like ('%end_general%')
                    or detection_type like ('%motorway%')
                    or detection_type like ('%residential_area%'))`;
            } else if (currentProcessingMode === 'oneways'){
                endFields = `detection_type in ('oneway','no_entrance','arrow_no_left','arrow_left','arrow_right','arrow_straight','arrow_left_ahead','arrow_right_ahead','arrow_no_right')`;
            }

            // Build complete signs query
            const query = `select id, lon, lat, detection_type, angle, cluster_size, confidence, dt, supplementary_type, sub_type, is_electronic, from_tunnel, country from roads_rsd_production.source_v3_0_0_deduplicated_points
                where dt = ${strFormattedDate}
                and ${finalCondition}
                and cluster_size > 10 and confidence > 0.1 and status <> 'Deleted'
                and ${endFields}`;
            return query;
        }

                function generateMultipolygonWKT(countryQuadkeys) {
            const polygons = [];

            for (const quadkey of countryQuadkeys) {
                const bounds = quadkeyToBounds(quadkey);

                // Create polygon for this quadkey (rectangle)
                // WKT polygon format: ((west south, west north, east north, east south, west south))
                const polygon = `((${bounds.west} ${bounds.south}, ${bounds.west} ${bounds.north}, ${bounds.east} ${bounds.north}, ${bounds.east} ${bounds.south}, ${bounds.west} ${bounds.south}))`;
                polygons.push(polygon);
            }

            if (polygons.length === 0) {
                return '';
            }

            // MULTIPOLYGON format: MULTIPOLYGON(((polygon1)), ((polygon2)), ...)
            return `MULTIPOLYGON(${polygons.join(', ')})`;
        }

        // Combine signs with roads, sharing signs across border quadkeys but NOT sharing roads
async function combineSignsWithRoads(signs, roadsGeoJSON) {
    const combinedGeoJSON = {};

    // Group signs by quadkey (signs are shared across countries)
    const signsByQuadkey = new Map();

    // First, assign signs to quadkeys based on coordinates
    for (let signIndex = 0; signIndex < signs.length; signIndex++) {
        const sign = signs[signIndex];
        if (!sign.coordinates) continue;

        const [signLng, signLat] = sign.coordinates;

        // Find which quadkey this sign belongs to
        let foundQuadkey = null;

        // Check all quadkeys by their bounds
        for (const [quadkey, countries] of quadkeyCountriesMap.entries()) {
            const bounds = quadkeyToBounds(quadkey);
            if (isPointInBounds(signLng, signLat, bounds)) {
                foundQuadkey = quadkey;
                break;
            }
        }

        if (foundQuadkey) {
            if (!signsByQuadkey.has(foundQuadkey)) {
                signsByQuadkey.set(foundQuadkey, []);
            }
            signsByQuadkey.get(foundQuadkey).push(sign);
        }

        if (signIndex % 100 === 0) {
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    // Now combine: each country gets its own roads + shared signs for quadkeys
    for (const [country, quadkeys] of Object.entries(roadsGeoJSON)) {
        if (!combinedGeoJSON[country]) {
            combinedGeoJSON[country] = {};
        }

        for (const [quadkey, roadCollection] of Object.entries(quadkeys)) {
            if (!combinedGeoJSON[country][quadkey]) {
                combinedGeoJSON[country][quadkey] = {
                    type: 'FeatureCollection',
                    features: []
                };
            }

            // Add this country's roads (NOT shared)
            combinedGeoJSON[country][quadkey].features.push(...roadCollection.features);

            // Add shared signs for this quadkey (same signs for all countries)
            const signsInQuadkey = signsByQuadkey.get(quadkey) || [];
            for (const sign of signsInQuadkey) {
                const signFeature = createSignFeature(sign, country, quadkey);
                combinedGeoJSON[country][quadkey].features.push(signFeature);
            }
        }

        // Also add signs for quadkeys that this country has, even if no roads
        const countryQuadkeys = Object.keys(quadkeys);
        for (const [quadkey, signsList] of signsByQuadkey.entries()) {
            // If this country has this quadkey but no roads in it, still add signs
            if (countryQuadkeys.includes(quadkey) ||
                (quadkeyCountriesMap.has(quadkey) &&
                 Array.from(quadkeyCountriesMap.get(quadkey)).includes(country))) {

                if (!combinedGeoJSON[country][quadkey]) {
                    combinedGeoJSON[country][quadkey] = {
                        type: 'FeatureCollection',
                        features: []
                    };
                }

                // Add signs if not already added
                const existingSignIds = new Set(
                    combinedGeoJSON[country][quadkey].features
                        .filter(f => f.properties.id && f.properties.id.startsWith('sign_'))
                        .map(f => f.properties.id)
                );

                for (const sign of signsList) {
                    if (!existingSignIds.has(sign.id)) {
                        const signFeature = createSignFeature(sign, country, quadkey);
                        combinedGeoJSON[country][quadkey].features.push(signFeature);
                    }
                }
            }
        }
    }

    const totalSigns = Array.from(signsByQuadkey.values()).reduce((sum, arr) => sum + arr.length, 0);
    showStatus(`Shared ${totalSigns} signs across ${signsByQuadkey.size} quadkeys`, 'success');

    return combinedGeoJSON;
}

        function isPointInBounds(lng, lat, bounds) {
    return lng >= bounds.west && lng <= bounds.east &&
           lat >= bounds.south && lat <= bounds.north;
}

function filterRoadTags(road) {
    // Check if oneway
    const isOneway = road.oneway === 'yes' || road.oneway === '1' || road.oneway === '-1' || road.oneway === 'true';

    let filteredRoad = {
        id: road.id || ''
    };

    if (currentProcessingMode === 'speed_limits') {
        // Speed Limits mode - current functionality
        filteredRoad = filterRoadTagsSpeedLimits(road, isOneway);
    } else if (currentProcessingMode === 'oneways' || currentProcessingMode === 'here_oneways'){
        // Oneways mode - simplified output
        filteredRoad = filterRoadTagsOneways(road, isOneway);
    }
    return filteredRoad;
}

function filterRoadTagsSpeedLimits(road, isOneway) {
    const filteredRoad = {
        id: road.id || ''
    };

    // Keep only specified keys and remove any with "type" substring
    const keysToCheck = Object.keys(road);

    for (const key of keysToCheck) {
        const lowerKey = key.toLowerCase();

        // Skip if key contains "type" substring or other excluded patterns
        if (lowerKey.includes('type') || lowerKey.includes('zone') || lowerKey.includes('correction') ||
            lowerKey.includes('dt') || lowerKey.includes('advisory') || lowerKey.includes('source') ||
            lowerKey.includes('country')) {
            continue;
        }

        // Get the value and check if it's [DELETED]
        let value = road[key];
        if (value === '[DELETED]') {
            value = '0';
        }

        // Always include these specific tags if they exist
        if (lowerKey === 'oneway') {
            filteredRoad.oneway = value;
        }
        else if (lowerKey === 'junction') {
            filteredRoad.junction = value;
        }
        else if (lowerKey === 'highway') {
            // Rename highway to FRC
            filteredRoad.FRC = value;
        }
        // Include any tag with "maxspeed" substring
        else if (lowerKey.startsWith('maxspeed')) {
            filteredRoad[key] = value;
        }
    }

    // Add oneway=no if oneway key doesn't exist
    if (!filteredRoad.oneway) {
        filteredRoad.oneway = isOneway ? isOneway : 'no';
    }

    // Add default maxspeed tags based on oneway status
    if (!filteredRoad['maxspeed:conditional']) {
        filteredRoad['maxspeed_conditional'] = '0';
    }
    if (!filteredRoad['maxspeed:variable']) {
        filteredRoad['maxspeed:variable'] = '0';
    }
    if (!filteredRoad['maxspeed:hgv']) {
        filteredRoad['maxspeed_hgv'] = '0';
    }
    if (!filteredRoad['maxspeed:hgv:conditional']) {
        filteredRoad['maxspeed_hgv_conditional'] = '0';
    }
    if (!filteredRoad['maxspeed:trailer']) {
        filteredRoad['maxspeed_trailer'] = '0';
    }
    if (isOneway) {
        if (!filteredRoad.maxspeed) {
            filteredRoad.maxspeed = '0';
        }
    } else {
        // For bidirectional roads, add forward/backward tags if not present
        if (!filteredRoad['maxspeed:forward']) {
            filteredRoad['maxspeed:forward'] = '0';
        }
        if (!filteredRoad['maxspeed:backward']) {
            filteredRoad['maxspeed:backward'] = '0';
        }
        if (!filteredRoad['maxspeed:forward:conditional']) {
            filteredRoad['maxspeed_forward_conditional'] = '0';
        }
        if (!filteredRoad['maxspeed:backward:conditional']) {
            filteredRoad['maxspeed_backward_conditional'] = '0';
        }
    }

    return filteredRoad;
}

function filterRoadTagsOneways(road, isOneway) {
    const filteredRoad = {
        id: road.id || ''
    };

    // Only include these specific tags
    if (road.oneway !== undefined) {
        filteredRoad.oneway = road.oneway === '[DELETED]' ? '0' : road.oneway;
    } else {
        filteredRoad.oneway = isOneway ? isOneway : 'no';
    }

    if (road.junction !== undefined) {
        filteredRoad.junction = road.junction === '[DELETED]' ? '0' : road.junction;
    }

    if (road.highway !== undefined) {
        filteredRoad.highway = road.highway;
    }
    return filteredRoad;
}

                // Download processed roads GeoJSON
        document.getElementById('downloadCSVResultsBtn').addEventListener('click', function() {
            if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
                showStatus('No processed roads data available', 'error');
                return;
            }

            // Create a zip file with organized GeoJSON files
            const zip = new JSZip();

            for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
                const countryFolder = zip.folder(country);

                for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                    if (geojson.features.length > 0) {
                        const fileName = `${quadkey}.geojson`;
                        countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                    }
                }
            }

            // Generate and download zip file
            zip.generateAsync({ type: 'blob' }).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                let currentDate = new Date();
                let iso = currentDate.toISOString()
                a.download = `roads_${currentProcessingMode}_${iso}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                console.log('Downloaded roads organized by country/quadkey');
                showStatus(`Downloaded roads organized by country/quadkey`, 'success');
            });
        });

                // Load JSZip library dynamically
        function loadJSZip() {
            return new Promise((resolve, reject) => {
                if (typeof JSZip !== 'undefined') {
                    resolve();
                    return;
                }

                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        async function downloadCSVResults() {
    if (!processedRoadsGeoJSON || Object.keys(processedRoadsGeoJSON).length === 0) {
        showStatus('No processed roads data available', 'error');
        return;
    }

    try {
        await loadJSZip();
        const zip = new JSZip();
        let fileCount = 0;

        // Process each country
        for (const [country, quadkeys] of Object.entries(processedRoadsGeoJSON)) {
            // Only process if we have features for this country
            let hasFeatures = false;
            for (const quadkey in quadkeys) {
                if (quadkeys[quadkey].features.length > 0) {
                    hasFeatures = true;
                    break;
                }
            }

            if (!hasFeatures) continue;

            // Create folder for this country
            const countryFolder = zip.folder(country);

            // Add each quadkey's features for this country
            for (const [quadkey, geojson] of Object.entries(quadkeys)) {
                if (geojson.features.length > 0) {
                    // Create file name with country code to make it clear
                    const fileName = `${quadkey}_${country}.geojson`;
                    countryFolder.file(fileName, JSON.stringify(geojson, null, 2));
                    fileCount++;
                }
            }
        }

        // Generate and download zip file
        zip.generateAsync({ type: 'blob' }).then(function(content) {
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = `roads_by_country_strict.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showStatus(`Downloaded ${fileCount} GeoJSON files organized by country`, 'success');
        });

    } catch (error) {
        showStatus('Error creating zip file: ' + error.message, 'error');
        console.error(error);
    }
}

    </script>
</body>
</html>
