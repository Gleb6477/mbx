<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadkey Processor</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.css" type="text/css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
            gap: 20px;
        }

        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 10px 10px 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }

        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 20px;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .left-panel {
                max-width: 100%;
            }
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .left-panel {
            width: 400px;
            min-width: 400px;
        }

        .panel-title {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eaeaea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }

        input, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
            font-weight: 600;
        }

        button:hover {
            background-color: #2980b9;
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .file-input-container {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: block;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px dashed #ced4da;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .file-input-label:hover {
            background-color: #e9ecef;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .results-container {
            margin-top: 20px;
            overflow-x: auto;
        }

        .results-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .results-title {
            font-size: 1.3rem;
            color: #2c3e50;
        }

        .results-content {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            max-height: 300px;
            max-width: 920px;
            font-family: monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            overflow: scroll;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            margin-bottom: 15px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .controls button {
            flex: 1;
        }

        .secondary-btn {
            background-color: #6c757d;
        }

        .secondary-btn:hover {
            background-color: #5a6268;
        }

        .success-btn {
            background-color: #28a745;
        }

        .success-btn:hover {
            background-color: #218838;
        }

        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .route-info p {
            margin-bottom: 5px;
        }

        .route-selector {
            margin-bottom: 15px;
        }

        .performance-info {
            background: #e8f4fd;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }

        .stats-info {
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 0.9rem;
        }

        .route-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .route-controls button {
            flex: 1;
        }

        /* New styles for country controls */
        .country-controls {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            background-color: #f8f9fa;
        }

        .country-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .country-control:hover {
            background-color: #e9ecef;
        }

        .country-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .country-label {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .country-name {
            font-weight: 600;
        }

        .country-count {
            background-color: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 10px;
        }

        .border-control {
            margin-left: 10px;
            font-size: 0.8rem;
            color: #6c757d;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
            border: 1px solid #6c757d;
        }

        .border-control:hover {
            background-color: #6c757d;
            color: white;
        }

        .border-control.excluded {
            background-color: #6c757d;
            color: white;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            margin-top: 30px;
        }

        .select-all-buttons {
            display: flex;
            gap: 5px;
        }

        .select-all-buttons button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .map-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .map-controls button {
            flex: 1;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* New styles for CSV upload and processing */
        .csv-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .tab-container {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 2px solid #eaeaea;
        }

        .tab {
            padding: 10px 20px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            color: #666;
            font-weight: 600;
            transition: all 0.3s;
        }

        .tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .csv-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a6ee0;
        }

        .csv-processing-btn {
            background: linear-gradient(135deg, #4a6ee0, #764ba2);
        }

        .csv-processing-btn:hover {
            background: linear-gradient(135deg, #3a5ecf, #663aa2);
        }

        .csv-download-btn {
            background: linear-gradient(135deg, #00b09b, #96c93d);
            margin-top: 10px;
        }

        .csv-download-btn:hover {
            background: linear-gradient(135deg, #009985, #85b92d);
        }

        /* Modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .country-selection-item {
            display: flex;
            margin: 10px 0;
            padding: 4px 4px 0px 130px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .country-selection-item input {
            margin-right: 10px;
        }

        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        #confirmSelection {
            background-color: #28a745;
            color: white;
        }

        #cancelSelection {
            background-color: #6c757d;
            color: white;
        }

        .processing-mode-select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
            background-color: white;
            cursor: pointer;
        }

        .nested-options {
            margin-top: 10px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }

        .option-description {
            font-size: 0.9rem;
            color: #495057;
        }

        .option-description p {
            margin: 5px 0;
            padding-left: 20px;
            position: relative;
        }

        .option-description p:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: #3498db;
        }

        .processing-mode-select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }

        /* Mapbox GL specific styles */
        .mapboxgl-popup {
            max-width: 300px;
        }

        .mapboxgl-popup-content {
            padding: 15px;
            border-radius: 5px;
        }

        .quadkey-highlight {
            fill-opacity: 0.2;
            stroke-width: 2;
        }

        .pulse-marker {
            background: transparent;
            border: none;
        }

        .pulse-dot {
            width: 20px;
            height: 20px;
            background-color: #ff0000;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 0 0 rgba(255, 0, 0, 1);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7);
            }
            70% {
                transform: scale(1);
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }
            100% {
                transform: scale(0.95);
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Quadkey Processor</h1>
        </header>

        <div class="main-content">
            <div class="panel left-panel">
                <div class="tab-container">
                    <button class="tab active" data-tab="preferences">Settings</button>
                    <button class="tab" data-tab="route">Route</button>
                    <button class="tab" data-tab="admin">Admin</button>
                    <button class="tab" data-tab="csv">CSV</button>
                </div>

                <div id="preferences-tab" class="tab-content active">
                    <div class="input-group">
                        <label for="searchQuadkey">Quadkey Search (comma-separated for multiple)</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="text" id="searchQuadkey" placeholder="Enter quadkeys">
                            <button id="searchQuadkeyBtn" class="secondary-btn">Search & Zoom</button>
                        </div>
                        <div id="searchResult" style="margin-top: 5px; font-size: 0.9rem; color: #666;"></div>
                        <div id="searchActions" style="margin-top: 10px; display: none;">
                            <button id="addSearchedQuadkeysBtn" class="secondary-btn" style="margin-right: 10px;margin-bottom: 10px">Add All to Results</button>
                            <button id="removeSearchedQuadkeysBtn" class="secondary-btn">Remove All from Results</button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="zoomLevel">Zoom Level (for Quadkey Calculation)</label>
                        <input type="number" id="zoomLevel" min="1" max="18" value="12">
                    </div>

                    <div class="input-group">
                        <label for="processingMode">Attribute</label>
                        <div id="processingModeContainer">
                            <select id="processingMode" class="processing-mode-select">
                                <option value="speed_limits">Speed Limits</option>
                                <option value="oneways">Oneways</option>
                                <option value="here_oneways">HERE Oneways</option>
                            </select>
                        </div>
                    </div>

                    <div class="map-controls">
                        <button id="addQuadkeyModeBtn" class="secondary-btn">Add Quadkey Mode</button>
                        <button id="removeQuadkeyModeBtn" class="secondary-btn">Remove Quadkey Mode</button>
                    </div>
                </div>

                <!-- Route Processor Tab -->
                <div id="route-tab" class="tab-content">

                    <div class="input-group">
                        <label for="routeFile">Upload Route JSON File</label>
                        <div class="file-input-container">
                            <input type="file" id="routeFile" class="file-input" accept=".json">
                            <label for="routeFile" class="file-input-label" id="fileInputLabel">Choose a JSON file</label>
                        </div>
                    </div>

                    <div class="input-group route-selector" id="routeSelectorContainer" style="display: none;">
                        <label for="routeSelect">Select Route</label>
                        <select id="routeSelect"></select>
                    </div>

                    <div class="route-controls">
                        <button id="downloadRouteBtn" class="secondary-btn" disabled>Download Route GeoJSON</button>
                        <button id="copyWktBtn" class="secondary-btn" disabled>Copy WKT</button>
                    </div>

                    <div class="controls">
                        <button id="processBtn" disabled>Calculate Quadkeys</button>
                        <button id="downloadGeoJSONBtn" class="secondary-btn" disabled>Download Results GeoJSON</button>
                    </div>

                    <!-- Country Controls Section -->
                    <div id="countryControlsContainer" style="display: none;">
                        <div class="controls-header">
                            <h3 class="panel-title">Country Controls</h3>
                            <div class="select-all-buttons">
                                <button id="selectAllBtn" class="secondary-btn">All</button>
                                <button id="selectNoneBtn" class="secondary-btn">None</button>
                            </div>
                        </div>
                        <div class="country-controls" id="countryControls">
                            <!-- Country controls will be dynamically added here -->
                        </div>
                    </div>
                </div>

<!--                <div class="route-info" id="routeInfo" style="display: none;">-->
<!--                    <p><strong>Route Information</strong></p>-->
<!--                    <p id="routeDetails"></p>-->
<!--                </div>-->
                <div id="admin-tab" class="tab-content">
                    <div class="csv-section">
                        <div class="input-group">
                            <label for="adminLevel">Admin Level</label>
                            <select id="adminLevel">
                                <option value="2">Country (level 2)</option>
                                <option value="4">Region/State (level 4)</option>
                                <option value="6">County (level 6)</option>
                                <option value="8" selected>Municipality (level 8)</option>
                                <option value="9">Local (level 9)</option>
                                <option value="10">Neighborhood (level 10)</option>
                            </select>
                        </div>
                    </div>

                    <div class="input-group">
                        <label for="countryFilter">Country Filter (optional)</label>
                        <input type="text" id="countryFilter" placeholder="e.g., Spain, France">
                    </div>

                    <div class="controls">
                        <button id="queryAdminBtn" class="admin-btn">Query Admin Boundaries</button>
                        <button id="clearAdminBtn" class="secondary-btn">Clear Admin</button>
                    </div>

                    <div class="controls">
                        <button id="splitQuadkeysBtn" class="quadkey-btn">Generate Quadkeys from Selected</button>
                    </div>
                </div>
<!--                <div id="adminInfo" class="info-box admin-info" style="display: none;">-->
<!--                    <p><strong>Selected Polygon:</strong> <span id="selectedPolygonName">None</span></p>-->
<!--                    <p><strong>OSM ID:</strong> <span id="selectedPolygonId">-</span></p>-->
<!--                    <p><strong>Admin Level:</strong> <span id="selectedAdminLevel">-</span></p>-->
<!--                    <p><strong>Area Quadkeys:</strong> <span id="quadkeyCount">0</span></p>-->
<!--                </div>-->

                <!-- CSV Upload Section -->
                <div id="csv-tab" class="tab-content">
                    <div class="csv-section">
                        <div class="input-group">
                            <label for="csvFile">Upload Roads CSV File</label>
                            <div class="file-input-container">
                                <input type="file" id="csvFile" class="file-input" accept=".csv">
                                <label for="csvFile" class="file-input-label" id="csvInputLabel">Choose a Roads CSV file</label>
                            </div>
                        </div>

                        <button id="processCSVBtn" class="csv-processing-btn" disabled>Process Roads CSV</button>
                        <button id="downloadCSVResultsBtn" class="csv-download-btn" disabled>Download Roads GeoJSON</button>
                    </div>


                    <div class="csv-section" style="margin-top: 20px;">
                        <h3 class="panel-title">Signs CSV Processing</h3>

                        <div class="input-group">
                            <label for="signsCsvFile">Upload Signs CSV File</label>
                            <div class="file-input-container">
                                <input type="file" id="signsCsvFile" class="file-input" accept=".csv">
                                <label for="signsCsvFile" class="file-input-label" id="signsCsvInputLabel">Choose a Signs CSV file</label>
                            </div>
                        </div>

                        <button id="processSignsCSVBtn" class="csv-processing-btn" disabled>Process Signs CSV</button>
                        <button id="downloadCombinedResultsBtn" class="csv-download-btn" disabled>Download Combined GeoJSON</button>
                    </div>
                </div>
                <div class="status-message" id="statusMessage"></div>

                <div class="loading" id="loadingIndicator">
                    <div class="spinner"></div>
                    <p>Processing route data...</p>
                </div>
            </div>
            <div class="panel">
                <h2 class="panel-title">Map & Results</h2>

                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="results-container">
                    <div class="results-header">
                        <h3 class="results-title">Quadkeys Results</h3>
                        <div style="display: flex">
                            <button id="copyResultsBtn" class="secondary-btn" style="margin-left:20px" disabled>Copy Results</button>
                            <button id="copySqlResultsBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy roads SQL</button>
                            <button id="copySignsSqlBtn" class="secondary-btn" style="margin-left:10px" disabled>Copy signs SQL</button>
                        </div>
                    </div>
                    <div class="results-content" id="resultsOutput">
                        No results yet. Upload a route file and click "Calculate Quadkeys".
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-geocoder/v5.0.0/mapbox-gl-geocoder.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src='https://unpkg.com'></script>
    <script>
        // Global variables
        let map;
        let currentRouteData = null;
        let currentRouteIndex = 0;
        let countryCache = {};
        let processingController = null;
        let currentCountryQuadkeys = null;
        let quadkeyCountriesMap = new Map();
        let countryControlsState = {};
        let countryBorderExclusions = new Set();
        let addQuadkeyMode = false;
        let removeQuadkeyMode = false;
        let currentZoomLevel = 12;
        let originalStats = null;
        let csvRoadsData = [];
        let processedRoadsGeoJSON = null;
        let query = '';
        let selectedAdminPolygon = []
        const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2NvdHRzZmFybGV5OTMiLCJhIjoiY2o4ODJxNjh4MWVndjJ3cWI5ODRlZ2hnayJ9.w9-dF3jh-GtQzk9h0wBUbw';
        mapboxgl.accessToken = MAPBOX_TOKEN;

        // Admin elements
        const queryAdminBtn = document.getElementById('queryAdminBtn');
        const clearAdminBtn = document.getElementById('clearAdminBtn');
        const splitQuadkeysBtn = document.getElementById('splitQuadkeysBtn');
        const adminInfo = document.getElementById('adminInfo');
        const selectedPolygonName = document.getElementById('selectedPolygonName');
        const selectedPolygonId = document.getElementById('selectedPolygonId');
        const selectedAdminLevel = document.getElementById('selectedAdminLevel');
        const quadkeyCount = document.getElementById('quadkeyCount');

        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');

        // Map layers management
        let mapLayers = {
            route: 'route-line',
            quadkeys: new Map(),
            searchHighlights: new Map(),
            searchMarkers: []
        };

        // Initialize map
        function initMap() {
            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v12',
                center: [0, 20],
                zoom: 2,
                attributionControl: false
            });

            // Add navigation controls
            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            // Add geocoder
            const geocoder = new MapboxGeocoder({
                accessToken: mapboxgl.accessToken,
                mapboxgl: mapboxgl,
                marker: false,
                placeholder: 'Search',
                countries: '',
                types: 'place,locality,neighborhood,address,region',
                bbox: [-180, -90, 180, 90]
            });

            map.addControl(geocoder, 'top-left');

            // Initialize click handler
            map.on('click', handleMapClick);

            // Initialize geocoder result handler
            geocoder.on('result', function(e) {
                const result = e.result;
            });
        }

        // ==================== TAB MANAGEMENT ====================
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                currentTab = tabId;

                // Update tabs
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Update tab contents
                tabContents.forEach(content => {
                    content.classList.remove('active');
                    if (content.id === `${tabId}-tab`) {
                        content.classList.add('active');
                    }
                });
            });
        });

        // ==================== ADMIN BOUNDARIES ====================
        queryAdminBtn.addEventListener('click', queryAdminBoundaries);
        clearAdminBtn.addEventListener('click', clearAdminBoundaries);
        splitQuadkeysBtn.addEventListener('click', generateQuadkeysFromPolygon);

        async function queryAdminBoundaries() {
            const adminLevel = document.getElementById('adminLevel').value;
            const countryFilter = document.getElementById('countryFilter').value;

            const bbox = getCurrentBbox();
            let query = `[out:json][timeout:90];
(
  relation["boundary"="administrative"]["admin_level"="${adminLevel}"](${bbox});
`;

            if (countryFilter) {
                const countries = countryFilter.split(',').map(c => c.trim());
                countries.forEach(country => {
                    query += `  relation["boundary"="administrative"]["admin_level"="${adminLevel}"]["name"="${country}"](${bbox});\n`;
                });
            }

            query += `);
(._;>;);
out body;
>;
out skel qt;`;

            try {
                const encodedQuery = encodeURIComponent(query);
                const response = await fetch(
                    `https://overpass-api.de/api/interpreter?data=${encodedQuery}`
                );

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const osmData = await response.json();
                processAdminData(osmData, adminLevel);

            } catch (error) {
                showStatus(`Error fetching boundaries: ${error.message}`, 'error');
            }
        }

        function processAdminData(osmData, adminLevel) {
            const nodes = {};
            const ways = {};
            const relations = {};
            // Build lookup tables
            osmData.elements.forEach(element => {
                switch (element.type) {
                    case 'node':
                        nodes[element.id] = [element.lon, element.lat];
                        break;
                    case 'way':
                        ways[element.id] = element;
                        break;
                    case 'relation':
                        relations[element.id] = element;
                        break;
                }
            });

            // Process each relation
            adminFeatures = [];

            Object.values(relations).forEach(relation => {
                if (!relation.tags || relation.tags.boundary !== 'administrative') return;

                const relationFeatures = processRelation(relation, ways, nodes);
                if (relationFeatures) {
                    adminFeatures.push(...relationFeatures);
                }
            });

            console.log(`Processed ${adminFeatures.length} admin polygons`);
            showStatus(`Found ${adminFeatures.length} admin boundaries`, 'success');

            displayAdminBoundaries();
            updateStats();
        }

        function processRelation(relation, ways, nodes) {
            if (!relation.members) return null;

            const outerSegments = [];
            const innerSegments = [];

            relation.members.forEach(member => {
                if (member.type === 'way' && ways[member.ref]) {
                    const way = ways[member.ref];
                    const coords = way.nodes
                        .map(nodeId => nodes[nodeId])
                        .filter(coord => coord !== undefined);

                    if (coords.length > 1) {
                        if (member.role === 'outer') {
                            outerSegments.push({
                                coords: coords,
                                first: coords[0],
                                last: coords[coords.length - 1]
                            });
                        } else if (member.role === 'inner') {
                            innerSegments.push({
                                coords: coords,
                                first: coords[0],
                                last: coords[coords.length - 1]
                            });
                        }
                    }
                }
            });

            if (outerSegments.length === 0) return null;

            const outerRings = connectSegments(outerSegments);
            const innerRings = connectSegments(innerSegments);

            const features = [];

            outerRings.forEach((outerRing, index) => {
                const belongingInnerRings = innerRings.filter(innerRing =>
                    isPointInPolygon(innerRing[0], outerRing)
                );

                const coordinates = [outerRing];
                belongingInnerRings.forEach(innerRing => {
                    coordinates.push(innerRing);
                });

                features.push({
                    type: 'Feature',
                    properties: {
                        name: relation.tags.name || relation.tags['name:es'] || 'Unnamed',
                        admin_level: relation.tags.admin_level,
                        osm_id: relation.id,
                        osm_type: 'relation',
                        part_index: index,
                        total_parts: outerRings.length,
                        isClicked: false,
                        isHighlighted: false,
                        ...relation.tags
                    },
                    geometry: {
                        type: 'Polygon',
                        coordinates: coordinates
                    }
                });
            });

            return features;
        }

        function displayAdminBoundaries() {
            if (adminFeatures.length === 0) {
                showStatus('No admin boundaries to display', 'info');
                return;
            }

            // Clear existing admin layers
            if (map.getSource('admin-boundaries')) {
                map.removeLayer('admin-boundaries-fill');
                map.removeLayer('admin-boundaries-outline');
                map.removeSource('admin-boundaries');
            }

            const geoJson = {
                type: 'FeatureCollection',
                features: adminFeatures
            };

            map.addSource('admin-boundaries', {
                type: 'geojson',
                data: geoJson
            });

            // Add fill layer
            map.addLayer({
                id: 'admin-boundaries-fill',
                type: 'fill',
                source: 'admin-boundaries',
                paint: {
                    'fill-color': [
                        'case',
                        ['==', ['get', 'isClicked'], true], '#FFE66D',
                        ['==', ['get', 'isHighlighted'], true], '#FF6B6B',
                        '#4ECDC4'
                    ],
                    'fill-opacity': [
                        'case',
                        ['==', ['get', 'isClicked'], true], 0.8,
                        ['==', ['get', 'isHighlighted'], true], 0.6,
                        0.4
                    ],
                    'fill-outline-color': '#333'
                }
            });

            // Add outline layer
            map.addLayer({
                id: 'admin-boundaries-outline',
                type: 'line',
                source: 'admin-boundaries',
                paint: {
                    'line-color': [
                        'case',
                        ['==', ['get', 'isClicked'], true], '#333',
                        ['==', ['get', 'isHighlighted'], true], '#C44569',
                        '#333'
                    ],
                    'line-width': [
                        'case',
                        ['==', ['get', 'isClicked'], true], 3,
                        ['==', ['get', 'isHighlighted'], true], 2,
                        1
                    ],
                    'line-opacity': 0.8
                }
            });

            setupAdminInteractions();
        }

        function setupAdminInteractions() {
            map.off('click', 'admin-boundaries-fill');
            map.off('mouseenter', 'admin-boundaries-fill');
            map.off('mouseleave', 'admin-boundaries-fill');

            map.on('click', 'admin-boundaries-fill', (e) => {
                if (e.features.length === 0) return;

                const clickedFeature = e.features[0];
                const clickedName = clickedFeature.properties.name;
                const clickedId = clickedFeature.id;

                console.log(`Clicked: ${clickedName} (ID: ${clickedId})`);

                // Update all features
                adminFeatures.forEach(feature => {
                    feature.properties.isClicked = false;
                    feature.properties.isHighlighted = false;

                    if (feature.properties.name === clickedName) {
                        if (feature.properties.osm_id === clickedFeature.properties.osm_id &&
                            feature.properties.part_index === clickedFeature.properties.part_index) {
                            feature.properties.isClicked = true;
                        } else {
                            feature.properties.isHighlighted = true;
                        }
                        selectedAdminPolygon.push(feature);
                    }
                });

                // Update source
                const source = map.getSource('admin-boundaries');
                if (source) {
                    const updatedGeoJson = {
                        type: 'FeatureCollection',
                        features: adminFeatures
                    };
                    source.setData(updatedGeoJson);
                }

                // Update UI
                updateAdminInfo(clickedFeature);
                splitQuadkeysBtn.disabled = false;
                currentHighlightName = clickedName;

                // Show info
                const sameNameCount = adminFeatures.filter(f =>
                    f.properties.name === clickedName
                ).length;

                showStatus(`Selected ${clickedName} (${sameNameCount} polygons)`, 'success');
                updateStats();
            });

            map.on('mouseenter', 'admin-boundaries-fill', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'admin-boundaries-fill', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        function updateAdminInfo(feature) {
            selectedPolygonName.textContent = feature.properties.name;
            selectedPolygonId.textContent = feature.properties.osm_id;
            selectedAdminLevel.textContent = feature.properties.admin_level;
            adminInfo.style.display = 'block';
        }

        function clearAdminBoundaries() {
            if (map.getSource('admin-boundaries')) {
                map.removeLayer('admin-boundaries-fill');
                map.removeLayer('admin-boundaries-outline');
                map.removeSource('admin-boundaries');
            }

            if (map.getSource('admin-quadkeys')) {
                map.removeLayer('admin-quadkeys');
                map.removeSource('admin-quadkeys');
            }

            adminFeatures = [];
            generatedQuadkeys = [];
            selectedAdminPolygon = [];
            adminInfo.style.display = 'none';
            splitQuadkeysBtn.disabled = true;
        }

        async function bindQuadkeyToCountry(qk) {
            const countries = await getQuadkeyCountries(qk);
            if (countries.length > 1) {
                showCountrySelectionModal(qk, countries, 'add');
            } else {
                addQuadkey(qk, countries);
                updateDisplayAndVisualization();
                recalculateStatistics();

                if (currentCountryQuadkeys) {
                    createCountryControls(currentCountryQuadkeys, true);
                }
            }
        }

        // Handle map click
        async function handleMapClick(e) {
            if (!addQuadkeyMode && !removeQuadkeyMode) return;

            const zoom = parseInt(document.getElementById('zoomLevel').value);
            const tile = tileAtZoom(e.lngLat.lat, e.lngLat.lng, zoom);
            const quadkey = toQuadkey(tile.x, tile.y, zoom);

            // Get countries for this quadkey
            const countries = await getQuadkeyCountries(quadkey);

            if (addQuadkeyMode) {
                if (countries.length > 1) {
                    showCountrySelectionModal(quadkey, countries, 'add');
                } else {
                    addQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            } else if (removeQuadkeyMode) {
                if (!quadkeyCountriesMap.has(quadkey) && (!currentCountryQuadkeys ||
                    !Object.values(currentCountryQuadkeys).flat().includes(quadkey))) {
                    showStatus(`Quadkey ${quadkey} not found in current data`, 'error');
                    return;
                }

                if (countries.length > 1 && quadkeyCountriesMap.has(quadkey)) {
                    const currentCountries = Array.from(quadkeyCountriesMap.get(quadkey) || []);
                    showCountrySelectionModal(quadkey, currentCountries, 'remove');
                } else {
                    removeQuadkey(quadkey, countries);
                    updateDisplayAndVisualization();
                    recalculateStatistics();

                    if (currentCountryQuadkeys) {
                        createCountryControls(currentCountryQuadkeys, true);
                    }
                }
            }
        }

        // Show country selection modal
        function showCountrySelectionModal(quadkey, countries, action) {
            const modalHTML = `
                <div id="countrySelectionModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <h3>Select Countries for Quadkey: ${quadkey}</h3>
                        <p>This quadkey spans multiple countries. Choose which countries to ${action}:</p>
                        <div id="countrySelectionList">
                            ${countries.map(country => `
                                <div class="country-selection-item">
                                    <label for="sel-${country}">${country}</label>
                                    <input type="checkbox" id="sel-${country}" style="width:20px;height:20px;margin-left:30px; margin-top:3px" value="${country}" checked>
                                </div>
                            `).join('')}
                        </div>
                        <div class="modal-buttons">
                            <button id="confirmSelection">Confirm</button>
                            <button id="cancelSelection">Cancel</button>
                        </div>
                    </div>
                </div>
            `;

            const modalContainer = document.createElement('div');
            modalContainer.innerHTML = modalHTML;
            document.body.appendChild(modalContainer);

            document.getElementById('confirmSelection').addEventListener('click', function() {
                const selectedCountries = [];
                countries.forEach(country => {
                    const checkbox = document.getElementById(`sel-${country}`);
                    if (checkbox.checked) {
                        selectedCountries.push(country);
                    }
                });

                if (selectedCountries.length > 0) {
                    if (action === 'add') {
                        addQuadkey(quadkey, selectedCountries);
                    } else {
                        removeQuadkey(quadkey, selectedCountries);
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                    createCountryControls(currentCountryQuadkeys, true);
                }

                document.body.removeChild(modalContainer);
            });

            document.getElementById('cancelSelection').addEventListener('click', function() {
                document.body.removeChild(modalContainer);
            });

            document.getElementById('countrySelectionModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    document.body.removeChild(modalContainer);
                }
            });
        }

        // Convert route to WKT format
        function convertRouteToWKT(route) {
            if (!route || !route.legs) {
                throw new Error('Invalid route data');
            }

            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No coordinates found in route');
            }

            const wktCoordinates = allCoords.map(coord => `${coord[0]} ${coord[1]}`).join(', ');
            return `LINESTRING (${wktCoordinates})`;
        }

        // Copy WKT to clipboard
        document.getElementById('copyWktBtn').addEventListener('click', function() {
            if (!currentRouteData) {
                showStatus('No route data available', 'error');
                return;
            }

            try {
                const route = currentRouteData.routes[currentRouteIndex];
                const wkt = convertRouteToWKT(route);

                navigator.clipboard.writeText(wkt).then(() => {
                    showStatus('WKT copied to clipboard!', 'success');
                }).catch(() => {
                    const textArea = document.createElement('textarea');
                    textArea.value = wkt;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    showStatus('WKT copied to clipboard!', 'success');
                });
            } catch (error) {
                showStatus(`Error generating WKT: ${error.message}`, 'error');
                console.error(error);
            }
        });

        // Add a quadkey to results
        function addQuadkey(quadkey, countries) {
            if (!quadkeyCountriesMap) {
                quadkeyCountriesMap = new Map();
            }
            if (!currentCountryQuadkeys) {
                currentCountryQuadkeys = {};
            }
            if (!countryControlsState) {
                countryControlsState = {};
            }

            quadkeyCountriesMap.set(quadkey, new Set(countries));

            countries.forEach(country => {
                if (!currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = [];
                }
                if (!currentCountryQuadkeys[country].includes(quadkey)) {
                    currentCountryQuadkeys[country].push(quadkey);
                    currentCountryQuadkeys[country].sort();
                }

                countryControlsState[country] = true;
            });

            showStatus(`Added quadkey ${quadkey} for countries: ${countries.join(', ')}`, 'success');

            if (Object.keys(currentCountryQuadkeys).length > 0) {
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            }
        }

        // Remove a quadkey
        function removeQuadkey(quadkey, countries) {
            countries.forEach(country => {
                if (currentCountryQuadkeys && currentCountryQuadkeys[country]) {
                    currentCountryQuadkeys[country] = currentCountryQuadkeys[country].filter(q => q !== quadkey);
                    if (currentCountryQuadkeys[country].length === 0) {
                        delete currentCountryQuadkeys[country];
                        delete countryControlsState[country];
                    }
                }
            });

            if (quadkeyCountriesMap) {
                const currentCountries = quadkeyCountriesMap.get(quadkey);
                if (currentCountries) {
                    countries.forEach(country => currentCountries.delete(country));
                    if (currentCountries.size === 0) {
                        quadkeyCountriesMap.delete(quadkey);
                    }
                }
            }

            showStatus(`Removed quadkey ${quadkey} from countries: ${countries.join(', ')}`, 'success');

            if (!currentCountryQuadkeys || Object.keys(currentCountryQuadkeys).length === 0) {
                document.getElementById('copySqlResultsBtn').disabled = true;
                document.getElementById('copySignsSqlBtn').disabled = true;
                document.getElementById('countryControlsContainer').style.display = 'none';
            }
        }

        // Initialize processing mode
        function initProcessingMode() {
            const processingModeSelect = document.getElementById('processingMode');
            currentProcessingMode = processingModeSelect.value;

            processingModeSelect.addEventListener('change', function() {
                currentProcessingMode = this.value;
                if (currentCountryQuadkeys) {
                    updateDisplayAndVisualization();
                }
            });
        }

        // Recalculate statistics
        function recalculateStatistics() {
            if (!currentCountryQuadkeys) return;

            let totalQuadkeys = 0;
            let borderQuadkeys = 0;
            let totalCountries = new Set();
            const seenQuadkeys = new Set();

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                totalCountries.add(country);
                quadkeys.forEach(quadkey => {
                    if (!seenQuadkeys.has(quadkey)) {
                        seenQuadkeys.add(quadkey);
                        totalQuadkeys++;
                        const countries = quadkeyCountriesMap.get(quadkey);
                        if (countries && countries.size > 1) {
                            borderQuadkeys++;
                        }
                    }
                });
            }

            const statsEl = document.getElementById('statsDetails');
            statsEl.textContent = `Found ${totalQuadkeys} quadkeys, ${borderQuadkeys} border quadkeys across ${totalCountries.size} countries`;
        }

        // Show status message
        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';

            if (type === 'success') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Show/hide loading indicator
        function setLoading(loading) {
            document.getElementById('loadingIndicator').style.display = loading ? 'block' : 'none';
            document.getElementById('processBtn').disabled = loading;

            if (loading && processingController) {
                processingController.abort();
            }
            processingController = new AbortController();
        }

        // Fast country detection using Mapbox Geocoding
        async function reverseGeocodeCountry(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;

            if (countryCache[cacheKey]) {
                return countryCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?types=country&access_token=${MAPBOX_TOKEN}`,
                    {
                        signal: processingController?.signal
                    }
                );

                if (!response.ok) {
                    throw new Error(`Mapbox API error: ${response.status}`);
                }

                const data = await response.json();
                let countryCode = 'UNKNOWN';
                if (data.features && data.features.length > 0) {
                    const place = data.features[0];
                    countryCode = place.properties?.short_code?.toUpperCase() || 'UNKNOWN';
                }

                countryCache[cacheKey] = countryCode;
                return countryCode;

            } catch (error) {
                if (error.name === 'AbortError') throw error;
                console.warn(`Mapbox geocoding failed for (${lat}, ${lng}):`, error);
                return 'UNKNOWN';
            }
        }

        // Get countries for a quadkey
        async function getQuadkeyCountries(quadkey) {
            const bounds = quadkeyToBounds(quadkey);
            const countries = new Set();

            const samplePoints = [
                [bounds.north, bounds.west],
                [bounds.north, bounds.east],
                [bounds.south, bounds.west],
                [bounds.south, bounds.east],
                [(bounds.north + bounds.south) / 2, (bounds.west + bounds.east) / 2]
            ];

            const promises = samplePoints.map(([lat, lng]) => reverseGeocodeCountry(lat, lng));
            const results = await Promise.all(promises);

            results.forEach(country => {
                if (country && country !== 'UNKNOWN') {
                    countries.add(country);
                }
            });

            return Array.from(countries);
        }

        // Parse uploaded JSON file
        document.getElementById('routeFile').addEventListener('change', function(e) {
            currentCountryQuadkeys = null;
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    if (!data.routes || !Array.isArray(data.routes)) {
                        throw new Error('Invalid route file format. Expected "routes" array.');
                    }

                    currentRouteData = data;
                    countryCache = {};

                    document.getElementById('fileInputLabel').textContent = file.name;

                    const routeSelect = document.getElementById('routeSelect');
                    routeSelect.innerHTML = '';

                    data.routes.forEach((route, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = `Route ${index + 1}`;
                        routeSelect.appendChild(option);
                    });

                    document.getElementById('routeSelectorContainer').style.display = 'block';
                    document.getElementById('processBtn').disabled = false;
                    document.getElementById('downloadRouteBtn').disabled = false;
                    document.getElementById('copyWktBtn').disabled = false;

                    loadRoute(0);
                    showStatus('Route file loaded successfully!', 'success');
                } catch (error) {
                    showStatus(`Error parsing JSON: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            reader.readAsText(file);
        });

        // Handle route selection change
        document.getElementById('routeSelect').addEventListener('change', function(e) {
            const routeIndex = parseInt(e.target.value);
            loadRoute(routeIndex);
        });

        // Load a route onto the map
        function loadRoute(routeIndex) {
            if (!currentRouteData || !currentRouteData.routes[routeIndex]) {
                showStatus('Invalid route selected', 'error');
                return;
            }

            currentRouteIndex = routeIndex;
            const route = currentRouteData.routes[routeIndex];

            // Remove existing route layer
            if (map.getSource('route')) {
                map.removeLayer('route-line');
                map.removeSource('route');
            }

            const allCoords = [];
            let totalDistance = 0;
            let waypointCount = 0;

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    const geom = step.geometry;
                    if (geom.type === 'LineString' && geom.coordinates) {
                        const latLngs = geom.coordinates.map(coord => [coord[0], coord[1]]);
                        allCoords.push(...latLngs);

                        if (latLngs.length > 1) {
                            for (let i = 1; i < latLngs.length; i++) {
                                totalDistance += calculateDistance(latLngs[i-1], latLngs[i]);
                            }
                        }

                        waypointCount += latLngs.length;
                    }
                });
            });

            // Create route GeoJSON
            const routeFeature = {
                type: 'Feature',
                geometry: {
                    type: 'LineString',
                    coordinates: allCoords
                },
                properties: {
                    name: `Route ${currentRouteIndex + 1}`
                }
            };

            // Add route to map
            map.addSource('route', {
                type: 'geojson',
                data: routeFeature
            });

            map.addLayer({
                id: 'route-line',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#3498db',
                    'line-width': 4,
                    'line-opacity': 0.7
                }
            });

            // Fit bounds to route
            const bounds = getBoundingBox(routeFeature);
            map.fitBounds([[bounds.xMin, bounds.yMin], [bounds.xMax, bounds.yMax]], {
                padding: 50
            });

            document.getElementById('routeInfo').style.display = 'block';
            document.getElementById('routeDetails').textContent =
                `Distance: ${(totalDistance / 1000).toFixed(2)} km, Waypoints: ${waypointCount}, Legs: ${route.legs.length}`;

            clearQuadkeyLayers();
            document.getElementById('resultsOutput').textContent =
                'No results yet. Click "Calculate Quadkeys" to process this route.';
            document.getElementById('copyResultsBtn').disabled = true;
            document.getElementById('copySqlResultsBtn').disabled = true;
            document.getElementById('copySignsSqlBtn').disabled = true;
            document.getElementById('downloadGeoJSONBtn').disabled = true;
            document.getElementById('statsInfo').style.display = 'none';
            document.getElementById('countryControlsContainer').style.display = 'none';
            document.getElementById('copyWktBtn').style.display = 'block';

            // Reset modes
            addQuadkeyMode = false;
            removeQuadkeyMode = false;
            document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
            document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
        }

        // Calculate distance between two coordinates
        function calculateDistance(coord1, coord2) {
            const R = 6371e3;
            const Ï†1 = coord1[0] * Math.PI / 180;
            const Ï†2 = coord2[0] * Math.PI / 180;
            const Î”Ï† = (coord2[0] - coord1[0]) * Math.PI / 180;
            const Î”Î» = (coord2[1] - coord1[1]) * Math.PI / 180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                     Math.cos(Ï†1) * Math.cos(Ï†2) *
                     Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // Get bounding box
        function getBoundingBox(data) {
            var bounds = {}, coords, point, latitude, longitude;
            coords = data.geometry.coordinates;
            for (var j = 0; j < coords.length; j++) {
                longitude = coords[j][0];
                latitude = coords[j][1];
                bounds.xMin = bounds.xMin < longitude ? bounds.xMin : longitude;
                bounds.xMax = bounds.xMax > longitude ? bounds.xMax : longitude;
                bounds.yMin = bounds.yMin < latitude ? bounds.yMin : latitude;
                bounds.yMax = bounds.yMax > latitude ? bounds.yMax : latitude;
            }
            return bounds;
        }

        // Process route to calculate quadkeys
        document.getElementById('processBtn').addEventListener('click', async function() {
            if (!currentRouteData) {
                showStatus('Please upload a route file first', 'error');
                return;
            }

            setLoading(true);
            showStatus('Calculating quadkeys using bounding box approach...', 'info');

            try {
                const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
                currentZoomLevel = zoomLevel;
                const route = currentRouteData.routes[currentRouteIndex];

                const startTime = Date.now();
                var { countryQuadkeys, stats, quadkeyCountries } = await getRouteQuadkeysWithCountriesBBox(
                    route,
                    zoomLevel
                );
                const processingTime = (Date.now() - startTime) / 1000;

                currentCountryQuadkeys = countryQuadkeys;
                quadkeyCountriesMap = quadkeyCountries;
                originalStats = stats;

                // Initialize all countries as enabled
                countryControlsState = {};
                countryBorderExclusions.clear();
                Object.keys(countryQuadkeys).forEach(country => {
                    countryControlsState[country] = true;
                });

                createCountryControls(countryQuadkeys, false);
                updateDisplayAndVisualization();

                // Show statistics
                document.getElementById('statsInfo').style.display = 'block';
                document.getElementById('statsDetails').textContent =
                    `Found ${stats.totalQuadkeys} quadkeys, ${stats.borderQuadkeys} border quadkeys in ${processingTime.toFixed(1)}s`;

                showStatus(`Found ${stats.totalQuadkeys} quadkeys across ${Object.keys(countryQuadkeys).length} countries`, 'success');

                document.getElementById('downloadGeoJSONBtn').disabled = false;
                document.getElementById('copyResultsBtn').disabled = false;
                document.getElementById('copySqlResultsBtn').disabled = false;
                document.getElementById('copySignsSqlBtn').disabled = false;
                document.getElementById('countryControlsContainer').style.display = 'block';
            } catch (error) {
                if (error.name !== 'AbortError') {
                    showStatus(`Error calculating quadkeys: ${error.message}`, 'error');
                    console.error(error);
                }
            } finally {
                setLoading(false);
            }
        });

        // Get quadkeys for a route using bounding box approach
        async function getRouteQuadkeysWithCountriesBBox(route, zoom) {
            var stats = {
                totalQuadkeys: 0,
                borderQuadkeys: 0
            };

            // Extract all coordinates
            const allLineStrings = [];
            const allCoords = [];

            route.legs.forEach(leg => {
                leg.steps.forEach(step => {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates) {
                        allLineStrings.push(step.geometry.coordinates);
                        allCoords.push(...step.geometry.coordinates);
                    }
                });
            });

            if (allCoords.length === 0) {
                throw new Error('No valid coordinates found in route');
            }

            // Get bounding box
            const lats = allCoords.map(coord => coord[1]);
            const lngs = allCoords.map(coord => coord[0]);

            const minLon = Math.min(...lngs);
            const minLat = Math.min(...lats);
            const maxLon = Math.max(...lngs);
            const maxLat = Math.max(...lats);

            showStatus(`Route bounds: ${minLon.toFixed(4)}, ${minLat.toFixed(4)} to ${maxLon.toFixed(4)}, ${maxLat.toFixed(4)}`, 'info');

            // Get all tiles in bounding box
            const tiles = getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom);
            showStatus(`Checking ${tiles.length} tiles for intersection...`, 'info');

            const quadkeyCountries = new Map();

            // Check which tiles intersect with route
            for (let i = 0; i < tiles.length; i++) {
                if (processingController?.signal.aborted) {
                    throw new DOMException('Aborted', 'AbortError');
                }

                const tile = tiles[i];
                const quadkey = toQuadkey(tile.x, tile.y, zoom);
                const tileBounds = tileToBounds(tile);

                let intersects = false;
                for (const lineString of allLineStrings) {
                    if (lineStringIntersectsBounds(lineString, tileBounds)) {
                        intersects = true;
                        break;
                    }
                }

                if (intersects) {
                    const countries = await getQuadkeyCountries(quadkey);
                    if (countries.length > 1) {
                        stats.borderQuadkeys++;
                    }
                    quadkeyCountries.set(quadkey, new Set(countries));

                    if (i % 10 === 0) {
                        showStatus(`Processing tiles... ${Math.round((i / tiles.length) * 100)}%`, 'info');
                    }
                }
            }

            stats.totalQuadkeys = quadkeyCountries.size;

            // Convert to country->quadkeys mapping
            const countryQuadkeys = {};
            for (const [quadkey, countries] of quadkeyCountries.entries()) {
                for (const country of countries) {
                    if (!countryQuadkeys[country]) {
                        countryQuadkeys[country] = new Set();
                    }
                    countryQuadkeys[country].add(quadkey);
                }
            }

            // Convert Sets to Arrays and sort
            const result = {};
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                result[country] = Array.from(quadkeys).sort();
            }

            return {
                countryQuadkeys: result,
                stats,
                quadkeyCountries: quadkeyCountries
            };
        }

        // Create country controls UI
        function createCountryControls(countryQuadkeys, qkManipulationEvent) {
            const container = document.getElementById('countryControls');
            container.innerHTML = '';

            const sortedCountries = Object.keys(countryQuadkeys).sort();

            sortedCountries.forEach(country => {
                const quadkeys = countryQuadkeys[country];
                const count = quadkeys.length;

                const controlDiv = document.createElement('div');
                controlDiv.className = 'country-control';
                const check = qkManipulationEvent ? (countryControlsState[country] ? 'checked' : '') : 'checked';

                controlDiv.innerHTML = `
                    <input type="checkbox" class="country-checkbox" id="chk-${country}" ${check}>
                    <div class="country-label">
                        <span class="country-name">${country}</span>
                        <span class="country-count">${count}</span>
                    </div>
                    <button class="border-control" data-country="${country}" title="Exclude border quadkeys for ${country}">No Borders</button>
                `;

                container.appendChild(controlDiv);

                // Add event listener for checkbox
                const checkbox = controlDiv.querySelector('.country-checkbox');
                checkbox.addEventListener('change', function() {
                    countryControlsState[country] = this.checked;
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });

                // Add event listener for border control
                const borderBtn = controlDiv.querySelector('.border-control');
                borderBtn.addEventListener('click', function() {
                    const country = this.getAttribute('data-country');
                    if (countryBorderExclusions.has(country)) {
                        countryBorderExclusions.delete(country);
                        this.classList.remove('excluded');
                        this.textContent = 'No Borders';
                    } else {
                        countryBorderExclusions.add(country);
                        this.classList.add('excluded');
                        this.textContent = 'With Borders';
                    }
                    updateDisplayAndVisualization();
                    recalculateStatistics();
                });
            });
        }

        // Update display and visualization
        function updateDisplayAndVisualization() {
            if (!currentCountryQuadkeys) {
                document.getElementById('resultsOutput').textContent = 'No quadkeys found.';
                clearQuadkeyLayers();
                return;
            }

            // Filter quadkeys based on country controls and border exclusions
            const filteredCountryQuadkeys = {};

            for (const [country, quadkeys] of Object.entries(currentCountryQuadkeys)) {
                if (countryControlsState[country]) {
                    let filteredQuadkeys = [...quadkeys];

                    if (countryBorderExclusions && countryBorderExclusions.has(country)) {
                        filteredQuadkeys = filteredQuadkeys.filter(quadkey => {
                            const countries = quadkeyCountriesMap.get(quadkey);
                            return countries && countries.size === 1 && countries.has(country);
                        });
                    }

                    if (filteredQuadkeys.length > 0) {
                        filteredCountryQuadkeys[country] = filteredQuadkeys;
                    }
                }
            }

            displayResults(filteredCountryQuadkeys);
            visualizeQuadkeys(filteredCountryQuadkeys, currentZoomLevel);
        }

        // Select all countries
        document.getElementById('selectAllBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = true;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = true;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Select none countries
        document.getElementById('selectNoneBtn').addEventListener('click', function() {
            Object.keys(countryControlsState).forEach(country => {
                countryControlsState[country] = false;
                const checkbox = document.getElementById(`chk-${country}`);
                if (checkbox) checkbox.checked = false;
            });
            updateDisplayAndVisualization();
            recalculateStatistics();
        });

        // Visualize quadkeys on map
        function visualizeQuadkeys(countryQuadkeys, zoom) {
            clearQuadkeyLayers();

            if (!countryQuadkeys || Object.keys(countryQuadkeys).length === 0) {
                return;
            }

            const colors = [
                '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
                '#1abc9c', '#d35400', '#c0392b', '#16a085', '#8e44ad'
            ];

            let colorIndex = 0;
            const countryColors = {};
            const quadkeyCountries = new Map();

            // First pass: count how many countries each quadkey belongs to
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                for (const quadkey of quadkeys) {
                    if (!quadkeyCountries.has(quadkey)) {
                        quadkeyCountries.set(quadkey, new Set());
                    }
                    quadkeyCountries.get(quadkey).add(country);
                }
            }

            // Second pass: visualize with appropriate colors
            for (const [country, quadkeys] of Object.entries(countryQuadkeys)) {
                if (!countryColors[country]) {
                    countryColors[country] = colors[colorIndex % colors.length];
                    colorIndex++;
                }

                const baseColor = countryColors[country];

                for (const quadkey of quadkeys) {
                    const bounds = quadkeyToBounds(quadkey);
                    const countriesForQuadkey = quadkeyCountries.get(quadkey);

                    let color, fillOpacity;
                    if (countriesForQuadkey.size > 1) {
                        color = '#ffeb3b';
                        fillOpacity = 0.3;
                    } else {
                        color = baseColor;
                        fillOpacity = 0.3;
                    }

                    // Create polygon GeoJSON for quadkey
                    const polygonGeoJSON = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [[
                                [bounds.west, bounds.south],
                                [bounds.west, bounds.north],
                                [bounds.east, bounds.north],
                                [bounds.east, bounds.south],
                                [bounds.west, bounds.south]
                            ]]
                        },
                        properties: {
                            quadkey: quadkey,
                            country: country,
                            isBorder: countriesForQuadkey.size > 1
                        }
                    };

                    const sourceId = `quadkey-${quadkey}`;
                    const layerId = `quadkey-layer-${quadkey}`;

                    // Add source
                    map.addSource(sourceId, {
                        type: 'geojson',
                        data: polygonGeoJSON
                    });

                    // Add fill layer
                    map.addLayer({
                        id: layerId + '-fill',
                        type: 'fill',
                        source: sourceId,
                        paint: {
                            'fill-color': color,
                            'fill-opacity': fillOpacity
                        }
                    });

                    // Add outline layer
                    map.addLayer({
                        id: layerId + '-outline',
                        type: 'line',
                        source: sourceId,
                        paint: {
                            'line-color': color,
                            'line-width': 2
                        }
                    });

                    // Store layer references
                    if (!mapLayers.quadkeys.has(quadkey)) {
                        mapLayers.quadkeys.set(quadkey, []);
                    }
                    mapLayers.quadkeys.get(quadkey).push(layerId + '-fill', layerId + '-outline');

                    // Add click handler
                    map.on('click', layerId + '-fill', (e) => {
                        if (removeQuadkeyMode) {
                            const clickedQuadkey = quadkey;
                            const countries = Array.from(quadkeyCountriesMap.get(clickedQuadkey) || []);

                            if (countries.length > 1) {
                                showCountrySelectionModal(clickedQuadkey, countries, 'remove');
                            } else {
                                removeQuadkey(clickedQuadkey, countries);
                                updateDisplayAndVisualization();
                                recalculateStatistics();
                                if (currentCountryQuadkeys) {
                                    createCountryControls(currentCountryQuadkeys, true);
                                }
                            }
                        } else {
                            navigator.clipboard.writeText(quadkey).then(() => {
                                showStatus('Quadkey copied to clipboard!', 'success');
                            }).catch(err => {
                                console.error('Copy failed:', err);
                            });
                        }
                    });

                    // Change cursor on hover
                    map.on('mouseenter', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });

                    map.on('mouseleave', layerId + '-fill', () => {
                        map.getCanvas().style.cursor = '';
                    });
                }
            }
        }

        // Clear quadkey layers from map
        function clearQuadkeyLayers() {
            mapLayers.quadkeys.forEach((layers, quadkey) => {
                layers.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });
                const sourceId = `quadkey-${quadkey}`;
                if (map.getSource(sourceId)) {
                    map.removeSource(sourceId);
                }
            });
            mapLayers.quadkeys.clear();
        }

        document.getElementById('zoomLevel').addEventListener('click', function() {
            currentZoomLevel = document.getElementById('zoomLevel').value;
        })

        // Copy results to clipboard
        document.getElementById('copyResultsBtn').addEventListener('click', function() {
            const resultsText = document.getElementById('resultsOutput').textContent;

            navigator.clipboard.writeText(resultsText).then(() => {
                showStatus('Results copied to clipboard!', 'success');
            }).catch(err => {
                showStatus('Failed to copy results to clipboard', 'error');
                console.error('Copy failed:', err);
            });
        });

        // Quadkey utility functions
        function tileAtZoom(lat, lng, zoom) {
            const latRad = lat * Math.PI / 180;
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const y = Math.floor((1 - Math.asinh(Math.tan(latRad)) / Math.PI) / 2 * n);
            return { x, y, z: zoom };
        }

        function toQuadkey(x, y, z) {
            let quadkey = '';
            for (let i = z; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit += 1;
                if ((y & mask) !== 0) digit += 2;
                quadkey += digit.toString();
            }
            return quadkey;
        }

        function quadkeyToBounds(quadkey) {
            let x = 0, y = 0;
            const z = quadkey.length;

            for (let i = z; i > 0; i--) {
                const mask = 1 << (i - 1);
                const q = parseInt(quadkey[z - i]);
                if (q & 1) x |= mask;
                if (q & 2) y |= mask;
            }

            return calculateTileBounds(x, y, z);
        }

        function calculateTileBounds(x, y, z) {
            const n = Math.pow(2, z);
            const west = x / n * 360 - 180;
            const east = (x + 1) / n * 360 - 180;
            const north = (Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI);
            const south = (Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI);
            return { west, south, east, north };
        }

        function tileToBounds(tile) {
            return calculateTileBounds(tile.x, tile.y, tile.z);
        }

        function getTilesInBounds(minLon, minLat, maxLon, maxLat, zoom) {
            const tiles = [];
            const topLeft = [maxLat, minLon];
            const bottomRight = [minLat, maxLon];
            const topLeftTile = tileAtZoom(topLeft[0], topLeft[1], zoom);
            const bottomRightTile = tileAtZoom(bottomRight[0], bottomRight[1], zoom);

            for (let x = topLeftTile.x; x <= bottomRightTile.x; x++) {
                for (let y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                    tiles.push({ x, y, z: zoom });
                }
            }
            return tiles;
        }

        // Line intersection functions
        function lineStringIntersectsBounds(lineString, bounds) {
            const lineBounds = getLineStringBounds(lineString);
            if (!boundsIntersect(lineBounds, bounds)) {
                return false;
            }

            for (let i = 1; i < lineString.length; i++) {
                const prevCoord = lineString[i - 1];
                const currCoord = lineString[i];
                if (lineSegmentIntersectsBounds(prevCoord, currCoord, bounds)) {
                    return true;
                }
            }
            return false;
        }

        function getLineStringBounds(lineString) {
            const lats = lineString.map(coord => coord[1]);
            const lngs = lineString.map(coord => coord[0]);
            return {
                west: Math.min(...lngs),
                east: Math.max(...lngs),
                south: Math.min(...lats),
                north: Math.max(...lats)
            };
        }

        function boundsIntersect(bounds1, bounds2) {
            return !(bounds1.east < bounds2.west ||
                     bounds1.west > bounds2.east ||
                     bounds1.south > bounds2.north ||
                     bounds1.north < bounds2.south);
        }

        function lineSegmentIntersectsBounds(coord1, coord2, bounds) {
            let [x1, y1] = coord1;
            let [x2, y2] = coord2;

            const INSIDE = 0;
            const LEFT = 1;
            const RIGHT = 2;
            const BOTTOM = 4;
            const TOP = 8;

            function computeOutCode(x, y) {
                let code = INSIDE;
                if (x < bounds.west) code |= LEFT;
                else if (x > bounds.east) code |= RIGHT;
                if (y < bounds.south) code |= BOTTOM;
                else if (y > bounds.north) code |= TOP;
                return code;
            }

            let outcode1 = computeOutCode(x1, y1);
            let outcode2 = computeOutCode(x2, y2);
            let accept = false;

            while (true) {
                if (!(outcode1 | outcode2)) {
                    accept = true;
                    break;
                } else if (outcode1 & outcode2) {
                    break;
                } else {
                    let x, y;
                    const outcodeOut = outcode1 ? outcode1 : outcode2;

                    if (outcodeOut & TOP) {
                        x = x1 + (x2 - x1) * (bounds.north - y1) / (y2 - y1);
                        y = bounds.north;
                    } else if (outcodeOut & BOTTOM) {
                        x = x1 + (x2 - x1) * (bounds.south - y1) / (y2 - y1);
                        y = bounds.south;
                    } else if (outcodeOut & RIGHT) {
                        y = y1 + (y2 - y1) * (bounds.east - x1) / (x2 - x1);
                        x = bounds.east;
                    } else if (outcodeOut & LEFT) {
                        y = y1 + (y2 - y1) * (bounds.west - x1) / (x2 - x1);
                        x = bounds.west;
                    }

                    if (outcodeOut === outcode1) {
                        x1 = x;
                        y1 = y;
                        outcode1 = computeOutCode(x1, y1);
                    } else {
                        x2 = x;
                        y2 = y;
                        outcode2 = computeOutCode(x2, y2);
                    }
                }
            }
            return accept;
        }

        // Display results
        function displayResults(countryQuadkeys) {
            const firstRoutePoint = getFirstRoutePoint();
            const sortedCountries = Object.keys(countryQuadkeys).sort();
            let output = '';
            const currentDate = new Date();
            currentDate.setDate(currentDate.getDate() - 2);
            const formattedDate = currentDate.toLocaleDateString('en-CA');
            let strFormattedDate = `'${formattedDate}'`;

            let countryConditions = [];

            for (const country of sortedCountries) {
                const quadkeys = countryQuadkeys[country];

                // Sort quadkeys by distance from first route point
                const sortedQuadkeys = quadkeys.map(quadkey => {
                    const bounds = quadkeyToBounds(quadkey);
                    const centerLat = (bounds.north + bounds.south) / 2;
                    const centerLng = (bounds.west + bounds.east) / 2;
                    const distance = calculateDistance(
                        [firstRoutePoint.lat, firstRoutePoint.lng],
                        [centerLat, centerLng]
                    );
                    return { quadkey, distance };
                }).sort((a, b) => a.distance - b.distance)
                  .map(item => item.quadkey);

                // Group quadkeys by zoom level
                const quadkeysByZoom = {};
                for (let qk of sortedQuadkeys) {
                    const zoomLevel = qk.length;
                    if (zoomLevel in quadkeysByZoom) {
                        quadkeysByZoom[zoomLevel].push(qk);
                    } else {
                        quadkeysByZoom[zoomLevel] = [qk];
                    }
                }

                // Build cardinality condition
                let cardinalityCondition = '';
                for (const [zoom, qks] of Object.entries(quadkeysByZoom)) {
                    let quads = getQkStringifyArray(qks);
                    cardinalityCondition += `cardinality(filter(metadata_array['quadkey_z${zoom}'], x -> x in (${quads})))>0 or `;
                }

                if (cardinalityCondition) {
                    cardinalityCondition = cardinalityCondition.slice(0, -4);
                    const countryCondition = `(metadata_str['iso:3166_1'] = '${country}' and (${cardinalityCondition}))`;
                    countryConditions.push(countryCondition);
                }

                const count = sortedQuadkeys.length;
                output += `${country}: ${count} quadkeys\n`;
                output += sortedQuadkeys.join(',') + '\n\n';
            }

            // Combine all country conditions
            let finalCountryCondition = '';
            if (countryConditions.length > 0) {
                if (countryConditions.length === 1) {
                    finalCountryCondition = countryConditions[0];
                } else {
                    finalCountryCondition = '(' + countryConditions.join(' or ') + ')';
                }
            }

            // Build the complete query
            query = `select id, tags, geometry_wkt, metadata_str['iso:3166_1'] as country
                from roads_production.road_pipeline_corrections_v1_1_0_metadata_corrected_osm_roads_enriched
                where dt = ${strFormattedDate}
                and ${finalCountryCondition}
                and tags['highway'] in ('motorway', 'trunk', 'motorway_link', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link', 'tertiary', 'unclassified', 'residential', 'tertiary_link')`;

            document.getElementById('resultsOutput').textContent = output.trim() || 'No quadkeys found for this route.';
        }

        // Get QK stringify array
        function getQkStringifyArray(qk_array){
            let qks = "";
            for (let item of qk_array){
                qks+=`'${item}',`
            }
            return qks.slice(0, -1);
        }

        // Get first point of current route
        function getFirstRoutePoint() {
            if (!currentRouteData || !currentRouteData.routes[currentRouteIndex]) {
                return { lat: 0, lng: 0 };
            }

            const route = currentRouteData.routes[currentRouteIndex];
            for (const leg of route.legs) {
                for (const step of leg.steps) {
                    if (step.geometry.type === 'LineString' && step.geometry.coordinates && step.geometry.coordinates.length > 0) {
                        const firstCoord = step.geometry.coordinates[0];
                        return { lat: firstCoord[1], lng: firstCoord[0] };
                    }
                }
            }
            return { lat: 0, lng: 0 };
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            initProcessingMode();

            // Add quadkey mode button
            document.getElementById('addQuadkeyModeBtn').addEventListener('click', function() {
                addQuadkeyMode = !addQuadkeyMode;
                removeQuadkeyMode = false;
                if (addQuadkeyMode) {
                    this.style.backgroundColor = '#28a745';
                    document.getElementById('removeQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Add Quadkey Mode: Click on map to add quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Add Quadkey Mode disabled', 'info');
                }
            });

            // Remove quadkey mode button
            document.getElementById('removeQuadkeyModeBtn').addEventListener('click', function() {
                removeQuadkeyMode = !removeQuadkeyMode;
                addQuadkeyMode = false;
                if (removeQuadkeyMode) {
                    this.style.backgroundColor = '#dc3545';
                    document.getElementById('addQuadkeyModeBtn').style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode: Click on map to remove quadkeys', 'info');
                } else {
                    this.style.backgroundColor = '';
                    showStatus('Remove Quadkey Mode disabled', 'info');
                }
            });

            showStatus('Ready. Upload a route file to begin.', 'info');
        });

        function getCurrentBbox() {
            const bounds = map.getBounds();
            return `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
        }

        function pointsEqual(p1, p2) {
            return Math.abs(p1[0] - p2[0]) < 0.000001 &&
                   Math.abs(p1[1] - p2[1]) < 0.000001;
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i][0], yi = polygon[i][1];
                const xj = polygon[j][0], yj = polygon[j][1];

                const intersect = ((yi > point[1]) !== (yj > point[1])) &&
                    (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function connectSegments(segments) {
            if (segments.length === 0) return [];
            if (segments.length === 1) {
                const ring = segments[0].coords;
                if (!pointsEqual(ring[0], ring[ring.length - 1])) {
                    ring.push([ring[0][0], ring[0][1]]);
                }
                return [ring];
            }

            const rings = [];
            const used = new Set();

            while (used.size < segments.length) {
                let startIdx = -1;
                for (let i = 0; i < segments.length; i++) {
                    if (!used.has(i)) {
                        startIdx = i;
                        break;
                    }
                }

                if (startIdx === -1) break;

                const start = segments[startIdx];
                let ring = [...start.coords];
                used.add(startIdx);
                let currentEnd = start.last;

                let found;
                do {
                    found = false;
                    for (let i = 0; i < segments.length; i++) {
                        if (used.has(i)) continue;

                        const seg = segments[i];

                        if (pointsEqual(currentEnd, seg.first)) {
                            ring.push(...seg.coords.slice(1));
                            currentEnd = seg.last;
                            used.add(i);
                            found = true;
                            break;
                        } else if (pointsEqual(currentEnd, seg.last)) {
                            ring.push(...seg.coords.slice(0, -1).reverse());
                            currentEnd = seg.first;
                            used.add(i);
                            found = true;
                            break;
                        }
                    }
                } while (found);

                if (!pointsEqual(ring[0], ring[ring.length - 1])) {
                    ring.push([ring[0][0], ring[0][1]]);
                }

                rings.push(ring);
            }

            return rings;
        }

        function updateStats() {
<!--            statsQuadkeys.textContent = generatedQuadkeys.length + routeQuadkeys.length;-->
<!--            statsSelected.textContent = selectedAdminPolygon ? selectedAdminPolygon.properties.name : 'None';-->
        }

<!--        function filterQuadkeysInSelectedPolygons(polygon, qk){-->
<!--            bboxIntersectsPolygon(polygon, qk);-->
<!--        }-->

        // ==================== QUADKEY GENERATION ====================
        function generateQuadkeysFromPolygon() {
            if (!selectedAdminPolygon) {
                return;
            }
            const zoomLevel = currentZoomLevel;
            let tmp = new Set();
            for (let poly_index = 0; poly_index < selectedAdminPolygon.length; poly_index++){
                const polygon = selectedAdminPolygon[poly_index].geometry;
                console.log(polygon)
                // Get bounding box of polygon
                const bbox = getPolygonBbox(polygon);

                // Generate quadkeys for the bounding box
                const quadkeys = generateQuadkeysForBbox(bbox, zoomLevel);

                quadkeys.forEach(qk => {
                    if (intersects(bbox, polygon.coordinates[0])){
                        tmp.add(qk);
                        bindQuadkeyToCountry(qk);
                    }
                });
                //Filter quadkeys that are inside the polygon
                //const filteredQuadkeys = filterQuadkeysByPolygon(quadkeys, polygon, zoomLevel);

                //generatedQuadkeys = filteredQuadkeys;
            }
            console.log(tmp)
            // Display quadkeys on map
            //displayAdminQuadkeys([...tmp], zoomLevel);

            // Update UI
            //quadkeyCount.textContent = quadkeys.length;
            //updateAdminResults(filteredQuadkeys);
        }

        /**
         * SAT-based intersection test (works for convex polygons)
         */
        function intersects(bbox, polygon) {
            const [xmin, ymin, xmax, ymax] = bbox;

            // Convert bbox to polygon
            const bboxPoly = [
                [xmin, ymin],
                [xmax, ymin],
                [xmax, ymax],
                [xmin, ymax]
            ];

            // Get axes to test (normals of all edges)
            const axes = [];

            // Add bbox normals
            axes.push([1, 0]);  // x-axis (horizontal edges)
            axes.push([0, 1]);  // y-axis (vertical edges)

            // Add polygon normals
            for (let i = 0; i < polygon.length; i++) {
                const p1 = polygon[i];
                const p2 = polygon[(i + 1) % polygon.length];

                const edge = [p2[0] - p1[0], p2[1] - p1[1]];
                const normal = [-edge[1], edge[0]]; // perpendicular
                axes.push(normalize(normal));
            }

            // Test all axes for separation
            for (const axis of axes) {
                const [ax, ay] = axis;

                // Project bbox onto axis
                let bboxMin = Infinity, bboxMax = -Infinity;
                for (const [x, y] of bboxPoly) {
                    const projection = x * ax + y * ay;
                    bboxMin = Math.min(bboxMin, projection);
                    bboxMax = Math.max(bboxMax, projection);
                }

                // Project polygon onto axis
                let polyMin = Infinity, polyMax = -Infinity;
                for (const [x, y] of polygon) {
                    const projection = x * ax + y * ay;
                    polyMin = Math.min(polyMin, projection);
                    polyMax = Math.max(polyMax, projection);
                }

                // Check for separation
                if (bboxMax < polyMin || bboxMin > polyMax) {
                    return false; // Found a separating axis
                }
            }

            return true; // No separating axis found
        }

        function normalize(vector) {
            const [x, y] = vector;
            const length = Math.sqrt(x * x + y * y);
            if (length === 0) return [0, 0];
            return [x / length, y / length];
        }

        let united_features = new Set();

        function displayAdminQuadkeys(quadkeys, zoom) {
            // Clear existing admin quadkey layer
            if (map.getSource('admin-quadkeys')) {
                map.removeLayer('admin-quadkeys');
                map.removeSource('admin-quadkeys');
            }
            const features = quadkeys.map(quadkey => {
                const bbox = quadkeyToBbox(quadkey, zoom);
                return {
                    type: 'Feature',
                    properties: { quadkey: quadkey, source: 'admin' },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[
                            [bbox[0], bbox[1]],
                            [bbox[2], bbox[1]],
                            [bbox[2], bbox[3]],
                            [bbox[0], bbox[3]],
                            [bbox[0], bbox[1]]
                        ]]
                    }
                };
            });

            const geoJson = {
                type: 'FeatureCollection',
                features: features
            };
            map.addSource('admin-quadkeys', {
                type: 'geojson',
                data: geoJson
            });

            map.addLayer({
                id: 'admin-quadkeys',
                type: 'fill',
                source: 'admin-quadkeys',
                paint: {
                    'fill-color': '#e74c3c',
                    'fill-opacity': 0.3,
                    'fill-outline-color': '#c0392b'
                }
            });
        }

        function getPolygonBbox(polygon) {
            let minLng = Infinity, minLat = Infinity;
            let maxLng = -Infinity, maxLat = -Infinity;

            polygon.coordinates[0].forEach(coord => {
                const [lng, lat] = coord;
                minLng = Math.min(minLng, lng);
                minLat = Math.min(minLat, lat);
                maxLng = Math.max(maxLng, lng);
                maxLat = Math.max(maxLat, lat);
            });

            return [minLng, minLat, maxLng, maxLat];
        }

        function generateQuadkeysForBbox(bbox, zoom) {
            const [minLng, minLat, maxLng, maxLat] = bbox;
            const quadkeys = new Set();

            // Convert to tile coordinates
            const minTile = lngLatToTile(minLng, minLat, zoom);
            const maxTile = lngLatToTile(maxLng, maxLat, zoom);

            minTile_x = Math.min(minTile.x, maxTile.x)
            minTile_y = Math.min(minTile.y, maxTile.y)
            maxTile_x = Math.max(minTile.x, maxTile.x)
            maxTile_y = Math.max(minTile.y, maxTile.y)

            for (let x = minTile_x; x <= maxTile_x; x++) {
                for (let y = minTile_y; y <= maxTile_y; y++) {
                    const quadkey = tileToQuadkey(x, y, zoom);
                    quadkeys.add(quadkey);
                }
            }
            return Array.from(quadkeys);
        }

        function filterQuadkeysByPolygon(quadkeys, polygon, zoom) {
            return quadkeys.filter(quadkey => {
                const bbox = quadkeyToBbox(quadkey, zoom);
                const tileCenter = [
                    (bbox[0] + bbox[2]) / 2,
                    (bbox[1] + bbox[3]) / 2
                ];
                return isPointInPolygon(tileCenter, polygon.coordinates[0]);
            });
        }

        // ==================== QUADKEY UTILITIES ====================
        function lngLatToTile(lng, lat, zoom) {
            const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
            const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) +
                1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            return { x, y };
        }

        function tileToQuadkey(x, y, zoom) {
            let quadkey = '';
            for (let i = zoom; i > 0; i--) {
                let digit = 0;
                const mask = 1 << (i - 1);
                if ((x & mask) !== 0) digit += 1;
                if ((y & mask) !== 0) digit += 2;
                quadkey += digit;
            }
            return quadkey;
        }

        function quadkeyToBbox(quadkey, zoom) {
            let x = 0, y = 0;
            for (let i = zoom; i > 0; i--) {
                const mask = 1 << (i - 1);
                const digit = parseInt(quadkey[zoom - i]);
                if ((digit & 1) !== 0) x |= mask;
                if ((digit & 2) !== 0) y |= mask;
            }

            const n = Math.pow(2, zoom);
            const lon1 = x / n * 360 - 180;
            const lat1 = radToDeg(Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))));
            const lon2 = (x + 1) / n * 360 - 180;
            const lat2 = radToDeg(Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))));

            return [lon1, lat2, lon2, lat1];
        }

        function radToDeg(rad) {
            return rad * 180 / Math.PI;
        }
    </script>
</body>
</html>
